<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>简单实践spring框架-手写Spring-MVC</title>
    <url>/posts/b874e66d/</url>
    <content><![CDATA[<h2 id="Spring-MVC篇"><a href="#Spring-MVC篇" class="headerlink" title="Spring MVC篇"></a>Spring MVC篇</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        在上一篇中有说到spring ioc 的实现，这一篇就让我们来看看spring mvc的实现吧！</p><p>​    spring mvc 是基于servlet实现的一个框架，它很好对servlet进行了优化，把servlet那些繁琐的操作进行了一步操作，配合spring 使得代码变得更加简洁，操作变得更加的简单。他的主要实现逻辑就是通过 @Controller , @RequestMapping 注解去标注需要被执行的方法 ，而且每个方法都有每个方法独立的访问路径。这时当请求到达服务器时会被最外层的servlet 也就是DispatcherServlet 拦截下来，然后再通过请求携带的路径参数去判断，需要调用的方法是哪一个 ，然后再去调用对应的方法。</p><a id="more"></a>

<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><ol>
<li>调用ioc去获取那些被@Controller所修饰的类</li>
<li>​     获取到被@Controller修饰的类后 对类中方法进行扫描获取带有@RequestMapping的方法</li>
<li>​     获取方法@RequestMapping 中所带的请求地址以及请求类型参数</li>
<li>​     将参数封装成request对象，将对应类与方法封装成handler对象</li>
<li>​     将封装好的request与handler对象放入map中</li>
<li>​     请求到达DispatcherServlet 时获取请求的请求路径与请求类型 封装成request对象</li>
<li>​     拿到请求参数封装的request对象去map中去匹配对应的handler对象</li>
<li>​     拿到handler对象中的请求方法后反射执行</li>
<li>​     获取方法执行后的返回值 判断返回值类型如果是view则跳转jsp页面，如果是data则返回数据</li>
</ol>
<p><strong>执行流程图</strong></p>
<p><img alt="img" data-src="https://img-blog.csdnimg.cn/20190630145911981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdGlhbnhpYW5nX2thb2xh,size_16,color_FFFFFF,t_70"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>定义需要用到的基础类</strong></p>
<p>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RequestMethod <span class="title">method</span><span class="params">()</span> <span class="keyword">default</span> RequestMethod.GET</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用到的枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RequestMethod&#123;</span><br><span class="line">    GET,POST,DELETE,PUT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求封装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String requestMethod;</span><br><span class="line">    <span class="keyword">private</span> String requestPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String requestMethod, String requestPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestMethod = requestMethod;</span><br><span class="line">        <span class="keyword">this</span>.requestPath = requestPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Request)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Request request = (Request) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(getRequestMethod(), request.getRequestMethod()) &amp;&amp;</span><br><span class="line">                Objects.equals(getRequestPath(), request.getRequestPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(getRequestMethod(), getRequestPath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标方法封装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理程序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; controllerClass;</span><br><span class="line">    <span class="keyword">private</span> Method controllerMethods;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Class&lt;?&gt; controllerClass, Method controllerMethods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.controllerClass = controllerClass;</span><br><span class="line">        <span class="keyword">this</span>.controllerMethods = controllerMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getControllerClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> controllerClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Method <span class="title">getControllerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> controllerMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Param</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Param</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Param</span><span class="params">(Map&lt;String, Object&gt; paramMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paramMap = paramMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getParamMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paramMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MapUtils.isEmpty(paramMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型封装类  数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.Bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模型数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object model;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(Object model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视图类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视图</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; model;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">View</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.model = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">addModel</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        model.put(key,value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现流程</strong></p>
<p>加载被@Controller修饰的类 封装成一个map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import cn.dszmr.Bean.Handler;</span><br><span class="line">import cn.dszmr.Bean.Request;</span><br><span class="line">import cn.dszmr.annotation.RequestMapping;</span><br><span class="line">import cn.dszmr.annotation.RequestMethod;</span><br><span class="line">import org.apache.commons.collections4.CollectionUtils;</span><br><span class="line">import org.apache.commons.lang3.ArrayUtils;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 控制器的辅助</span><br><span class="line"> *</span><br><span class="line"> * @author dsz</span><br><span class="line"> * @date 2020/06/09</span><br><span class="line"> */</span><br><span class="line">public final class ControllerHelper &#123;</span><br><span class="line">    private static final HashMap&lt;Request, Handler&gt; REQUEST_MAP = new HashMap&lt;Request, Handler&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //获取所有被controller修饰的类集合</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; controllerClassSet = ClassHelper.getControllerClassSet();</span><br><span class="line"></span><br><span class="line">        if (CollectionUtils.isNotEmpty(controllerClassSet))&#123;</span><br><span class="line">            //遍历被controller修饰的类集合</span><br><span class="line">            for (Class&lt;?&gt; aClass : controllerClassSet) &#123;</span><br><span class="line">                //获取类下的所有方法</span><br><span class="line">                Method[] declaredMethods = aClass.getDeclaredMethods();</span><br><span class="line">                if (ArrayUtils.isNotEmpty(declaredMethods))&#123;</span><br><span class="line">                    //遍历所有方法</span><br><span class="line">                    for (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">                        //判断方法是否带有RequestMapping注解</span><br><span class="line">                        if (declaredMethod.isAnnotationPresent(RequestMapping.class))&#123;</span><br><span class="line">                            //获取RequestMapping的参数</span><br><span class="line">                            RequestMapping annotation = declaredMethod.getAnnotation(RequestMapping.class);</span><br><span class="line">                            RequestMethod requestMethod = annotation.method();</span><br><span class="line">                            String requestPath = annotation.value();</span><br><span class="line">                            //将参数封装成request对象</span><br><span class="line">                            Request request = new Request(requestMethod.name(), requestPath);</span><br><span class="line">                            //将类和方法信息封装成handler对象</span><br><span class="line">                            Handler handler = new Handler(aClass,declaredMethod);</span><br><span class="line">                            REQUEST_MAP.put(request,handler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过请求类型和请求路径获取对应请求方法</span><br><span class="line">     * @return 对应handler对象</span><br><span class="line">     */</span><br><span class="line">    public static Handler getHandler(String requestMethod,String requestPath)&#123;</span><br><span class="line">        Request request = new Request(requestMethod, requestPath);</span><br><span class="line">        return REQUEST_MAP.get(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取请求参数列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求帮助</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Param <span class="title">createParam</span><span class="params">(HttpServletRequest request)</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; params = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">        Enumeration&lt;String&gt; parameterNames = request.getParameterNames();</span><br><span class="line">        <span class="keyword">if</span> (!parameterNames.hasMoreElements())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (parameterNames.hasMoreElements())&#123;</span><br><span class="line">            String paramName = parameterNames.nextElement();</span><br><span class="line">            String paramValue = request.getParameter(paramName);</span><br><span class="line">            params.put(paramName,paramValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Param(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心处理器DispatcherServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.Data;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.Handler;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.Param;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.View;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.BeanHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.ConfigHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.ControllerHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.RequestHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.load.HelperLoader;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ReflectionUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dispatcher servlet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/*"</span>, loadOnStartup = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化框架</span></span><br><span class="line">        HelperLoader.init();</span><br><span class="line">        <span class="comment">//获取全局上下文</span></span><br><span class="line">        ServletContext servletContext = config.getServletContext();</span><br><span class="line">        registerServlet(servletContext);</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServlet</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注册信息</span></span><br><span class="line">        ServletRegistration jsp = servletContext.getServletRegistration(<span class="string">"jsp"</span>);</span><br><span class="line">        jsp.addMapping(ConfigHelper.getJspPath() + <span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration aDefault = servletContext.getServletRegistration(<span class="string">"default"</span>);</span><br><span class="line">        aDefault.addMapping(<span class="string">"/favicon.ico"</span>);</span><br><span class="line">        aDefault.addMapping(ConfigHelper.getAssetPath() + <span class="string">"*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取请求方式</span></span><br><span class="line">            String method = req.getMethod().toUpperCase();</span><br><span class="line">            <span class="comment">//获取请求路径</span></span><br><span class="line">            String path = req.getPathInfo();</span><br><span class="line">            <span class="comment">//通过请求方式与路径获取对应controller的class对象</span></span><br><span class="line">            String[] splits = path.split(<span class="string">"/"</span>);</span><br><span class="line">            <span class="keyword">if</span> (splits.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                path = <span class="string">"/"</span> + splits[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            Handler handler = ControllerHelper.getHandler(method, path);</span><br><span class="line">            <span class="comment">//通过request获取参数列表</span></span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Param param = RequestHelper.createParam(req);</span><br><span class="line">                Class&lt;?&gt; controllerClass = handler.getControllerClass();</span><br><span class="line">                Method controllerMethods = handler.getControllerMethods();</span><br><span class="line">                <span class="comment">//获取对应方法</span></span><br><span class="line">                <span class="comment">//设置参数运行取返回值</span></span><br><span class="line">                Object result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (param == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    result = ReflectionUtil.invokeMethod(BeanHelper.getBaen(controllerClass), controllerMethods);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = ReflectionUtil.invokeMethod(BeanHelper.getBaen(controllerClass), controllerMethods, param);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//返回值转换data 或者 view对象 进行相关处理</span></span><br><span class="line">                <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Data) &#123;</span><br><span class="line">                    handleDataResult((Data) result, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    handleViewResult((View) result, req, resp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleViewResult</span><span class="params">(View view, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//获取页面文件的路径</span></span><br><span class="line">        String path = view.getPath();</span><br><span class="line">        <span class="keyword">if</span> (path!=<span class="keyword">null</span>&amp;&amp;path.length()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果是/开头则重定向</span></span><br><span class="line">                response.sendRedirect(request.getContextPath() + path);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将参数封装进request域再进行请求转发</span></span><br><span class="line">                Map&lt;String, Object&gt; model = view.getModel();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) &#123;</span><br><span class="line">                    request.setAttribute(entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">                request.getRequestDispatcher(ConfigHelper.getJspPath() + path).forward(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDataResult</span><span class="params">(Data data, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取对应模型</span></span><br><span class="line">        Object model = data.getModel();</span><br><span class="line">        <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置返回头</span></span><br><span class="line">            response.setContentType(<span class="string">"application/json"</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">//获取输出流</span></span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            <span class="comment">//将数据转换成json</span></span><br><span class="line">            String json = JSON.toJSON(model).toString();</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            writer.write(json);</span><br><span class="line">            writer.flush();</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>框架定义好了 接下来是测试</p>
<p>dsz.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">dsz.framework.app.base_package</span>=<span class="string">cn.dszmr</span></span><br><span class="line"><span class="meta">dsz.framework.app.asset_path</span>=<span class="string">/asset/</span></span><br><span class="line"><span class="meta">dsz.framework.app.jsp_path</span>=<span class="string">/WEB-INF/view/</span></span><br></pre></td></tr></table></figure>

<p>index.jsp</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"BASE"</span> value=<span class="string">"$&#123;pageContext.request.contextPath&#125;"</span>/&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;$&#123;massage&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>Userservice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String  <span class="title">helloWord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello word"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.Bean.View;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Controller;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.BeanHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.IocHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        View  view = <span class="keyword">new</span> View(<span class="string">"index.jsp"</span>);</span><br><span class="line">        view.addModel(<span class="string">"massage"</span>,userService.helloWord());</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加测试项目依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>框架依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- JSP标准标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志框架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通用工具包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--集合工具包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JSON依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编译项目  启动项目</p>
<p>访问 <span class="exturl" data-url="aHR0cHM6Ly9sb2NhbGhvc3Q6ODA4MC9kc3ovdGVzdA==" title="https://localhost:8080/dsz/test">https://localhost:8080/dsz/test<i class="fa fa-external-link"></i></span></p>
<p>看到hello word 成功打印 </p>
<p>下一篇 AOP篇 敬请期待！</p>
]]></content>
      <categories>
        <category>框架底层</category>
      </categories>
      <tags>
        <tag>spring 全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之组合设计模式</title>
    <url>/posts/cb2ca9f4/</url>
    <content><![CDATA[<h2 id="组合模式的定义与特点"><a href="#组合模式的定义与特点" class="headerlink" title="组合模式的定义与特点"></a>组合模式的定义与特点</h2><p><strong>组合（Composite）模式的定义：</strong>有时又叫作，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p><p><strong>组合模式的主要优点有：</strong></p><ol>
<li><p>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</p>
</li>
<li><p>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p>
</li>
</ol><a id="more"></a>


<p><strong>其主要缺点是：</strong></p>
<ol>
<li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li>
<li>不容易限制容器中的构件；</li>
<li>不容易用继承的方法来增加构件的新功能；</li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zhms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zhms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树叶构件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"树叶"</span>+name+<span class="string">"：被访问！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zhms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树枝  一个数值构件中包含了多个树叶构件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; children=<span class="keyword">new</span> ArrayList&lt;Component&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Component <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zhms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component c0=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component c1=<span class="keyword">new</span> Composite();</span><br><span class="line">        Component leaf1=<span class="keyword">new</span> Leaf(<span class="string">"1"</span>);</span><br><span class="line">        Component leaf2=<span class="keyword">new</span> Leaf(<span class="string">"2"</span>);</span><br><span class="line">        Component leaf3=<span class="keyword">new</span> Leaf(<span class="string">"3"</span>);</span><br><span class="line">        c0.add(leaf1);</span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2);</span><br><span class="line">        c1.add(leaf3);</span><br><span class="line">        c0.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之享元设计模式</title>
    <url>/posts/3a014e30/</url>
    <content><![CDATA[<h2 id="享元模式的定义与特点"><a href="#享元模式的定义与特点" class="headerlink" title="享元模式的定义与特点"></a>享元模式的定义与特点</h2><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><a id="more"></a>

<p>其主要缺点是：</p>
<ol>
<li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li>
<li>读取享元模式的外部状态会使得运行时间稍微变长。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.xyms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsharedConcreteFlyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnsharedConcreteFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.xyms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 享元接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.xyms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体享元类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        System.out.println(<span class="string">"key被创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(UnsharedConcreteFlyweight state)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"具体享元"</span>+key+<span class="string">"被调用，"</span>);</span><br><span class="line">        System.out.println(<span class="string">"非享元信息是:"</span>+state.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.xyms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 享元工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,Flyweight&gt;  flyweights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Flyweight flyweight = flyweights.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flyweight != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(key+<span class="string">"已存在并且被成功获取！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key,flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.xyms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FlyweightFactory factory=<span class="keyword">new</span> FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(<span class="string">"a"</span>);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(<span class="string">"b"</span>);</span><br><span class="line">        f01.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用a。"</span>));</span><br><span class="line">        f02.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用a。"</span>));</span><br><span class="line">        f03.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第3次调用a。"</span>));</span><br><span class="line">        f11.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第1次调用b。"</span>));</span><br><span class="line">        f12.operation(<span class="keyword">new</span> UnsharedConcreteFlyweight(<span class="string">"第2次调用b。"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之外观设计模式</title>
    <url>/posts/76e6897c/</url>
    <content><![CDATA[<h2 id="外观模式的定义与特点"><a href="#外观模式的定义与特点" class="headerlink" title="外观模式的定义与特点"></a>外观模式的定义与特点</h2><p><strong>外观（Facade）模式的定义：</strong>是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p><strong>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</strong></p><a id="more"></a>

<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p><strong>外观（Facade）模式的主要缺点如下。</strong></p>
<ol>
<li><p>不能很好地限制客户使用子系统类。</p>
</li>
<li><p>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
</li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSZA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统A的一个方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">package</span> cn.dszmr.sjms.wgms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSZB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统B的一个方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.wgms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子系统C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DSZC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子系统C的一个方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.wgms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外观聚合类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DSZA dsza = <span class="keyword">new</span> DSZA();</span><br><span class="line">    <span class="keyword">private</span> DSZB dszb = <span class="keyword">new</span> DSZB();</span><br><span class="line">    <span class="keyword">private</span> DSZC dszc = <span class="keyword">new</span> DSZC();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dsza.method();</span><br><span class="line">        dszb.method();</span><br><span class="line">        dszc.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.wgms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Facade f=<span class="keyword">new</span> Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之装饰设计模式</title>
    <url>/posts/5580f791/</url>
    <content><![CDATA[<h2 id="装饰模式的定义与特点"><a href="#装饰模式的定义与特点" class="headerlink" title="装饰模式的定义与特点"></a>装饰模式的定义与特点</h2><p><strong>装饰（Decorator）模式的定义：</strong>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><p><strong>装饰（Decorator）模式的主要优点有：</strong></p><ul>
<li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul><a id="more"></a>


<p><strong>其主要缺点是：</strong>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zsms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zsms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务类实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建具体构件角色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用具体构件角色的方法operation()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.dszmr.sjms.zsms;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 拓展抽象类</span><br><span class="line"> */</span><br><span class="line">public abstract class Decorator implements Component&#123;</span><br><span class="line">    private Component component;</span><br><span class="line"></span><br><span class="line">    public Decorator(Component component) &#123;</span><br><span class="line">        this.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void operation() &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zsms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓展类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"为具体构件角色增加额外的功能addedFunction()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.zsms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Component p=<span class="keyword">new</span> ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">        Component d=<span class="keyword">new</span> ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之桥接设计模式</title>
    <url>/posts/f0529bc3/</url>
    <content><![CDATA[<h2 id="桥接模式的定义与特点"><a href="#桥接模式的定义与特点" class="headerlink" title="桥接模式的定义与特点"></a>桥接模式的定义与特点</h2><p><strong>桥接（Bridge）模式的定义如下：</strong>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br><strong>桥接（Bridge）模式的优点是：</strong></p><ul>
<li>由于抽象与实现分离，所以扩展能力强；</li>
<li>其实现细节对客户透明。</li>
</ul><p><strong>缺点是：</strong>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><a id="more"></a>


<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.qjms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓展接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.qjms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OperationImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里是业务代码a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.qjms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象化拓展类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    Implementor impl ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.qjms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓展类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个是对业务代码进行的拓展"</span>);</span><br><span class="line">        impl.OperationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.qjms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Implementor imple=<span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=<span class="keyword">new</span> RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之适配器设计模式</title>
    <url>/posts/342dc42e/</url>
    <content><![CDATA[<h2 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h2><p><strong>适配器模式（Adapter）的定义如下：</strong>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>该模式的主要优点如下。</p><ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
</ul><a id="more"></a>

<p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码实现非常简单，就是定义一个适配者类，让业务类继承或者创建一个适配者类，然后在业务方法中调用适配者类中的一个方法，这样以后修改就只需要去修改适配器的代码即可，可以尽量的避免去修改业务类代码。</p>
<p>业务类接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.spqms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适配器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.spqms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"适配器的代码被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.spqms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span>  <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.spqms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapterTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类适配器模式测试："</span>);</span><br><span class="line">        Target target = <span class="keyword">new</span> ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之代理设计模式</title>
    <url>/posts/990c4abf/</url>
    <content><![CDATA[<h2 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h2><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式的主要优点有：</p><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul><a id="more"></a>


<p>代理模式的主要优点有：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dailims;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问主题方法体......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dailims;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之前的预处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"访问真实主题之后的后续处理。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=<span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dailims;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Proxy proxy=<span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之建造者设计模式</title>
    <url>/posts/dd6ab62d/</url>
    <content><![CDATA[<h2 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h2><p><strong>建造者（Builder）模式的定义：</strong>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p><strong>该模式的主要优点如下：</strong></p><a id="more"></a>

<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p><strong>其缺点如下：</strong></p>
<ol>
<li>产品的组成部分必须相同，这限制了其使用范围。</li>
<li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li>
</ol>
<p><strong>建造者（Builder）模式和工厂模式的关注点不同：</strong>建造者模式注重零部件的组装过程，而更注重零部件的创建过程，但两者可以结合使用。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.jzzms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品角色：包含多个组成部件的复杂对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String head;</span><br><span class="line">    <span class="keyword">private</span> String body;</span><br><span class="line">    <span class="keyword">private</span> String foot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(String head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoot</span><span class="params">(String foot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.foot = foot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这个人他有一个"</span>+head+<span class="string">",他还有一个"</span>+body+<span class="string">",他也有一双"</span>+foot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.jzzms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象建造者：包含创建产品各个子部件的抽象方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Preson preson = <span class="keyword">new</span> Preson();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">foot</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Preson <span class="title">getPreson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.jzzms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体建造者：实现了抽象建造者接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">head</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preson.setHead(<span class="string">"大头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preson.setBody(<span class="string">"啤酒杯"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        preson.setFoot(<span class="string">"肥猪蹄"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.jzzms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.sjms.kdgcms.Product;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者：调用建造者中的方法完成复杂对象的创建。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Preson <span class="title">construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.head();</span><br><span class="line">        builder.body();</span><br><span class="line">        builder.foot();</span><br><span class="line">        <span class="keyword">return</span> builder.getPreson();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.jzzms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder concreteBuilder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(concreteBuilder);</span><br><span class="line">        Preson construct = director.construct();</span><br><span class="line">        construct.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之抽象工厂设计模式</title>
    <url>/posts/e2787a47/</url>
    <content><![CDATA[<h2 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h2><p><strong>抽象工厂（AbstractFactory）模式的定义：</strong>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>使用抽象工厂模式一般要满足以下条件。</p><ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ul><a id="more"></a>


<p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li>
<li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li>
</ul>
<p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>其大概逻辑就是将原本简单工厂的只有创建一种对象 改变成了能创建一个种族的所有对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.cxgcms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.sjms.kdgcms.Car;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.sjms.kdgcms.Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">newCar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Cat <span class="title">newCat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.cxgcms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.sjms.kdgcms.Car;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.sjms.kdgcms.Cat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">newCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">newCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之工厂方法设计模式</title>
    <url>/posts/5fd6ffe3/</url>
    <content><![CDATA[<h2 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h2><p><strong>工厂方法（FactoryMethod）模式的定义：</strong>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。<br>如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典<span class="exturl" data-url="aHR0cDovL2MuYmlhbmNoZW5nLm5ldC9kZXNpZ25fcGF0dGVybi8=" title="http://c.biancheng.net/design_pattern/">设计模式<i class="fa fa-external-link"></i></span>，它的缺点是增加新产品时会违背“开闭原则”。</p><a id="more"></a>
<p><strong>工厂方法模式的主要优点有：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>其缺点是：</strong>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>抽象父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象产品</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果业务需要添加一个car的商品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品实现类</span></span><br><span class="line"><span class="comment"> * 具体类2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is car"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还需要添加一个cat的商品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品实现类</span></span><br><span class="line"><span class="comment"> * 具体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span>  <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话并未对原有代码进行修改 但是也完成了业务需求 符合开闭原则</p>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.kdgcms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       CatFactory catFactory = <span class="keyword">new</span> CatFactory();</span><br><span class="line">       CarFactory carFactory = <span class="keyword">new</span> CarFactory();</span><br><span class="line"></span><br><span class="line">       System.out.println(carFactory.newProduct());</span><br><span class="line">       System.out.println(catFactory.newProduct());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之原型设计模式</title>
    <url>/posts/c909a911/</url>
    <content><![CDATA[<h2 id="原型模式的定义与特点"><a href="#原型模式的定义与特点" class="headerlink" title="原型模式的定义与特点"></a>原型模式的定义与特点</h2><p><strong>原型（Prototype）模式的定义如下</strong>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。在有的时候需要重新创建个对象时，无疑使用原型模式会显得更加的便捷。</p><a id="more"></a>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.yxms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原型模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yuanxing</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLabel</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Yuanxing <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Yuanxing) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Yuanxing yuanxing = <span class="keyword">new</span> Yuanxing();</span><br><span class="line">        yuanxing.setLabel(<span class="string">"dsz"</span>);</span><br><span class="line"></span><br><span class="line">        Yuanxing clone = yuanxing.clone();</span><br><span class="line"></span><br><span class="line">        String label = yuanxing.getLabel();</span><br><span class="line">        String label1 = clone.getLabel();</span><br><span class="line"></span><br><span class="line">        System.out.println(label.equals(label1)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(clone==yuanxing); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析设计模式之单例设计模式</title>
    <url>/posts/1abfeb89/</url>
    <content><![CDATA[<h2 id="单例模式的定义与特点"><a href="#单例模式的定义与特点" class="headerlink" title="单例模式的定义与特点"></a>单例模式的定义与特点</h2><p><strong>单例（Singleton）模式的定义：</strong>指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。<br>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p><a id="more"></a>
<ol>
<li>单例类只有一个实例对象；</li>
<li>该单例对象必须由单例类自行创建；</li>
<li>单例类对外提供一个访问该单例的全局访问点；</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dlms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Langhan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Langhan langhan = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Langhan</span> <span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Langhan <span class="title">getLanghan</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (langhan == <span class="keyword">null</span>)</span><br><span class="line">            langhan = <span class="keyword">new</span> Langhan();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> langhan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dlms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erhan</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Erhan erhan = <span class="keyword">new</span> Erhan();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Erhan</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Erhan <span class="title">getErhan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> erhan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.sjms.dlms;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Erhan erhan = Erhan.getErhan();</span><br><span class="line">        Langhan langhan = Langhan.getLanghan();</span><br><span class="line">        System.out.println(erhan);</span><br><span class="line">        System.out.println(langhan);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>简单实践spring框架(手写spring)</title>
    <url>/posts/8da23d78/</url>
    <content><![CDATA[<h1 id="Spring-IOC篇"><a href="#Spring-IOC篇" class="headerlink" title="Spring-IOC篇"></a>Spring-IOC篇</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    我们认识的Spring-IOC 无非就是在类上加一个    @Component,@Service,@Controller,@Repository这些注解，这样就代表了将这个类或者说对象交给了spring管理，由spring为我们创建对象，而我们只需要在其他的类的成员位置定义该对象的对象名并在其上面加上@Resource或者@Autowired注解，spring便会自动的把我们所需要的值注入进去了，我们直接调用即可。这看似简单的却又神奇的操作，你又有没有想过spring是怎么实现的呢？</p><a id="more"></a>
<h3 id="IOC注入流程"><a href="#IOC注入流程" class="headerlink" title="IOC注入流程"></a>IOC注入流程</h3><p>流程大致分为五步</p>
<ol>
<li>读取配置文件获取文件根路径</li>
<li>通过根路径获取所有类</li>
<li>为这些类创建对象</li>
<li>扫描获取需要注入的对象</li>
<li>通过反射为类注入对象</li>
</ol>
<h3 id="手动实现IOC"><a href="#手动实现IOC" class="headerlink" title="手动实现IOC"></a>手动实现IOC</h3><p><strong>既然知道了流程那么就话不多说来实现一下spring的ioc</strong></p>
<p>首先需要做一些基础的准备工作也就是定义注解。</p>
<p>需要用到的注解</p>
<p>​        <strong>@Component,@Service,@Controller,@Repository,@Autowired</strong></p>
<p>我这里为了简便就不进行@Component和@Repository的定义了</p>
<p>@Service 在这里用注释简单介绍了一下参数的意思 后面将不在介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单参数介绍</span></span><br><span class="line"><span class="comment"> * ElementType.TYPE   在类上定义</span></span><br><span class="line"><span class="comment"> * ElementType.FIELD 在成员字段上定义</span></span><br><span class="line"><span class="comment"> * ElementType.METHOD 在方法上定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单参数介绍</span></span><br><span class="line"><span class="comment"> * RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；</span></span><br><span class="line"><span class="comment"> * RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；</span></span><br><span class="line"><span class="comment"> * RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * autowired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好注解以后就可以进行第一步操作了 </p>
<p>​         读取配置文件获取文件根路径</p>
<p>这一步的具体步骤就是去你的项目加载指定目录下去获取一个指定文件名的文件，也就是properties配置文件，然后解析这个配置文件获取里面的配置项为我们项目加载所用。</p>
<p>首先我们需要一个类来进行固定配置名的约束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.utils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定配置项</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigConstant</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java源码地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String APP_BASE_PACKAGE = <span class="string">"dsz.framework.app.base_package"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String APP_ASSET_PATH = <span class="string">"dsz.framework.app.asset_path"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String CONFIG_FILE = <span class="string">"dsz.properties"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要一个工具类来读取properties文件内容</p>
<p>具体逻辑就是给定一个文件路径 然后读取该文件 把它读取至properties集合容器中</p>
<blockquote>
<p>需要添加一个日志包</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日志框架 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 道具跑龙套</span></span><br><span class="line"><span class="comment"> * 配置文件工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropsUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志记录器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(PropsUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载的道具</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Properties&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">loadProps</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        Properties  properties = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is =  <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is =  Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(fileName+<span class="string">"文件不存在，请检查路径?"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.load(is);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"读取文件错误！"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"文件流关流失败！"</span>,e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                LOGGER.info(fileName+<span class="string">"文件读取成功，正在进行下一步！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Properties properties,String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getString(properties, key,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到字符串</span></span><br><span class="line"><span class="comment">     * 获取string类型的值 默认为空字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value      价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Properties properties,String key,String value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (properties.containsKey(key))&#123;</span><br><span class="line">            value = properties.getProperty(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取布尔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Properties properties,String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getBoolean(properties, key,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取布尔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value      价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Properties properties,String key,<span class="keyword">boolean</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (properties.containsKey(key))&#123;</span><br><span class="line">            value = Boolean.parseBoolean(properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Properties properties,String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInt(properties, key,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value      价值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Properties properties,String key,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (properties.containsKey(key))&#123;</span><br><span class="line">            value = Integer.parseInt(properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们再结合工具类和基本名称的定义获取到对应的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ConfigConstant;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.PropsUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置助手</span></span><br><span class="line"><span class="comment"> * 设计及其助手</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties PROPERTIES = PropsUtil.loadProps(ConfigConstant.CONFIG_FILE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得基础包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getBasePackage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PropsUtil.getString(PROPERTIES,ConfigConstant.APP_BASE_PACKAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PropsUtil.getString(PROPERTIES,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取布尔</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PropsUtil.getBoolean(PROPERTIES,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 关键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PropsUtil.getInt(PROPERTIES,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以通过调用ConfigHelper的静态方法去获取对应配置属性了</p>
<p>好了继续下一步</p>
<p>​            通过根路径获取所有类</p>
<blockquote>
<p>添加工具包这样操作更加的简便</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用工具包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--集合工具包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>具体逻辑是 获取类加载器 通过类加载器与设置好的根路径获取文件父包 进行扫描 如果为普通文件或者文件夹则进行递归扫描 如果为jar则开包获取所有.class文件 并获取出所有类对象并添加类对象至集合内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dszmr.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.JarURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarEntry;</span><br><span class="line"><span class="keyword">import</span> java.util.jar.JarFile;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载class工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ClassUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取指定类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isInitialized</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className,<span class="keyword">boolean</span> isInitialized)&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            aClass = Class.forName(className, isInitialized, getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"这个类读取不到"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取指定类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(className,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有bean类的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet(String packageName)&#123;</span><br><span class="line">        <span class="comment">//创建集合</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSet = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">//通过类加载器 获取包的根路径</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取类加载器</span></span><br><span class="line">            ClassLoader classLoader = getClassLoader();</span><br><span class="line">            <span class="comment">//把指定根路径包名替换成路径 也就是把.替换成\</span></span><br><span class="line">            String s = packageName.replaceAll(<span class="string">"\\."</span>, <span class="string">"\\\\"</span>);</span><br><span class="line">            <span class="comment">//通过类加载器去扫描该路径 获取出该路径下所有文件集合</span></span><br><span class="line">            Enumeration&lt;URL&gt; resources = classLoader.getResources(s);</span><br><span class="line">            <span class="comment">//循环迭代获取所有路径</span></span><br><span class="line">            <span class="keyword">while</span> (resources.hasMoreElements())&#123;</span><br><span class="line">                URL url = resources.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (url!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//判断文件类型如果是普通文件</span></span><br><span class="line">                    String protocol = url.getProtocol();</span><br><span class="line">                    <span class="keyword">if</span> (protocol.equals(<span class="string">"file"</span>))&#123;</span><br><span class="line">                        String packagePath = url.getPath().replaceAll(<span class="string">"%20"</span>, <span class="string">" "</span>);</span><br><span class="line">                        <span class="comment">//递归扫描但前路径下所有文件</span></span><br><span class="line">                        addClass(classSet,packagePath,packageName);</span><br><span class="line">                        <span class="comment">//如果是jar包则开包进行扫描</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (protocol.equals(<span class="string">"jar"</span>))&#123;</span><br><span class="line">                        <span class="comment">//获取jar路径连接对象</span></span><br><span class="line">                        JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();</span><br><span class="line">                        <span class="keyword">if</span> (jarURLConnection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                            <span class="comment">//获取jar内所有文件</span></span><br><span class="line">                            JarFile jarFile = jarURLConnection.getJarFile();</span><br><span class="line">                            <span class="keyword">if</span> (jarFile!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                                <span class="comment">//迭代文件</span></span><br><span class="line">                                Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line">                                <span class="keyword">while</span> (entries.hasMoreElements())&#123;</span><br><span class="line">                                    JarEntry jarEntry = entries.nextElement();</span><br><span class="line">                                    <span class="comment">//加载所有.class文件</span></span><br><span class="line">                                    String jarEntryName = jarEntry.getName();</span><br><span class="line">                                    <span class="keyword">if</span> (jarEntryName.endsWith(<span class="string">".class"</span>))&#123;</span><br><span class="line">                                        jarEntryName = jarEntryName.substring(<span class="number">0</span>,jarEntryName.indexOf(<span class="string">"."</span>)).replaceAll(<span class="string">"/"</span>,<span class="string">"."</span>);</span><br><span class="line">                                        doAddClass(classSet,jarEntryName);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"读取文件出现问题"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归遍历所有文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addClass</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classSet,String packagePath,String packageName)</span></span>&#123;</span><br><span class="line">       <span class="comment">//过滤文件 只读取class文件 或者文件夹</span></span><br><span class="line">        File[] files = <span class="keyword">new</span> File(packagePath).listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.isFile() ? pathname.getName().endsWith(<span class="string">".class"</span>) : pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//是文件则添加进集合容器中</span></span><br><span class="line">            String fileName = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                <span class="comment">//编辑类路径全名添加至集合容器</span></span><br><span class="line">                String className = fileName.substring(<span class="number">0</span>, fileName.indexOf(<span class="string">"."</span>));</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(packageName))&#123;</span><br><span class="line">                   className = packageName+<span class="string">"."</span>+className;</span><br><span class="line">                &#125;</span><br><span class="line">                doAddClass(classSet,className);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//是文件夹则进行再次递归读取</span></span><br><span class="line">                String subFilePath = fileName;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(packagePath))&#123;</span><br><span class="line">                    subFilePath = packagePath + <span class="string">"/"</span> + subFilePath;</span><br><span class="line">                &#125;</span><br><span class="line">                String subFileName = fileName;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isNotEmpty(packageName))&#123;</span><br><span class="line">                    subFileName = packageName + <span class="string">"."</span>+subFileName;</span><br><span class="line">                &#125;</span><br><span class="line">                 addClass(classSet,subFilePath,subFileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把文件添加至集合容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doAddClass</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; classSet,String className)</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过类路径获取类对象 将类对象添加至集合容器</span></span><br><span class="line">        Class&lt;?&gt; aClass = loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        classSet.add(aClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道spring只会加载被他的注解所修饰的类 而我们定义的工具类的功能是获取所有类 这样我们需要再次定义一个辅助类去筛选出需要注入和被注入的类</p>
<p>具体逻辑为通过ConfigHelper去获取当前根类 再传入ClassUtil去获取所有类的集合 再定义方法进行各种筛选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Controller;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ClassUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 筛选类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; CLASS_SET ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//获取根路径包</span></span><br><span class="line">        String basePackage = ConfigHelper.getBasePackage();</span><br><span class="line">        <span class="comment">//调用工具类获取项目下的所有类</span></span><br><span class="line">        CLASS_SET = ClassUtil.getClassSet(basePackage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSet()&#123;</span><br><span class="line">        <span class="keyword">return</span> CLASS_SET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取被service修饰的类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getServiceClassSet()&#123;</span><br><span class="line">        HashSet&lt;Class&lt;?&gt;&gt; classHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : CLASS_SET) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(Service<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                classHashSet.add(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classHashSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取被controller修饰的类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getControllerClassSet()&#123;</span><br><span class="line">        HashSet&lt;Class&lt;?&gt;&gt; classHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : CLASS_SET) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(Controller<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                classHashSet.add(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classHashSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有bean类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getBeanClassSet()&#123;</span><br><span class="line">        HashSet&lt;Class&lt;?&gt;&gt; classHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        classHashSet.addAll(getServiceClassSet());</span><br><span class="line">        classHashSet.addAll(getControllerClassSet());</span><br><span class="line">        <span class="keyword">return</span> classHashSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取但前类子类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> superClass 超类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSetBySuper(Class&lt;?&gt; superClass)&#123;</span><br><span class="line">        HashSet&lt;Class&lt;?&gt;&gt; classHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : CLASS_SET) &#123;</span><br><span class="line">            <span class="keyword">if</span> (superClass.isAssignableFrom(aClass)&amp;&amp;!superClass.equals(aClass))&#123;</span><br><span class="line">                classHashSet.add(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classHashSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取带有注释的类集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationClass 注释类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Set&lt;Class&lt;?&gt;&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getClassSetByAnnotation(Class&lt;? extends Annotation&gt; annotationClass)&#123;</span><br><span class="line">        HashSet&lt;Class&lt;?&gt;&gt; classHashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : CLASS_SET) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aClass.isAnnotationPresent(annotationClass))&#123;</span><br><span class="line">                classHashSet.add(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classHashSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在获取到了所有对应的所有bean类  现在我们只需要将其进行反射为有对应注解的类进行注入属性</p>
<p>既然要使用反射操作 为了避免代码重复 我们将反射的基本操作封装成一个工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志记录器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ReflectionUtil<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o = cls.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"创建类实例失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cls = ClassUtil.loadClass(className);</span><br><span class="line">        <span class="keyword">return</span> newInstance(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj    obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   arg游戏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Object&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeMethod</span><span class="params">(Object obj, Method method, Object... args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o = method.invoke(obj, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"调用"</span> + obj + <span class="string">"方法失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置字段</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj   obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field 场</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Object obj, Field field, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"修改"</span> + obj + <span class="string">"属性失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring-IOC 最核心的地方可能就是那个存着所有bean的大map了 键为类对象 值为对应的对象想要可以直接通过类对象获取对象 大大简便了操作 既然classHelper为我们提供了所有的bean的类对象 那么定义出这个bean map 是不是就显得很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ReflectionUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean助手</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bean工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;,Object&gt; BEAN_MAP = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; beanClassSet = ClassHelper.getBeanClassSet();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : beanClassSet) &#123;</span><br><span class="line">            Object o = ReflectionUtil.newInstance(aClass);</span><br><span class="line">            BEAN_MAP.put(aClass,o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到bean映射</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Map&lt;Class&lt;?&gt;, Object&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;,Object&gt; getBeanMap()&#123;</span><br><span class="line">        <span class="keyword">return</span> BEAN_MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到baen</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBaen</span><span class="params">(Class&lt;T&gt; cls)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!BEAN_MAP.containsKey(cls))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"你获取的"</span> + cls + <span class="string">"在Bean容器内不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) BEAN_MAP.get(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置bean</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o   o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBean</span><span class="params">(Class&lt;?&gt; cls,Object o)</span></span>&#123;</span><br><span class="line">        BEAN_MAP.put(cls,o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在把所有的bean都转载到了beanmap内 但是类上带有Autowired注解的还未进行注入操作</p>
<p>定义IocHelper进行注入操作 逻辑为 获取所有bean 进行迭代遍历 获取对应的字段 获取字段上有Autowired注解的bean 然后为其进行注入对象属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ReflectionUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ArrayUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 国际奥委会助手</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IocHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//取到beanMap</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Object&gt; beanMap = BeanHelper.getBeanMap();</span><br><span class="line">        <span class="keyword">if</span> (MapUtils.isNotEmpty(beanMap))&#123;</span><br><span class="line">            <span class="comment">//进行迭代</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; classObjectEntry : beanMap.entrySet()) &#123;</span><br><span class="line">                Class&lt;?&gt; cls = classObjectEntry.getKey();</span><br><span class="line">                Object o = classObjectEntry.getValue();</span><br><span class="line">                <span class="comment">//获取所有字段 遍历</span></span><br><span class="line">                Field[] fields = cls.getDeclaredFields();</span><br><span class="line">                <span class="keyword">if</span> (ArrayUtils.isNotEmpty(fields))&#123;</span><br><span class="line">                <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                    <span class="comment">//判断字段上是否有Autowired注解</span></span><br><span class="line">                    <span class="keyword">if</span> (field.isAnnotationPresent(Autowired<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                        <span class="comment">//获取其子类 类对象</span></span><br><span class="line">                        Class&lt;?&gt; superClass = findImplementClass(field.getType());</span><br><span class="line">                        <span class="comment">//从bean工厂获取对象</span></span><br><span class="line">                        Object obj = beanMap.get(superClass);</span><br><span class="line">                        <span class="keyword">if</span> (obj !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                            <span class="comment">//反射写入字段中</span></span><br><span class="line">                            ReflectionUtil.setField(o,field,obj);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到实现类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls cls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;?&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; findImplementClass(Class&lt;?&gt; cls)&#123;</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classSetBySuper = ClassHelper.getClassSetBySuper(cls);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(classSetBySuper))&#123;</span><br><span class="line">            cls = classSetBySuper.iterator().next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这一步一个简单的拥有ioc功能的框架就搭建成功了</p>
<p>我们可以定义测试类进行一个简单的测试</p>
<p>在此之前我们需要让tomcat在加载的时候会去加载我们ioc容器</p>
<p>所以我们需要定义一个初始化加载类 然后继承HTTPServlet 利用servlet的init方法进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.load;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.BeanHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.ClassHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.IocHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.utils.ClassUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 辅助装载机</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dsz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/06/09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelperLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] classes = &#123;</span><br><span class="line">                ClassHelper<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">BeanHelper</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">IocHelper</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">        &#125;</span>;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : classes) &#123;</span><br><span class="line">            ClassUtil.loadClass(aClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为要使用到servlet所以需要添加servlet相关依赖</p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.servlet;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.load.HelperLoader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Initservlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        HelperLoader.init();</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在定义完毕了 我们还需要在但前包下创建一个项目 然后依赖我们定义的spring-ioc项目进行测试</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>这是完成的框架项目结构</p>
<p><img alt="1591942979103" data-src="1591942979103.png"></p>
<p>这是定义的测试项目 的项目结构</p>
<p><img alt="1591943034322" data-src="1591943034322.png"></p>
<p>他俩存在于一个文件夹下</p>
<p><img alt="1591943073077" data-src="1591943073077.png"></p>
<h3 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h3><p>在框架的同一级目录下创建一个maven项目</p>
<p>pom依赖中依赖框架</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dszmr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dsz-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写dsz.properties 这个文件是在开始的时候指定的</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">dsz.framework.app.base_package</span>=<span class="string">cn.dszmr</span></span><br><span class="line"><span class="meta">dsz.framework.app.asset_path</span>=<span class="string">/asset/</span></span><br></pre></td></tr></table></figure>

<p>Usercontroller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Controller;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.BeanHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.helper.IocHelper;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        UserController baen = BeanHelper.getBaen(<span class="keyword">this</span>.getClass());</span><br><span class="line">        baen.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.helloWord();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于框架未全部完成只能实习一小部分功能  获取装载好的bean也只能到容器中获取</p>
<p>下一篇MVC篇将完善功能</p>
<p><strong>启动测试</strong></p>
<p>打开idea中的maven工具 compile 编译一下框架</p>
<p>配置测试项目的tomcat启动即可</p>
<p>访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2Rzei90ZXN0" title="http://localhost:8080/dsz/test">http://localhost:8080/dsz/test<i class="fa fa-external-link"></i></span></p>
<p>控制台打印 调用成功 </p>
<p>下一篇MVC篇  敬请期待！</p>
]]></content>
      <categories>
        <category>框架底层</category>
      </categories>
      <tags>
        <tag>spring 全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA类加载器</title>
    <url>/posts/f1b411ee/</url>
    <content><![CDATA[<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>​     当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化</p><p><img alt="1590634636055" data-src="1590634636055.png"></p><h2 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a><strong>1.加载</strong></h3><p>​    加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。</p><a id="more"></a>


<pre><code>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。

通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。</code></pre><p>从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。<br>从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。<br>通过网络加载class文件。<br>把一个Java源文件动态编译，并执行加载。<br>    类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。</p>
<h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2.链接"></a>2.链接</h3><p>​    当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。</p>
<p><strong>1)验证：</strong>验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</p>
<p><strong>四种验证做进一步说明：</strong></p>
<p><strong>文件格式验证：</strong>主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。</p>
<p><strong>元数据验证：</strong>对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。</p>
<p><strong>字节码验证：</strong>最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。</p>
<p><strong>符号引用验证：</strong>主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。</p>
<p>   2)<strong>准备：</strong>类准备阶段负责为类的静态变量分配内存，并设置默认初始值。</p>
<p>   3)<strong>解析：</strong>将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。</p>
<h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><p>​    初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。</p>
<h2 id="二、类加载时机"><a href="#二、类加载时机" class="headerlink" title="二、类加载时机"></a>二、类加载时机</h2><p>创建类的实例，也就是new一个对象<br>访问某个类或接口的静态变量，或者对该静态变量赋值<br>调用类的静态方法<br>反射（Class.forName(“com.lyj.load”)）<br>初始化一个类的子类（会首先初始化子类的父类）<br>JVM启动时标明的启动类，即文件名和类名相同的那个类<br>     除此之外，下面几种情形需要特别指出：</p>
<pre><code>对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</code></pre><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>​    类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。</p>
<p>   JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：</p>
<p> <strong>1)根类加载器（bootstrap class loader）:</strong>它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。</p>
<p>下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径：</p>
<p>public class ClassLoaderTest {</p>
<pre><code>public static void main(String[] args) {

    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
    for(URL url : urls){
        System.out.println(url.toExternalForm());
    }
}</code></pre><p>}<br>运行结果：</p>
<p><img alt="img" data-src="https://img-blog.csdn.net/2018081314481932?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p>  <strong>2)扩展类加载器（extensions class loader）：</strong>它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。</p>
<p>  <strong>3)系统类加载器（system class loader）：</strong>被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</p>
<p>类加载器加载Class大致要经过如下8个步骤：</p>
<ol>
<li><p>检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。</p>
</li>
<li><p>如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。</p>
</li>
<li><p>请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。</p>
</li>
<li><p>请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。</p>
</li>
<li><p>当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。</p>
</li>
<li><p>从文件中载入Class，成功后跳至第8步。</p>
</li>
<li><p>抛出ClassNotFountException异常。</p>
</li>
<li><p>返回对应的java.lang.Class对象。</p>
</li>
</ol>
<h2 id="四、类加载机制："><a href="#四、类加载机制：" class="headerlink" title="四、类加载机制："></a>四、类加载机制：</h2><h3 id="1-JVM的类加载机制主要有如下3种。"><a href="#1-JVM的类加载机制主要有如下3种。" class="headerlink" title="1.JVM的类加载机制主要有如下3种。"></a>1.JVM的类加载机制主要有如下3种。</h3><p>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。<br>双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。<br>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。</p>
<h3 id="2-这里说明一下双亲委派机制："><a href="#2-这里说明一下双亲委派机制：" class="headerlink" title="2.这里说明一下双亲委派机制："></a>2.这里说明一下双亲委派机制：</h3><p><img alt="img" data-src="https://img-blog.csdn.net/20180813145521896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MDc1NDI1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<pre><code> 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。

双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</code></pre>]]></content>
      <tags>
        <tag>搬砖技术</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm虚拟机</title>
    <url>/posts/c9804b55/</url>
    <content><![CDATA[<h2 id="jvm架构解析"><a href="#jvm架构解析" class="headerlink" title="jvm架构解析"></a>jvm架构解析</h2><p>程序加载步骤   class  &gt;&gt; 类装载子系统 &gt;&gt; 运行时数据区(内存模型)  &gt;&gt; 字节码执行引擎</p><p><img alt="1590134776914" data-src="1590134776914.png"></p><p>栈： 一个线程对应一块栈内存区域</p><p>栈针 ： 一个方法对应一个栈针</p><p>操作数栈：一个临时的运行空间  用于程序运算</p><p>局部变量 表：存储局部变量 内部是集合的一个存储结构</p><a id="more"></a>





<p>方法出口：但前方法执行完毕后 回到调用者方法 从那块开始继续执行 </p>
<p>程序计数器:代码运行到那一行的位置 值是由字节码执行引擎进行修改</p>
<p>方法区：1.8之前叫永久代 1.8以后叫元空间 它使用的是物理内存 不是虚拟机的内存  内部主要存储 常量，静态变量，类信息等</p>
<p>堆：由老年代与年轻代组成 老年代占用 3/2 年轻代占用3/1   年轻代分为Eden区 和 survivor区   对象一般会存储在Eden区  在Eden区 被占满后 会字节码执行引擎会调用minor gc 对垃圾对象进行回收  有引用的的对象会被复制进 survivor0区  没有引用的对象直接清除  当gc对堆进行第二次进行清理时 Eden 区有引用的对象会被移到survivor0区 ，survivor0区的有引用的对象会被移动到 survivor1区中 并且每进行一次移动 对象头中的年龄便会加一 年龄达到15会被移到老年代内 当老年代内存满了的时候 会字节码执行引擎会调用full gc对整个堆进行垃圾清理 如何还是在增加则会触发oom内存溢出 </p>
<p>stop the word :停止到所有用户线程 然fullgc 让full gc 专心回收内存  原因是为了防止gc在处理的时候 突然有线程停止 产生大量垃圾 会增加gc的复杂度 也会让gc的清理不够干净</p>
<p>本地方法栈：native 修饰方法 会到底层去找c语言实现</p>
<p>jvm调优：计算业务可能触发的内存大小，然后对堆内存 年轻代进行合理的内存分配，让对象尽量不要进入老年代 触发full gc 从而触发STW导致系统卡顿   （进入survivor区内存的对象如果内存超过 survivor区内存的50%会被直接移入到老年代内去  极易导致STW）</p>
]]></content>
  </entry>
  <entry>
    <title>sql优化相关之如何写出一条好sql</title>
    <url>/posts/785a1566/</url>
    <content><![CDATA[<h2 id="sql架构与存储引擎"><a href="#sql架构与存储引擎" class="headerlink" title="sql架构与存储引擎"></a>sql架构与存储引擎</h2><h3 id="Qps与Tps"><a href="#Qps与Tps" class="headerlink" title="Qps与Tps"></a>Qps与Tps</h3><p>​                TPS: 指服务器每秒处理的事务数 ，<strong>支持事务的存储引擎</strong>特有的一个性能指标 </p><p>TPS = (事务提交+事务回滚）/运行时间</p><p>​                QPS:执行sql等待返回结果之间的等待时间</p><p>QPS=查询个数/运行时间</p><h3 id="mysqlslap"><a href="#mysqlslap" class="headerlink" title="mysqlslap"></a>mysqlslap</h3><a id="more"></a>



<p>MySQLSlap是从MySQL5.1.4版本就开始的官方提供的压力测试工具，能测试MySQL服务器的性能</p>
<h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p>​    <strong>连接层</strong></p>
<p>MySQL启动时 MySQL自己会创建一个线程 每一个用户对MySQL进行连接时，服务器都会新建一个线程去处理这一个连接，每个线程都是独立的 但是如果有两个线程进行修改同一块内存时会引发数据同步问题</p>
<p><img alt="1589769109015" data-src="/1589769109015.png"></p>
<p><strong>sql处理层</strong></p>
<p>sql语句的解析，优化，缓存的查询 MySQL内置函数的实现等</p>
<p>1，如果是查询语句select，首先会查询缓存是否已经有对应的结果，有返回结果 没有的话进行下一步 </p>
<p>2，解析查询，创建一个内部数据结构这个解析树用于解析SQL语法</p>
<p>3，优化sql语句，列如重写查询，决定表的读写顺序以及选择需要的查询等，这一阶段用户是可以查询的，用户可以针对的进行一个调优</p>
<p><img alt="1589770015142" data-src="1589770015142.png"></p>
<p><strong>sql缓存</strong></p>
<p>show variables like ‘%query_cache_type%’ </p>
<p>查询数据库缓存是否开启</p>
<p><strong>sql转换器</strong></p>
<p>将传输进来的sql语句转换成MySQL能看得懂的样子</p>
<p><img alt="1589770451852" data-src="1589770451852.png"></p>
<p><strong>sql优化器</strong></p>
<p>能够优化一些MySQL中很明显得一些冗余代码 （列如 1=1），使得代码变得更加简单</p>
<h3 id="mylsam存储引擎"><a href="#mylsam存储引擎" class="headerlink" title="mylsam存储引擎"></a>mylsam存储引擎</h3><p><strong>文件结构</strong></p>
<ul>
<li>frm //存储表结构，所有得引擎都具备</li>
<li>myd  //数据文件</li>
<li>myi //索引文件</li>
</ul>
<p><strong>mysam特点</strong></p>
<ul>
<li>并发性与锁级别-表级锁</li>
<li>支持全文检索</li>
<li>支持数据压缩</li>
<li>myisampack -d -f testmysam.myl  文件压缩指令</li>
</ul>
<p><strong>mysam适用场景</strong></p>
<ul>
<li>非事务型应用（数据仓库，报表，日志数据）</li>
<li>只读类应用</li>
<li>空间类应用（地图等应用 更好得计算函数）</li>
</ul>
<h3 id="innodb存储引擎"><a href="#innodb存储引擎" class="headerlink" title="innodb存储引擎"></a><strong>innodb存储引擎</strong></h3><p>innodb是MySQL在5.5以后版本的默认数据库</p>
<p>innodb_file_per_table  属性 no代表独立表空间 off代表系统表空间 on的时候会创建一个.ibd文件 内容是（数据+索引）mysql5.6以前都是默认系统表空间</p>
<p>比较：</p>
<ul>
<li>系统表空间无法简单的收缩文件大小（所以占用磁盘内存会越来越大）</li>
<li>独立表空间可以通过optimize table收缩系统文件</li>
<li>系统表空间会产生io瓶颈</li>
<li>独立表空间可以同时向多个文件刷新数据</li>
</ul>
<p>（列如一张表有100w条数据占用磁盘内存 100000kb 当你把表中数据清除时 他在磁盘的占用内存还是 100000kb 无法收缩文件大小）</p>
<p><img alt="1589773241899" data-src="1589773241899.png"></p>
<p><strong>适用场景</strong>：</p>
<p>修改较多，事务操作较多的场景</p>
<h3 id="CSV存储引擎"><a href="#CSV存储引擎" class="headerlink" title="CSV存储引擎"></a>CSV存储引擎</h3><p>​    <strong>结构</strong></p>
<ul>
<li>​        数据以文本的方式存储在文件</li>
<li>​        .csv文件存储内容</li>
<li>​        .csm文件存储表的元数据如表的状态数据量等</li>
<li>​        .frm表结构</li>
</ul>
<p>​    <strong>特点</strong></p>
<ul>
<li>以csv格式进行数据存储 所有的列都不能为null 不支持索引 （不适合大表，不适合在线处理）</li>
<li>可以对数据文件直接编辑（保存文本文件内容）</li>
<li>修改文件以后运行FLUSH TABLES进行刷新</li>
<li>列的最后得有一个空行</li>
</ul>
<h3 id="Archive存储引擎"><a href="#Archive存储引擎" class="headerlink" title="Archive存储引擎"></a>Archive存储引擎</h3><p><strong>组成</strong></p>
<p>以zlib对表数据进行压缩，磁盘i/o更少数据存储在ARZ为后缀的文件中</p>
<p><strong>特点</strong></p>
<ul>
<li>只支持insert和select操作</li>
<li>只允许在自增ID列上加索引</li>
</ul>
<p><strong>使用场景</strong></p>
<p>日志和数据采集应用</p>
<h3 id="Memory-存储引擎"><a href="#Memory-存储引擎" class="headerlink" title="Memory 存储引擎"></a>Memory 存储引擎</h3><p><strong>特点</strong></p>
<ul>
<li>文件系统存储特点</li>
<li>支持hash索引和btree索引</li>
<li>所有字段都是固定长度</li>
<li>不支持blog和text等大字段</li>
<li>Memory存储引擎使用表级锁</li>
<li>最大大小由max_heap_table_size参数决定</li>
<li>数据存储到内存当中</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><p>hash索引用于查找或者是映射表</p>
</li>
<li><p>用于保存数据分析中产生的中间表</p>
</li>
<li><p>用于缓存周期性聚合数据的结果表<br>注意：memory数据易丢失，所以要求数据可再生</p>
</li>
</ul>
<h3 id="Ferderated-存储引擎"><a href="#Ferderated-存储引擎" class="headerlink" title="Ferderated 存储引擎"></a>Ferderated 存储引擎</h3><p><strong>特点</strong></p>
<ul>
<li>提供了访问远程MySQL服务器上表的方法</li>
<li>本地不存储数据，数据全部放到远程服务器上</li>
<li>本地需要保存表结构和远程服务器的连接信息</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>偶尔的统计分析及手工查询</li>
</ul>
<h2 id="sql锁机制"><a href="#sql锁机制" class="headerlink" title="sql锁机制"></a>sql锁机制</h2><h3 id="MySQL中的锁"><a href="#MySQL中的锁" class="headerlink" title="MySQL中的锁"></a><strong>MySQL中的锁</strong></h3><p>​        表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率较高，并发低 常见表级锁的存储引擎有mylsam 表级锁更加适合以查询为主的场景  </p>
<p>​        行级锁: 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度高，常见的行级锁存储引擎有innodb 更适合有修改操作的事务场景</p>
<h3 id="myisam的表锁"><a href="#myisam的表锁" class="headerlink" title="myisam的表锁"></a>myisam的表锁</h3><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a><strong>读锁</strong></h4><p><strong>加共享读锁</strong> lock table 表名 read</p>
<p><strong>测试</strong></p>
<ol>
<li>lock table testmysam READ 启动另外一个session select * from<br>testmysam 可以查询</li>
<li>insert into testmysam value(2);<br>update testmysam set id=2 where id=1;<br>报错</li>
<li>在另外一个session中<br> insert into testmysam value(2); 等待</li>
<li>在同一个session中<br> insert into testdemo value(2,’2’,’3’); 报错<br> select * from testdemo ; 报错</li>
<li>在另外一个session中<br> insert into testdemo value(2,’2’,’3’); 成功</li>
<li>加索在同一个session 中 select s.* from testmysam s 报错<br> lock table 表名 as 别名 read;</li>
<li>查看 show status LIKE ‘table_locks_waited’ 表被锁过几次 </li>
<li>UNLOCK TABLES  删除锁</li>
</ol>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a><strong>写锁</strong></h4><p><strong>加独占写锁</strong> lock table 表名 write</p>
<p><strong>测试</strong></p>
<ol>
<li>lock table testmysam WRITE<br>在同一个session中<br>insert testmysam value(3);<br>delete from testmysam where id = 3<br>select * from testmysam</li>
<li>对不同的表操作（ 报错）<br>select s.* from testmysam s<br>insert into testdemo value(2,’2’,’3’);</li>
<li>在其他session中 （ 等待）<br>select * from testmysam </li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>对myisam表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求</li>
<li>对myisam表的读操作，不会阻塞但前session对表读，当对表进行修改会保存</li>
<li>一个session使用LOCK TABLE命令给表f加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误</li>
<li>另外一个session可以查询表中的记录，但更新就会出现锁等待</li>
<li>对myisam表的写操作，则会阻塞其他用户对同一表的读和写操作</li>
<li>对myisam表的写操作，当前session可以对本表做crud，但对其他表进行操作就会报错</li>
</ul>
<h3 id="innoDB行锁"><a href="#innoDB行锁" class="headerlink" title="innoDB行锁"></a>innoDB行锁</h3><p><strong>行锁简介</strong></p>
<p>共享锁又称：读锁，当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁</p>
<p>排他锁又称：写锁。当一个事务对某几个上写锁时，不允许其他事务写，但允许读，更不允许其他事务给这几行上任何锁，包括写锁。</p>
<p><strong>语法</strong>：</p>
<p>上共享锁的写法：lock in share mode </p>
<p>列如：select * from 表 where 条件 lock in share mode </p>
<p>上排他锁的写法： for update</p>
<p>列如： select * from 表 where 条件 for update </p>
<p><strong>注意：</strong></p>
<ol>
<li>两个事务不能锁同一个索引</li>
<li>insert，delete，update 在事务中都会自动默认加上排他锁</li>
<li>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了</li>
</ol>
<p><strong>测试：</strong></p>
<ol>
<li><p>BEGIN<br>select * from testdemo where id =1 for update<br>在另外一个session中<br>update testdemo set c1 = ‘1’ where id = 2 成功<br>update testdemo set c1 = ‘1’ where id = 1 等待</p>
</li>
<li><p>BEGIN<br>update testdemo set c1 = ‘1’ where id = 1<br>在另外一个session中<br>update testdemo set c1 = ‘1’ where id = 1 等待</p>
</li>
<li><p>BEGIN</p>
<p>update testdemo set c1 = ‘1’ where  c1 = ‘1’ 在另外一个session中 update testdemo set c1 = ‘2’ where c1 = ‘2’ 等待</p>
</li>
</ol>
<p><strong>先来看下行锁</strong><br>第一个session中<br>select * from testdemo where id =1 for update<br>第二个session<br>select * from testdemo where id =1 lock in share mode<br>回到第一个session UNLOCK TABLES 并不会解锁<br>使用commit 或者 begin或者ROLLBACK 才会解锁</p>
<p><strong>再来看下表锁</strong><br>lock table testdemo WRITE<br>使用commit， ROLLBACK 并不会解锁<br>使用UNLOCK TABLES 或者begin会解锁 </p>
<h2 id="sql事务"><a href="#sql事务" class="headerlink" title="sql事务"></a>sql事务</h2><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p>事务有4个属性：原子性，一致性，隔离性，持久性。简称为ACID特性</p>
<ul>
<li>原子性：一组事务要么全部成功要么全部失败</li>
<li>一致性：事务前后的数据不可以丢失不可以不一致</li>
<li>隔离性：一个事务不能被另一个事务所干扰，即并发执行的各个事务之间不能互相干扰。</li>
<li>持久性：一个事务一旦提交 其对数据的改变就必须是永久性的</li>
</ul>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>事务有四种隔离级别</p>
<ul>
<li>​    读未提交   可能会产生脏读问题</li>
<li>​    读已提交   可能会产生不可重复读问题</li>
<li>​    可重复读  可以对产生幻读问题</li>
<li>​    可串行化   </li>
</ul>
<p>MySQL的默认隔离级别为可重复读</p>
<p><strong>并发问题</strong></p>
<ul>
<li>脏读：事务a读取到了事务b更新的数据，然后b进行了回滚操作 导致a读到的数据并不准确</li>
<li>不可重复读： 事务A多次读取一个数据，事务b在事务a读取时进行了更新操作，但是由于事务a读取的还是未进行更新的数据，所以事务A读取的数据并不准确</li>
<li>幻读：事务A开启事务准备往表里插入一条数据，而事务B也一样</li>
</ul>
<p><strong>事务的语法</strong></p>
<ul>
<li>开启事务<ol>
<li>start transaction</li>
<li>begin work</li>
<li>begin</li>
</ol>
</li>
<li>事务回滚 rollback</li>
<li>事务提交 commit</li>
<li>还原点 savepoint</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间、行锁、页锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表</strong></p>
<p><strong>事务隔离级别为串行化时，读写数据都会锁住整张表</strong></p>
<p><strong>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed**</strong>，它能够避免脏读取，而且具有较好的并发性能。**</p>
<h2 id="sql业务设计"><a href="#sql业务设计" class="headerlink" title="sql业务设计"></a>sql业务设计</h2><h3 id="范式设计-三大范式"><a href="#范式设计-三大范式" class="headerlink" title="范式设计 三大范式"></a>范式设计 三大范式</h3><p><strong>第一范式</strong></p>
<p>数据库表中的所有字段都只具有单一属性</p>
<p>单一属性的列是由基本数据类型所构成的</p>
<p>设计出来的表都是简单的二维表</p>
<p><img alt="img" data-src="2.png"> </p>
<p>name-age列具有两个属性，一个name,一个 age不符合第一范式，把它拆分成两列</p>
<p><img alt="img" data-src="3.png"></p>
<p><strong>第二范式</strong></p>
<p>要求表中只具有一个业务主键，也就是说符合第二范式的表不能存在非主键列只对部分主键的依赖关系</p>
<p>有两张表：订单表，产品表</p>
<p><img alt="img" data-src="4.png"></p>
<p><img alt="img" data-src="5.png"></p>
<p>一个订单有多个产品，所以订单的主键为【订单ID】和【产品ID】组成的联合主键，这样2个组件不符合第二范式，而且产品ID和订单ID没有强关联，故，把订单表进行拆分为订单表与订单与商品的中间表</p>
<p><img alt="img" data-src="6.png"></p>
<p><strong>第三范式</strong></p>
<p>指每一个非非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上相处了非主键对主键的传递依赖</p>
<p><img alt="img" data-src="7.png"></p>
<p>其中</p>
<p><strong>客户编号</strong> <strong>和订单编号管理</strong> <strong>关联</strong></p>
<p><strong>客户姓名</strong> <strong>和订单编号管理</strong> <strong>关联</strong></p>
<p><strong>客户编号</strong> <strong>和</strong> <strong>客户姓名</strong> <strong>关联</strong></p>
<p>如果客户编号发生改变，用户姓名也会改变，这样不符合第三大范式，应该<strong>把客户姓名这一列删除</strong></p>
<h3 id="反范式设计"><a href="#反范式设计" class="headerlink" title="反范式设计"></a>反范式设计</h3><h4 id="什么叫反范式化设计"><a href="#什么叫反范式化设计" class="headerlink" title="什么叫反范式化设计"></a>什么叫反范式化设计</h4><ul>
<li>反范式化是针对范式化而言得，在前面介绍了数据库设计得范式</li>
<li>所谓得反范式化就是为了性能和读取效率得考虑而适当得对数据库设计范式得要求进行违反</li>
<li>允许存在少量得冗余，换句话来说反范式化就是使用空间来换取时间</li>
</ul>
<p>商品信息反范式设计</p>
<p>下面是范式设计的商品信息表</p>
<p><img alt="1589872072524" data-src="1589872072524.png"></p>
<p>商品信息和分类信息经常一起查询，所以把分类信息也放到商品表里面，冗余存放</p>
<p>在线销售功能反范式</p>
<p>下面是在线手写功能的范式设计</p>
<p><img alt="1589872083937" data-src="1589872083937.png"></p>
<p> 范式化设计优缺点</p>
<p>优点：</p>
<p>  可以尽量得减少数据冗余</p>
<p>  范式化的更新操作比反范式化更快</p>
<p>  范式化的表通常比反范式化的表更小</p>
<p>缺点：</p>
<p>   对于查询需要对多个表进行关联</p>
<p>   更难进行索引优化 </p>
<h4 id="反范式化设计优缺点"><a href="#反范式化设计优缺点" class="headerlink" title="反范式化设计优缺点"></a>反范式化设计优缺点</h4><p>优点：</p>
<p> 可以减少表的关联</p>
<p>可以更好的进行索引优化</p>
<p>缺点：</p>
<p>  存在数据冗余及数据维护异常</p>
<p>  对数据的修改需要更多的成本</p>
<h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>数据库、表、字段的命名要遵守可读性原则</p>
<p>使用大小写来格式化的库对象名字以获得良好的可读性</p>
<p>例如：使用custAddress而不是custaddress来提高可读性。</p>
<p>数据库、表、字段的命名要遵守表意性原则</p>
<p>对象的名字应该能够描述它所表示的对象</p>
<p>例如：</p>
<p>对于表，表的名称应该能够体现表中存储的数据内容；对于存储过程</p>
<p>存储过程应该能够体现存储过程的功能。</p>
<p>数据库、表、字段的命名要遵守长名原则</p>
<p>尽可能少使用或者不使用缩写</p>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p><img alt="img" data-src="8.png"></p>
<h3 id="数据类型选择"><a href="#数据类型选择" class="headerlink" title="数据类型选择"></a>数据类型选择</h3><p>当一个列可以选择多种数据类型时</p>
<p>l  优先考虑数字类型</p>
<p>l  其次是日期、时间类型</p>
<p>l  最后是字符类型</p>
<p>l  对于相同级别的数据类型，应该优先选择占用空间小的数据类型</p>
<p>浮点类型</p>
<p><img alt="img" data-src="ss.png"></p>
<p>注意float 和double 是非精度类型，如果是和金额相关尽量用decimal</p>
<p><img alt="img" data-src="9.png"></p>
<p>select sum(c1),sum(c2),sum(c3) from test_numberic</p>
<p><img alt="img" data-src="10.png"></p>
<p>日期类型</p>
<p>面试经常问道 timestamp 类型 与 datetime区别</p>
<p><img alt="img" data-src="11.png"></p>
<p>datetime类型在5.6中字段长度是5个字节</p>
<p>datetime类型在5.5中字段长度是8个字节</p>
<p><strong>timestamp</strong> <strong>和时区有关，而datetime**</strong>无关**</p>
<p><img alt="img" data-src="12.png"></p>
<p>insert into  test_time  VALUES(NOW(),NOW(),NOW());</p>
<p>set time_zone=”-10:00”</p>
<p><img alt="img" data-src="13.png"></p>
<h2 id="sql慢查询"><a href="#sql慢查询" class="headerlink" title="sql慢查询"></a>sql慢查询</h2><h3 id="什么是慢查询"><a href="#什么是慢查询" class="headerlink" title="什么是慢查询"></a>什么是慢查询</h3><p>慢查询日志，顾名思义，就是查询慢的日志，是指mysql记录所有执行超过long_query_time参数设定的时间阈值的SQL语句的日志。该日志能为SQL语句的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要使用慢查询日志功能，首先要开启慢查询日志功能。（也就是说 把查询慢的SQL写到一个日志中）</p>
<p> 1.1.1.    慢查询基本配置</p>
<ul>
<li><p>slow_query_log 启动停止技术慢查询日志</p>
</li>
<li><p>slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</p>
</li>
<li><p>long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）</p>
</li>
<li><p>log_queries_not_using_indexes  是否记录未使用索引的SQL</p>
</li>
<li><p>log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】</p>
</li>
</ul>
<p>配置了慢查询后，它会记录符合条件的SQL</p>
<p>包括：</p>
<ol>
<li><p>查询语句</p>
</li>
<li><p>数据修改语句</p>
</li>
<li><p>已经回滚得SQL </p>
</li>
</ol>
<p><strong>实操：</strong></p>
<p>通过下面命令查看下上面的配置：</p>
<p>show VARIABLES like ‘%slow_query_log%’</p>
<p>show VARIABLES like ‘%slow_query_log_file%’ </p>
<p>show VARIABLES like ‘%long_query_time%’ </p>
<p>show VARIABLES like ‘%log_queries_not_using_indexes%’ </p>
<p>show VARIABLES like ‘log_output’  </p>
<p>set global long_query_time=0;   —默认10秒，这里为了演示方便设置为0  </p>
<p>set GLOBAL  slow_query_log = 1; –开启慢查询日志 </p>
<p>set global log_output=’FILE,TABLE’  –项目开发中日志只能记录在日志文件中，不能记表中  </p>
<p>设置完成后，查询一些列表可以发现慢查询的日志文件里面有数据了。</p>
<h3 id="1-1-1-慢查询基本配置"><a href="#1-1-1-慢查询基本配置" class="headerlink" title="1.1.1.    慢查询基本配置"></a>1.1.1.    慢查询基本配置</h3><ul>
<li>slow_query_log 启动停止技术慢查询日志</li>
<li>slow_query_log_file 指定慢查询日志得存储路径及文件（默认和数据文件放一起）</li>
<li>long_query_time 指定记录慢查询日志SQL执行时间得伐值（单位：秒，默认10秒）</li>
<li>log_queries_not_using_indexes  是否记录未使用索引的SQL</li>
<li>log_output 日志存放的地方【TABLE】【FILE】【FILE,TABLE】</li>
</ul>
<p>配置了慢查询后，它会记录符合条件的SQL</p>
<p>包括：</p>
<ul>
<li>查询语句</li>
<li>数据修改语句</li>
<li>已经回滚得SQL </li>
</ul>
<p><strong>实操：</strong></p>
<p><strong>通过下面命令查看下上面的配置：</strong></p>
<ul>
<li>show VARIABLES like ‘%slow_query_log%’</li>
<li>show VARIABLES like ‘%slow_query_log_file%’</li>
<li>show VARIABLES like ‘%long_query_time%’</li>
<li>show VARIABLES like ‘%log_queries_not_using_indexes%’</li>
<li>show VARIABLES like ‘log_output’</li>
<li>set global long_query_time=0;   —默认10秒，这里为了演示方便设置为0 </li>
<li>set GLOBAL  slow_query_log = 1; –开启慢查询日志</li>
<li>set global log_output=’FILE,TABLE’  –项目开发中日志只能记录在日志文件中，不能记表中</li>
</ul>
<p>设置完成后，查询一些列表可以发现慢查询的日志文件里面有数据了。</p>
<p><strong>Mysqldumpslow</strong></p>
<p>常用的慢查询日志分析工具，汇总除查询条件外其他完全相同的SQL，并将分析结果按照参数中所指定的顺序输出。</p>
<p><strong>语法：</strong></p>
<p>mysqldumpslow -s r -t 10 slow-mysql.log</p>
<p>-s order (c,t,l,r,at,al,ar) </p>
<p>​         c:总次数</p>
<p>​         t:总时间</p>
<p>​         l:锁的时间</p>
<p>​         r:总数据行</p>
<p>​         at,al,ar  :t,l,r平均数  【例如：at = 总时间/总次数】</p>
<p>  -t  top   指定取前面几天作为结果输出</p>
<p> //运行指令</p>
<p>mysqldumpslow.pl -s t -t 10 D:\DESKTOP-2EKGEE5-slow.log </p>
<h2 id="sql索引与执行计划"><a href="#sql索引与执行计划" class="headerlink" title="sql索引与执行计划"></a>sql索引与执行计划</h2><h3 id="生活中的索引"><a href="#生活中的索引" class="headerlink" title="生活中的索引"></a>生活中的索引</h3><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
<p>可以得到索引的本质：<strong>索引是数据结构</strong>。</p>
<p>上面的理解比较抽象，举一个例子，平时看任何一本书，首先看到的都是目录，通过目录去查询书籍里面的内容会非常的迅速。</p>
<h3 id="MySql中的索引"><a href="#MySql中的索引" class="headerlink" title="MySql中的索引"></a>MySql中的索引</h3><p><img alt="1589883497088" data-src="1589883497088.png"></p>
<p>MySql中的索引其实也是这么一回事，我们可以在数据库中建立一系列的索引，比如创建主键的时候默认会创建主键索引，上图是一种BTREE的索引。每一个节点都是主键的ID</p>
<p>当我们通过ID来查询内容的时候，首先去查索引库，在到索引库后能快速的定位索引的具体位置。</p>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p><strong>普通索引：</strong>即一个索引只包含单个列，一个表可以有多个单列索引</p>
<p><strong>唯一索引：</strong>索引列的值必须唯一，但允许有空值</p>
<p><strong>复合索引：</strong>即一个索引包含多个列 </p>
<p><strong>聚簇索引(聚集索引)</strong>：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。 </p>
<p><strong>非聚簇索引：</strong>不是聚簇索引，就是非聚簇索引</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>查看索引</strong></p>
<p>SHOW INDEX FROM table_name\G</p>
<p><strong>创建索引</strong></p>
<p>CREATE  [UNIQUE ] INDEX indexName ON mytable(columnname(length));</p>
<p>ALTER TABLE 表名 ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) </p>
<p><strong>删除索引</strong></p>
<p>DROP INDEX [indexName] ON mytable;</p>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p><strong>什么是执行计划</strong></p>
<p> 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是</p>
<p>如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<p><strong>执行计划的作用</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p><strong>执行计划的语法</strong></p>
<p>执行计划的语法其实非常简单： 在SQL查询的前面加上EXPLAIN关键字就行。</p>
<p>比如：EXPLAIN select * from table1 </p>
<p>重点的就是EXPLAIN后面你要分析的SQL语句 </p>
<h4 id="执行计划详解"><a href="#执行计划详解" class="headerlink" title="执行计划详解"></a><strong>执行计划详解</strong></h4><p>通过EXPLAIN关键分析的结果由以下列组成，接下来挨个分析每一个列</p>
<p><img alt="1589883858311" data-src="1589883858311.png"></p>
<p><strong>1. ID列</strong></p>
<p>ID列：描述select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<p>根据ID的数值结果可以分成一下三种情况</p>
<ul>
<li>id相同：执行顺序由上至下  （按照表在sql语句中的排列顺序进行加载）</li>
<li>id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行（如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行）</li>
<li>id相同不同：同时存在（id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行）</li>
</ul>
<p><strong>2. select_type列</strong></p>
<p>Select_type：查询的类型</p>
<p>用于区别：普通查询、联合查询、子查询等的复杂查询</p>
<p>类型如下</p>
<p><img alt="1589884184701" data-src="1589884184701.png"></p>
<p><strong>3.table列</strong></p>
<p>显示这一行数据是关于那张表从那张表而来的</p>
<p><strong>4.Type列</strong></p>
<p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </p>
<p>需要记忆的</p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><strong>属性解析：</strong></p>
<p>System：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p>
<p>Const：表示通过索引一次就找到了const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快</p>
<p>eq_ref ：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p>
<p>Ref： 非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p>
<p>Range： 只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p>
<p> Index：当查询的结果全为索引列的时候，虽然也是全部扫描，但是只查询的索引库，而没有去查询数据。</p>
<p>All： Full Table Scan，将遍历全表以找到匹配的行</p>
<p><strong>5.possible_keys 与Key列</strong></p>
<p>possible_keys:可能使用的索引</p>
<p>Key:实际使用的索引。如果为NULL，则没有使用索引</p>
<p> <strong>6.key_len</strong></p>
<p>Key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p>
<h2 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h2><p><strong>尽量全值匹配 ：</strong> 如果可以匹配条件越多越好</p>
<p><strong>最佳左前缀：</strong>让索引不失效的一个策略，也就是使用索引时，第一个索引字段一定要存在，如果第一个索引字段不存在则会出现索引失效问题</p>
<p><strong>不在索引列上做任何操作：</strong>（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</p>
<p><strong>范围条件放最后：</strong>中间有范围查询会导致后面的索引列全部失效</p>
<p><strong>覆盖索引尽量用</strong>：尽量使用覆盖索引(只访问索引的而不去访问整张表数据的查询(索引列和查询列一致) )，减少select *</p>
<p><strong>不等于要甚用</strong>：在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</p>
<p><strong>Null/Not 有影响：</strong>null/not null对索引的可能影响</p>
<p><strong>Like查询要当心：</strong>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</p>
<p><strong>字符类型加引号：</strong>字符串不加单引号索引失效</p>
<p><strong>OR改UNION效率高：</strong>在使用or的时候尽量更换为union  </p>
<h2 id="sql函数相关拓展"><a href="#sql函数相关拓展" class="headerlink" title="sql函数相关拓展"></a>sql函数相关拓展</h2><h4 id="一、数学函数"><a href="#一、数学函数" class="headerlink" title="一、数学函数"></a>一、数学函数</h4><p>ABS(x)   返回x的绝对值<br>BIN(x)   返回x的二进制（OCT返回八进制，HEX返回十六进制）<br>CEILING(x)   返回大于x的最小整数值<br>EXP(x)   返回值e（自然对数的底）的x次方<br>FLOOR(x)   返回小于x的最大整数值<br>GREATEST(x1,x2,…,xn)返回集合中最大的值<br>LEAST(x1,x2,…,xn)      返回集合中最小的值<br>LN(x)                    返回x的自然对数<br>LOG(x,y)返回x的以y为底的对数<br>MOD(x,y)                 返回x/y的模（余数）<br>PI()返回pi的值（圆周率）<br>RAND()返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。<br>ROUND(x,y)返回参数x的四舍五入的有y位小数的值<br>SIGN(x) 返回代表数字x的符号的值<br>SQRT(x) 返回一个数的平方根<br>TRUNCATE(x,y)            返回数字x截短为y位小数的结果</p>
<h4 id="二、聚合函数-常用于GROUP-BY从句的SELECT查询中"><a href="#二、聚合函数-常用于GROUP-BY从句的SELECT查询中" class="headerlink" title="二、聚合函数(常用于GROUP BY从句的SELECT查询中)"></a>二、聚合函数(常用于GROUP BY从句的SELECT查询中)</h4><p>AVG(col)返回指定列的平均值<br>COUNT(col)返回指定列中非NULL值的个数<br>MIN(col)返回指定列的最小值<br>MAX(col)返回指定列的最大值<br>SUM(col)返回指定列的所有值之和<br>GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果</p>
<h4 id="三、字符串函数"><a href="#三、字符串函数" class="headerlink" title="三、字符串函数"></a>三、字符串函数</h4><p>ASCII(char)返回字符的ASCII码值<br>BIT_LENGTH(str)返回字符串的比特长度<br>CONCAT(s1,s2…,sn)将s1,s2…,sn连接成字符串<br>CONCAT_WS(sep,s1,s2…,sn)将s1,s2…,sn连接成字符串，并用sep字符间隔<br>INSERT(str,x,y,instr) 将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果<br>FIND_IN_SET(str,list)分析逗号分隔的list列表，如果发现str，返回str在list中的位置<br>LCASE(str)或LOWER(str) 返回将字符串str中所有字符改变为小写后的结果<br>LEFT(str,x)返回字符串str中最左边的x个字符<br>LENGTH(s)返回字符串str中的字符数<br>LTRIM(str) 从字符串str中切掉开头的空格<br>POSITION(substr,str) 返回子串substr在字符串str中第一次出现的位置<br>QUOTE(str) 用反斜杠转义str中的单引号<br>REPEAT(str,srchstr,rplcstr)返回字符串str重复x次的结果<br>REVERSE(str) 返回颠倒字符串str的结果<br>RIGHT(str,x) 返回字符串str中最右边的x个字符<br>RTRIM(str) 返回字符串str尾部的空格<br>STRCMP(s1,s2)比较字符串s1和s2<br>TRIM(str)去除字符串首部和尾部的所有空格<br>UCASE(str)或UPPER(str) 返回将字符串str中所有字符转变为大写后的结果</p>
<h4 id="四、日期和时间函数"><a href="#四、日期和时间函数" class="headerlink" title="四、日期和时间函数"></a>四、日期和时间函数</h4><p>CURDATE()或CURRENT_DATE() 返回当前的日期<br>CURTIME()或CURRENT_TIME() 返回当前的时间<br>DATE_ADD(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH);<br>DATE_FORMAT(date,fmt)  依照指定的fmt格式格式化日期date值<br>DATE_SUB(date,INTERVAL int keyword)返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化),如：SELECTDATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH);<br>DAYOFWEEK(date)   返回date所代表的一星期中的第几天(1<del>7)<br>DAYOFMONTH(date)  返回date是一个月的第几天(1</del>31)<br>DAYOFYEAR(date)   返回date是一年的第几天(1<del>366)<br>DAYNAME(date)   返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);<br>FROM_UNIXTIME(ts,fmt)  根据指定的fmt格式，格式化UNIX时间戳ts<br>HOUR(time)   返回time的小时值(0</del>23)<br>MINUTE(time)   返回time的分钟值(0<del>59)<br>MONTH(date)   返回date的月份值(1</del>12)<br>MONTHNAME(date)   返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);<br>NOW()    返回当前的日期和时间<br>QUARTER(date)   返回date在一年中的季度(1<del>4)，如SELECT QUARTER(CURRENT_DATE);<br>WEEK(date)   返回日期date为一年中第几周(0</del>53)<br>YEAR(date)   返回日期date的年份(1000~9999)<br>一些示例：<br>获取当前系统时间：SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());<br>SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);<br>SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);<br>SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE);<br>返回两个日期值之间的差值(月数)：SELECT PERIOD_DIFF(200302,199802);<br>在Mysql中计算年龄：<br>SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),’%Y’)+0 AS age FROM employee;<br>这样，如果Brithday是未来的年月日的话，计算结果为0。<br>下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。<br>SELECT DATE_FORMAT(NOW(), ‘%Y’) - DATE_FORMAT(birthday, ‘%Y’) -(DATE_FORMAT(NOW(), ‘00-%m-%d’) &lt;DATE_FORMAT(birthday, ‘00-%m-%d’)) AS age from employee</p>
<h4 id="五、加密函数"><a href="#五、加密函数" class="headerlink" title="五、加密函数"></a>五、加密函数</h4><p>AES_ENCRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储<br>AES_DECRYPT(str,key)  返回用密钥key对字符串str利用高级加密标准算法解密后的结果<br>DECODE(str,key)   使用key作为密钥解密加密字符串str<br>ENCRYPT(str,salt)   使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str<br>ENCODE(str,key)   使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储<br>MD5()    计算字符串str的MD5校验和<br>PASSWORD(str)   返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。<br>SHA()    计算字符串str的安全散列算法(SHA)校验和<br>示例：<br>SELECT ENCRYPT(‘root’,’salt’);<br>SELECT ENCODE(‘xufeng’,’key’);<br>SELECT DECODE(ENCODE(‘xufeng’,’key’),’key’);#加解密放在一起<br>SELECT AES_ENCRYPT(‘root’,’key’);<br>SELECT AES_DECRYPT(AES_ENCRYPT(‘root’,’key’),’key’);<br>SELECT MD5(‘123456’);<br>SELECT SHA(‘123456’);</p>
<h4 id="六、控制流函数"><a href="#六、控制流函数" class="headerlink" title="六、控制流函数"></a>六、控制流函数</h4><p>MySQL有4个函数是用来进行条件操作的，这些函数可以实现SQL的条件逻辑，允许开发者将一些应用程序业务逻辑转换到数据库后台。<br>MySQL控制流函数：<br>CASE WHEN[test1] THEN [result1]…ELSE [default] END如果testN是真，则返回resultN，否则返回default<br>CASE [test] WHEN[val1] THEN [result]…ELSE [default]END  如果test和valN相等，则返回resultN，否则返回default<br>IF(test,t,f)   如果test是真，返回t；否则返回f<br>IFNULL(arg1,arg2) 如果arg1不是空，返回arg1，否则返回arg2<br>NULLIF(arg1,arg2) 如果arg1=arg2返回NULL；否则返回arg1<br>这些函数的第一个是IFNULL()，它有两个参数，并且对第一个参数进行判断。如果第一个参数不是NULL，函数就会向调用者返回第一个参数；如果是NULL,将返回第二个参数。<br>如：SELECT IFNULL(1,2), IFNULL(NULL,10),IFNULL(4*NULL,’false’);<br>NULLIF()函数将会检验提供的两个参数是否相等，如果相等，则返回NULL，如果不相等，就返回第一个参数。<br>如：SELECT NULLIF(1,1),NULLIF(‘A’,’B’),NULLIF(2+3,4+1);<br>和许多脚本语言提供的IF()函数一样，MySQL的IF()函数也可以建立一个简单的条件测试，这个函数有三个参数，第一个是要被判断的表达式，如果表达式为真，IF()将会返回第二个参数，如果为假，IF()将会返回第三个参数。<br>如：SELECTIF(1&lt;10,2,3),IF(56&gt;100,’true’,’false’);<br>IF()函数在只有两种可能结果时才适合使用。然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。在这种情况下，MySQL提供了CASE函数，它和PHP及Perl语言的switch-case条件例程一样。<br>CASE函数的格式有些复杂，通常如下所示：<br>CASE [expression to be evaluated]<br>WHEN [val 1] THEN [result 1]<br>WHEN [val 2] THEN [result 2]<br>WHEN [val 3] THEN [result 3]<br>……<br>WHEN [val n] THEN [result n]<br>ELSE [default result]<br>END<br>这里，第一个参数是要被判断的值或表达式，接下来的是一系列的WHEN-THEN块，每一块的第一个参数指定要比较的值，如果为真，就返回结果。所有的WHEN-THEN块将以ELSE块结束，当END结束了所有外部的CASE块时，如果前面的每一个块都不匹配就会返回ELSE块指定的默认结果。如果没有指定ELSE块，而且所有的WHEN-THEN比较都不是真，MySQL将会返回NULL。<br>CASE函数还有另外一种句法，有时使用起来非常方便，如下：<br>CASE<br>WHEN [conditional test 1] THEN [result 1]<br>WHEN [conditional test 2] THEN [result 2]<br>ELSE [default result]<br>END<br>这种条件下，返回的结果取决于相应的条件测试是否为真。<br>示例：<br>mysql&gt;SELECT CASE ‘green’<br>     WHEN ‘red’ THEN ‘stop’<br>     WHEN ‘green’ THEN ‘go’ END;<br>SELECT CASE 9 WHEN 1 THEN ‘a’ WHEN 2 THEN ‘b’ ELSE ‘N/A’ END;<br>SELECT CASE WHEN (2+2)=4 THEN ‘OK’ WHEN(2+2)&lt;&gt;4 THEN ‘not OK’ END ASSTATUS;<br>SELECT Name,IF((IsActive = 1),’已激活’,’未激活’) AS RESULT FROMUserLoginInfo;<br>SELECT fname,lname,(math+sci+lit) AS total,<br>CASE WHEN (math+sci+lit) &lt; 50 THEN ‘D’<br>WHEN (math+sci+lit) BETWEEN 50 AND 150 THEN ‘C’<br>WHEN (math+sci+lit) BETWEEN 151 AND 250 THEN ‘B’<br>ELSE ‘A’ END<br>AS grade FROM marks;<br>SELECT IF(ENCRYPT(‘sue’,’ts’)=upass,’allow’,’deny’) AS LoginResultFROM users WHERE uname = ‘sue’;#一个登陆验证</p>
<h4 id="七、格式化函数"><a href="#七、格式化函数" class="headerlink" title="七、格式化函数"></a>七、格式化函数</h4><p>DATE_FORMAT(date,fmt)  依照字符串fmt格式化日期date值<br>FORMAT(x,y)   把x格式化为以逗号隔开的数字序列，y是结果的小数位数<br>INET_ATON(ip)   返回IP地址的数字表示<br>INET_NTOA(num)   返回数字所代表的IP地址<br>TIME_FORMAT(time,fmt)  依照字符串fmt格式化时间time值<br>其中最简单的是FORMAT()函数，它可以把大的数值格式化为以逗号间隔的易读的序列。<br>示例：<br>SELECT FORMAT(34234.34323432,3);<br>SELECT DATE_FORMAT(NOW(),’%W,%D %M %Y %r’);<br>SELECT DATE_FORMAT(NOW(),’%Y-%m-%d’);<br>SELECT DATE_FORMAT(19990330,’%Y-%m-%d’);<br>SELECT DATE_FORMAT(NOW(),’%h:%i %p’);<br>SELECT INET_ATON(‘10.122.89.47’);<br>SELECT INET_NTOA(175790383);</p>
<h4 id="八、类型转化函数"><a href="#八、类型转化函数" class="headerlink" title="八、类型转化函数"></a>八、类型转化函数</h4><p>为了进行数据类型转化，MySQL提供了CAST()函数，它可以把一个值转化为指定的数据类型。类型有：BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED<br>示例：<br>SELECT CAST(NOW() AS SIGNED INTEGER),CURDATE()+0;<br>SELECT ‘f’=BINARY ‘F’,’f’=CAST(‘F’ AS BINARY);</p>
<h4 id="九、系统信息函数"><a href="#九、系统信息函数" class="headerlink" title="九、系统信息函数"></a>九、系统信息函数</h4><p>DATABASE()   返回当前数据库名<br>BENCHMARK(count,expr)  将表达式expr重复运行count次<br>CONNECTION_ID()   返回当前客户的连接ID<br>FOUND_ROWS()   返回最后一个SELECT查询进行检索的总行数<br>USER()或SYSTEM_USER()  返回当前登陆用户名<br>VERSION()   返回MySQL服务器的版本<br>示例：<br>SELECT DATABASE(),VERSION(),USER();<br>SELECTBENCHMARK(9999999,LOG(RAND()<em>PI()));#该例中,MySQL计算LOG(RAND()</em>PI())表达式9999999次。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>底层深入</tag>
      </tags>
  </entry>
  <entry>
    <title>Elastic-Stack相关</title>
    <url>/posts/878e527b/</url>
    <content><![CDATA[<h1 id="安装Elastic-Stack"><a href="#安装Elastic-Stack" class="headerlink" title="安装Elastic Stack"></a>安装Elastic Stack</h1><p>准备一台虚拟机，（最好3G内存以上，不然会很卡，很卡很卡）</p><ol>
<li>准备docker环境</li>
</ol><h6 id="安装docker环境"><a href="#安装docker环境" class="headerlink" title="安装docker环境"></a>安装docker环境</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装docker </span></span><br><span class="line">yum install -y docker</span><br></pre></td></tr></table></figure><h6 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 输入命令行 </span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">// 配置权限</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">// 查看版本</span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure><a id="more"></a>







<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-fb183f33f4842212.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1016/format/webp"></p>
<p>01.png</p>
<ol>
<li>配置运行时需要的变量</li>
</ol>
<h6 id="创建容器间交互的-桥接式网络-elk-demo-network"><a href="#创建容器间交互的-桥接式网络-elk-demo-network" class="headerlink" title="创建容器间交互的 桥接式网络 elk_demo_network"></a>创建容器间交互的 桥接式网络 elk_demo_network</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create elk_demo_network</span><br></pre></td></tr></table></figure>

<p>创建网络 异常 Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br> 使用sudo启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service docker restart</span><br></pre></td></tr></table></figure>

<p>查看网络创建情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">list</span></span><br></pre></td></tr></table></figure>



<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-7cf1bd97a12f22bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/958/format/webp"></p>
<p>02.png</p>
<h6 id="配置es需要的-变量-避免es异常"><a href="#配置es需要的-变量-避免es异常" class="headerlink" title="配置es需要的 变量 避免es异常"></a>配置es需要的 变量 避免es异常</h6><p>es 异常 exit code 78 解决方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w vm.max_map_count=524288</span><br></pre></td></tr></table></figure>

<p>es需要的内存很大 ，可以通过 修改环境变量 获取配置 虚拟机内存处理</p>
<ol>
<li>配置基本完成 配置docker-compose （PS：注意文件目录问题 此处文件放在 /root/elk_demo）</li>
</ol>
<p>创建docker-compose.yml<br> 进入到目录 /root/elk_demo</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vi</span> <span class="selector-tag">docker-compose</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">'2.2'</span></span><br><span class="line">services:</span><br><span class="line"><span class="comment"># nginx -- start</span></span><br><span class="line">  nginx01:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx01</span><br><span class="line">    privileged: <span class="literal">true</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"80:80"</span></span><br><span class="line">    environment:</span><br><span class="line">      - NGINX_HOST=foobar.com</span><br><span class="line">      - NGINX_PORT=80</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">    volumes:</span><br><span class="line"><span class="comment">#      - /root/elk_demo/nginx/mysite.template:/etc/nginx/conf.d/mysite.template </span></span><br><span class="line">      - /root/elk_demo/nginx/logs/:/var/<span class="built_in">log</span>/nginx/  </span><br><span class="line">      - /root/elk_demo/nginx/configs/:/etc/nginx/conf.d/   <span class="comment"># if would open this setting, you should put a 'default.conf' file in your configs dir. </span></span><br><span class="line"><span class="comment"># nginx -- end</span></span><br><span class="line"><span class="comment"># elasticsearch cluster -- start </span></span><br><span class="line">  es01:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.4.0</span><br><span class="line">    container_name: es01</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es01</span><br><span class="line">      - discovery.seed_hosts=es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02</span><br><span class="line">      - cluster.name=docker-cluster</span><br><span class="line">      - bootstrap.memory_lock=<span class="literal">true</span></span><br><span class="line">      - <span class="string">"ES_JAVA_OPTS=-Xms128m -Xmx128m"</span></span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - esdata01:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">  es02:</span><br><span class="line">    image: docker.elastic.co/elasticsearch/elasticsearch:7.4.0</span><br><span class="line">    container_name: es02</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es02</span><br><span class="line">      - discovery.seed_hosts=es01</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02</span><br><span class="line">      - cluster.name=docker-cluster</span><br><span class="line">      - bootstrap.memory_lock=<span class="literal">true</span></span><br><span class="line">      - <span class="string">"ES_JAVA_OPTS=-Xms128m -Xmx128m"</span></span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - esdata02:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line"><span class="comment"># elasticsearch cluster -- end</span></span><br><span class="line"><span class="comment"># kibana -- start</span></span><br><span class="line">  kibana01:</span><br><span class="line">    image: docker.elastic.co/kibana/kibana:7.4.0</span><br><span class="line">    container_name: kibana01</span><br><span class="line">    privileged: <span class="literal">true</span></span><br><span class="line">    ports:</span><br><span class="line">      - 5601:5601</span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#          - ELASTICSEARCH_HOSTS=http://es01:9200</span></span><br><span class="line"><span class="comment">#          - I18N_LOCALE=zh-CN</span></span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/elk_demo/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml</span><br><span class="line">    depends_on:</span><br><span class="line">      - es01</span><br><span class="line"><span class="comment"># kibana -- end</span></span><br><span class="line"><span class="comment"># filebeat -- start</span></span><br><span class="line">  filebeat01:</span><br><span class="line">    image: docker.elastic.co/beats/filebeat:7.4.0</span><br><span class="line">    container_name: filebeat01</span><br><span class="line">    privileged: <span class="literal">true</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#    #      - ES_HOST=es01</span></span><br><span class="line"><span class="comment">#    #      - ES_PORT=9200</span></span><br><span class="line"><span class="comment">#    #      - KIBANA_HOST=kibana</span></span><br><span class="line"><span class="comment">#    #      - KIBANA_PORT=5601</span></span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/elk_demo/filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class="line">      - /root/elk_demo/nginx/logs:/var/<span class="built_in">log</span>/</span><br><span class="line">      - /root/elk_demo/filebeat/modules.d/:/usr/share/filebeat/modules.d/</span><br><span class="line">    depends_on:</span><br><span class="line">      - es01</span><br><span class="line">      - kibana01</span><br><span class="line"><span class="comment"># filebeat -- end</span></span><br><span class="line"><span class="comment"># metricbeat -- start</span></span><br><span class="line">  metricbeat02:</span><br><span class="line">    image: docker.elastic.co/beats/metricbeat:7.4.0</span><br><span class="line">    container_name: metricbeat02</span><br><span class="line">    privileged: <span class="literal">true</span></span><br><span class="line"><span class="comment">#    environment:</span></span><br><span class="line"><span class="comment">#      - ES_HOST=es01</span></span><br><span class="line"><span class="comment">#      - ES_PORT=9200</span></span><br><span class="line"><span class="comment">#      - KIBANA_HOST=kibana</span></span><br><span class="line"><span class="comment">#      - KIBANA_PORT=5601</span></span><br><span class="line">    networks:</span><br><span class="line">      - esnet</span><br><span class="line">    volumes:</span><br><span class="line">      - /root/elk_demo/metricbeat/metricbeat.yml:/usr/share/metricbeat/metricbeat.yml</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock:ro</span><br><span class="line">      - /sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro</span><br><span class="line">      - /proc:/hostfs/proc:ro</span><br><span class="line">      - /:/hostfs:ro</span><br><span class="line">      - /root/elk_demo/metricbeat/modules.d/:/usr/share/metricbeat/modules.d/</span><br><span class="line">    depends_on:</span><br><span class="line">      - es01</span><br><span class="line">      - kibana01</span><br><span class="line"><span class="comment"># metricbeat -- end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  esdata01:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  esdata02:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  esnet:</span><br><span class="line">    external:</span><br><span class="line">      name: elk_demo_network</span><br></pre></td></tr></table></figure>

<p>创建docker-compose.yml 之后。开始处理相关的配置文件 。这边试验对象 是nginx 所以需要配置nginx 的相关配置</p>
<h6 id="nginx-相关配置"><a href="#nginx-相关配置" class="headerlink" title="nginx 相关配置"></a>nginx 相关配置</h6><p>根据 docker-compose.yml 可以看出 nginx 的配置环境变量的目录 在 /root/elk_demo/nginx/configs/。其实此处可以不配置 ，也可以使用，配置的目的是为了更好的操作配置文件，另一个就是为了 下面的 metribeat做实验铺垫</p>
<p>进入到 目录 /root/elk_demo/nginx/configs<br> 创建文件 metricbeat.conf</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vi</span> <span class="selector-tag">metricbeat</span><span class="selector-class">.conf</span></span><br></pre></td></tr></table></figure>



<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#charset koi8-r;</span></span><br><span class="line">    <span class="meta">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /nginx-status &#123;</span><br><span class="line">        stub_status <span class="keyword">on</span>;</span><br><span class="line">    access_log off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># redirect server <span class="meta-keyword">error</span> pages to the static page /50x.html</span></span><br><span class="line">    <span class="meta">#</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Kibana-相关配置"><a href="#Kibana-相关配置" class="headerlink" title="Kibana 相关配置"></a>Kibana 相关配置</h6><p>同上 在目录</p>
<p>vi /root/elk_demo/kibana/kibana.yml</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">i18n</span><span class="selector-class">.locale</span>: <span class="selector-tag">zh-CN</span> </span><br><span class="line"><span class="selector-tag">server</span><span class="selector-class">.name</span>: <span class="selector-tag">kibana</span></span><br><span class="line"><span class="selector-tag">server</span><span class="selector-class">.host</span>: "0"</span><br><span class="line"><span class="selector-tag">elasticsearch</span><span class="selector-class">.hosts</span>: <span class="selector-attr">[ "http://es01:9200" ]</span></span><br><span class="line"><span class="selector-tag">xpack</span><span class="selector-class">.monitoring</span><span class="selector-class">.ui</span><span class="selector-class">.container</span><span class="selector-class">.elasticsearch</span><span class="selector-class">.enabled</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>

<h6 id="filebeat-相关配置"><a href="#filebeat-相关配置" class="headerlink" title="filebeat 相关配置"></a>filebeat 相关配置</h6><p>vi /root/elk_demo/filebeat/filebeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    hosts: [<span class="string">"es01:9200"</span>] </span><br><span class="line"></span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">  reload.enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setup.template.settings:</span><br><span class="line">   index.number_of_shards: 3</span><br><span class="line"></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: <span class="string">"kibana01:5601"</span></span><br></pre></td></tr></table></figure>

<p>此外，为了配置 nginx 仪表盘 所以还需要配置 nginx的配置文件<br> 创建目录 /root/elk_demo/filebeat/modules.d</p>
<p>vi  /root/elk_demo/filebeat/modules.d/nginx.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">module</span>: nginx</span><br><span class="line">  access:</span><br><span class="line">    enabled: <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">var</span>.paths: [<span class="string">"/var/log/access.log*"</span>]</span><br><span class="line"></span><br><span class="line">  error:</span><br><span class="line">    enabled: <span class="keyword">true</span></span><br><span class="line">    <span class="keyword">var</span>.paths: [<span class="string">"/var/log/error.log*"</span>]</span><br></pre></td></tr></table></figure>

<h6 id="metricbeat-相关配置"><a href="#metricbeat-相关配置" class="headerlink" title="metricbeat 相关配置"></a>metricbeat 相关配置</h6><p>vi /root/elk_demo/metricbeat/metricbeat.yml</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">  <span class="comment"># Array of hosts to connect to.</span></span><br><span class="line">    hosts: [<span class="string">"es01:9200"</span>]</span><br><span class="line"></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: <span class="string">"kibana01:5601"</span></span><br><span class="line"></span><br><span class="line">metricbeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br></pre></td></tr></table></figure>

<p>同上 配置 Nginx 仪表盘</p>
<p>vi  /root/elk_demo/metricbeat/modules.d/nginx.yml</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Module: nginx</span></span><br><span class="line"><span class="meta"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/7.4/metricbeat-module-nginx.html</span></span><br><span class="line"></span><br><span class="line">- module: nginx</span><br><span class="line">  <span class="meta">#metricsets:</span></span><br><span class="line">  <span class="meta">#  - stubstatus</span></span><br><span class="line">  period: <span class="number">10</span>s</span><br><span class="line"></span><br><span class="line">  <span class="meta"># Nginx hosts</span></span><br><span class="line">  hosts: [<span class="string">"nginx01:80"</span>]</span><br><span class="line"></span><br><span class="line">  <span class="meta"># Path to server status. Default server-status</span></span><br><span class="line">  server_status_path: <span class="string">"nginx-status"</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#username: <span class="meta-string">"user"</span></span></span><br><span class="line">  <span class="meta">#password: <span class="meta-string">"secret"</span></span></span><br></pre></td></tr></table></figure>

<p>vi  /root/elk_demo/metricbeat/modules.d/system.yml</p>
<p>配置 system 仪表盘</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Module: system</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/7.4/metricbeat-module-system.html</span></span><br><span class="line"></span><br><span class="line">- <span class="class"><span class="keyword">module</span>: <span class="title">system</span></span></span><br><span class="line">  <span class="symbol">period:</span> <span class="number">10</span>s</span><br><span class="line">  <span class="symbol">metricsets:</span></span><br><span class="line">    - cpu</span><br><span class="line">    - load</span><br><span class="line">    - memory</span><br><span class="line">    - network</span><br><span class="line">    - process</span><br><span class="line">    - process_summary</span><br><span class="line">    - socket_summary</span><br><span class="line">    <span class="comment">#- entropy</span></span><br><span class="line">    <span class="comment">#- core</span></span><br><span class="line">    <span class="comment">#- diskio</span></span><br><span class="line">    <span class="comment">#- socket</span></span><br><span class="line">  process.<span class="symbol">include_top_n:</span></span><br><span class="line">    <span class="symbol">by_cpu:</span> <span class="number">5</span>      <span class="comment"># include top 5 processes by CPU</span></span><br><span class="line">    <span class="symbol">by_memory:</span> <span class="number">5</span>   <span class="comment"># include top 5 processes by memory</span></span><br><span class="line"></span><br><span class="line">- <span class="class"><span class="keyword">module</span>: <span class="title">system</span></span></span><br><span class="line">  <span class="symbol">period:</span> <span class="number">1</span>m</span><br><span class="line">  <span class="symbol">metricsets:</span></span><br><span class="line">    - filesystem</span><br><span class="line">    - fsstat</span><br><span class="line">  <span class="symbol">processors:</span></span><br><span class="line">  - drop_event.<span class="keyword">when</span>.<span class="symbol">regexp:</span></span><br><span class="line">      system.filesystem.<span class="symbol">mount_point:</span> <span class="string">'^/(sys|cgroup|proc|dev|etc|host|lib)($|/)'</span></span><br><span class="line"></span><br><span class="line">- <span class="class"><span class="keyword">module</span>: <span class="title">system</span></span></span><br><span class="line">  <span class="symbol">period:</span> <span class="number">15</span>m</span><br><span class="line">  <span class="symbol">metricsets:</span></span><br><span class="line">    - uptime</span><br><span class="line"></span><br><span class="line"><span class="comment">#- module: system</span></span><br><span class="line"><span class="comment">#  period: 5m</span></span><br><span class="line"><span class="comment">#  metricsets:</span></span><br><span class="line"><span class="comment">#    - raid</span></span><br><span class="line"><span class="comment">#  raid.mount_point: '/'</span></span><br></pre></td></tr></table></figure>

<h6 id="各项准备完成-开始最终步骤-启动"><a href="#各项准备完成-开始最终步骤-启动" class="headerlink" title="各项准备完成 开始最终步骤 启动"></a>各项准备完成 开始最终步骤 启动</h6><p>进入 /root/elk_demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//删除kibana索引</span><br><span class="line">curl -XDELETE http://localhost:9200/.kibana*</span><br><span class="line">//运行</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>



<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-cae0d20a3f36dcc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/736/format/webp"></p>
<p>03.png</p>
<hr>
<p>测试</p>
<p>访问：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguNjIuMTQ0Lw==" title="http://192.168.62.144/">http://192.168.62.144/<i class="fa fa-external-link"></i></span> 验证nginx<br> 访问：<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwJTNBJTJGJTJGMTkyLjE2OC42Mi4xNDQlMkZuZ2lueC1zdGF0dXM=" title="https://links.jianshu.com/go?to=http%3A%2F%2F192.168.62.144%2Fnginx-status">http://192.168.62.144/nginx-status<i class="fa fa-external-link"></i></span> 验证nginx 心跳<br> 访问：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguNjIuMTQ0OjU2MDE=" title="http://192.168.62.144:5601">http://192.168.62.144:5601<i class="fa fa-external-link"></i></span> 验证kibana</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-31dd538b79de5ff0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p>
<p>05.png</p>
<h6 id="安装Nginx-仪表盘"><a href="#安装Nginx-仪表盘" class="headerlink" title="安装Nginx 仪表盘"></a>安装Nginx 仪表盘</h6><p>确认之前的 beats 配置是否生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看容器信息</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模块配置信息</span></span><br><span class="line">docker <span class="built_in">exec</span> 容器ID ./filebeat modules list</span><br><span class="line">docker <span class="built_in">exec</span> 容器ID ./metricbeat modules list</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装仪表盘</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> 容器ID ./filebeat setup --dashboards</span><br><span class="line">docker <span class="built_in">exec</span> 容器ID ./metricbeat setup --dashboards</span><br></pre></td></tr></table></figure>



<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-c5661d4469e8778d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/775/format/webp"></p>
<p>配置仪表盘</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-284ac77da8c13a51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p>
<p>01</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-b9c70493991730d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p>
<p>08.png</p>
<p><img alt="img" data-src="https:////upload-images.jianshu.io/upload_images/14387783-eadf581f70b2612c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></p>
<p>10.png</p>
<p>以上就完成了使用 Beats+ES+Kibana 完成 Nginx 运行监控</p>
<h1 id="kibana简单使用"><a href="#kibana简单使用" class="headerlink" title="kibana简单使用"></a>kibana简单使用</h1>]]></content>
      <tags>
        <tag>主流框架</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ的入门</title>
    <url>/posts/3b8ce786/</url>
    <content><![CDATA[<h2 id="一，RabbitMQ的介绍与安装"><a href="#一，RabbitMQ的介绍与安装" class="headerlink" title="一，RabbitMQ的介绍与安装"></a>一，RabbitMQ的介绍与安装</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>​            RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议 来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布 /订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据_致 性、稳定性和可靠性要求很髙的场景，对性能和吞吐量的要求还在其次。</p><a id="more"></a>
<p><strong>与其他mq的比较</strong></p>
<pre><code>activiMq老牌消息中间件，api全面，但是吞吐量不大

Kafaka吞吐量大，但是数据无法保证不丢失，主要面向大数据

rokectMQ：吞吐量大，保证数据不丢失，并且支持分布式事物，但是商业版需要收费

rabbitMQ：吞吐量大，数据不易丢失</code></pre><p><strong>初识RabbitMQ:</strong></p>
<blockquote>
<p>RabbitMQ是—个开源的消息代理和队列服务器，用来通过普通协议 在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写 的，并且RabbitMQ是基于AMQP协议的。</p>
</blockquote>
<p><strong>哪些大厂在用RabbitMQ,为什幺？</strong></p>
<blockquote>
<p>滴滴、美团、头条、去哪儿、艺龙……</p>
<p>开源、性能优秀，稳定性保障</p>
<p>提供可靠性消息投递模式（confirm)、返回模式（return )</p>
<p>与SpringAMQP完美的整合、API丰富</p>
<p>集群模式丰富，表达式配置，HA模式，镜像队列模型</p>
<p>保证数据不丟失的前提做到高可靠性、可用性</p>
</blockquote>
<p><strong>RabbitMQ高性能的原因？</strong></p>
<blockquote>
<p><strong>Erlang语言</strong>最初在于交换机领域的架构模式，这样使得 RabbitMQ在Broker之间进行数据交互的性能是非常优秀的</p>
<p>Erlang的优点：<strong>Erlang有着和原生Socket—样的延迟</strong></p>
</blockquote>
<p><strong>什么是AMQP高级消息队列协议？</strong></p>
<p>　　<strong>AMQP定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">是具有现代特征的二进制协议；</span><br><span class="line">是一个提供统一消息服务的应用层标准高级消息队列协议；</span><br><span class="line">是应用层协议的一个开放标准，为面向消息的中间件设计；</span><br></pre></td></tr></table></figure>





<h4 id="RabbitMQ的安装与使用"><a href="#RabbitMQ的安装与使用" class="headerlink" title="RabbitMQ的安装与使用"></a>RabbitMQ的安装与使用</h4><p>因为RabbitMQ是基于Erlang的所以对他的安装要先安装Erlang，然后在进行RabbitMQ的安装 但是要<strong>注意RabbitMQ的版本一定要与Erlang的版本对应 否则将会出现错误！</strong></p>
<table>
<thead>
<tr>
<th>RabbitMQ版本</th>
<th>Erlang最低要求</th>
<th>Erlang最高要求</th>
</tr>
</thead>
<tbody><tr>
<td>3.7.7 - 3.7.12</td>
<td>20.3.x</td>
<td>21.x</td>
</tr>
<tr>
<td>3.7.0 - 3.7.6</td>
<td>19.3</td>
<td>20.3.x</td>
</tr>
</tbody></table>
<p><strong>下载Erlang</strong></p>
<p>​    <span class="exturl" data-url="aHR0cDovL3d3dy5lcmxhbmcub3JnL2Rvd25sb2Fkcw==" title="http://www.erlang.org/downloads">官网下载地址<i class="fa fa-external-link"></i></span>但是个人不推荐官网下载，因为Erlang官网在国外的原因下载会特别的慢</p>
<p><img alt="1588922880637" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588922880637.png"></p>
<p><strong>下载RabbitMQ</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhYmJpdG1xL3JhYmJpdG1xLXNlcnZlci90YWdz" title="https://github.com/rabbitmq/rabbitmq-server/tags">官方git地址<i class="fa fa-external-link"></i></span>直接下载即可</p>
<p><img alt="1588923074328" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588923074328.png"></p>
<p><strong>两个软件安装的话一直下一步即可</strong></p>
<p>安装完成之后需要配置Erlang的环境变量</p>
<p><img alt="1588923359657" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588923359657.png"></p>
<p>配好环境变量以后找到RabbitMQ安装路径</p>
<p><img alt="1588923496376" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588923496376.png"></p>
<p>也可以在菜单处打开</p>
<p><img alt="1588923467960" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588923467960.png"></p>
<p>以管理员身份运行RabbitMQ Command Prompt (sbin dir) <strong>一定要以管理员身份运行</strong></p>
<p>在打开的黑窗口中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p> 命令</p>
<p><img alt="1588923647762" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588923647762.png"></p>
<p>加载完毕后启动服务即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动服务</span><br><span class="line">net start RabbitMQ</span><br><span class="line">#停止服务</span><br><span class="line">net stop RabbitMQ</span><br></pre></td></tr></table></figure>



<p>然后访问浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:15672</span><br></pre></td></tr></table></figure>

<p>出现如下页面</p>
<p><img alt="1588924048369" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588924048369.png"></p>
<p>默认账号密码是     guest</p>
<p>登录进去 添加一个admin账户还有对应一个测试用的虚拟主机</p>
<p>添加用户</p>
<p><img alt="1588926208949" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588926208949.png"></p>
<p>添加虚拟主机</p>
<p><img alt="1588926263239" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588926263239.png"></p>
<p>为账户绑定虚拟机</p>
<p><img alt="1588926370839" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588926370839.png"></p>
<p><img alt="1588926419418" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588926419418.png"></p>
<p><img alt="1588926614652" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588926614652.png"></p>
<p><strong>RabbitMQ默认端口</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4369 -- erlang发现口</span><br><span class="line">5672 --client端通信口</span><br><span class="line">15672 -- 管理界面ui端口</span><br><span class="line">25672 -- server间内部通信口</span><br></pre></td></tr></table></figure>





<h2 id="二，RabbitMQ入门案例"><a href="#二，RabbitMQ入门案例" class="headerlink" title="二，RabbitMQ入门案例"></a>二，RabbitMQ入门案例</h2><p>1，新建项目导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2，工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"q_test_01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"dsztest"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"admin"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"admin"</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3,  新建消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.QueueingConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(ConnectionUtil.QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听队列</span></span><br><span class="line">        channel.basicConsume(ConnectionUtil.QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">            String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">            System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4,  新建服务提供者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列</span></span><br><span class="line">        channel.queueDeclare(ConnectionUtil.QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"你能随时收到么？"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, ConnectionUtil.QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5，测试：</p>
<p><img alt="1588924589956" data-src="D:%5Chexo%5Csource_posts%5CRabbitMQ%E7%9A%84%E5%85%A5%E9%97%A8%5C1588924589956.png"></p>
<p>接收成功！</p>
<p>6，总结</p>
<p>​        服务消费者一共分为7个步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 获取到连接以及mq通道</span><br><span class="line">2. 从连接中创建通道</span><br><span class="line">3. 声明队列</span><br><span class="line">4. 定义队列的消费者</span><br><span class="line">5. 监听队列</span><br><span class="line">6. 获取消息</span><br><span class="line">7. 关闭通道和连接(本案例中没有定义)</span><br></pre></td></tr></table></figure>

<p>​        服务提供者一共分为5个步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 获取到连接以及mq通道</span><br><span class="line">2. 从连接中创建通道</span><br><span class="line">3. 声明队列</span><br><span class="line">4. 发送消息内容</span><br><span class="line">5. 关闭通道和连接</span><br></pre></td></tr></table></figure>

<p>可以看到在代码中服务提供者与服务消费者前3个步骤都是一样的，是对服务器进行连接然后再进行对应的逻辑处理最后再进行关闭，代码结构简单，但是有的时候可能在运行业务代码的时候突然出现异常 服务中止 但是消息中间件以及标记为正确并返回了 这样数据的原子性就会遭到破坏，要避免这种情况怎么办呢？ 切换自动确认为手动确认即可</p>
<p>手动确认消息设置：</p>
<ul>
<li><pre><code>channel.basicConsume(QUEUE_NAME, true, consumer);
1
 修改消费者

 /**

 - 消费者,手动进行ACK
   */
   public class Recv2 {
   private final static String QUEUE_NAME = &quot;simple_queue&quot;;

   public static void main(String[] argv) throws Exception {
       // 获取到连接
       Connection connection = ConnectionUtil.getConnection();
       // 创建通道
       final Channel channel = connection.createChannel();
       // 声明队列
       channel.queueDeclare(QUEUE_NAME, false, false, false, null);
       // 定义队列的消费者
       DefaultConsumer consumer = new DefaultConsumer(channel) {
       // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
           @Override
           public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException {
               // body 即消息体
               //int i = 1/0;
               String msg = new String(body);
               System.out.println(&quot;received : &quot; + msg + &quot;!&quot;);

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
       // 手动进行ACK
       channel.basicAck(envelope.getDeliveryTag(), false);
   }
};
// 监听队列，第二个参数false，手动进行ACK
channel.basicConsume(QUEUE_NAME, false, consumer);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>启动生产者，debug启动消费者</p>
<p>可以看到在确认之后消息被消费掉<br>同样制造异常：int i = 1/0;，启动生产者，消费者，可以看到消息并没有被消息掉</p>
<p>二、工作模型</p>
<p>在一个生产者，多个消费者的情况下，消费者根据处理任务的性能，合理分配消息的处理，让线程睡眠一秒模拟性能差的消费者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Recv &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_work_queue&quot;;</span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    // 获取到连接</span><br><span class="line">    Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">    // 获取通道</span><br><span class="line">    final Channel channel = connection.createChannel();</span><br><span class="line">    // 声明队列</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">    // 设置每个消费者同时只能处理一条消息，即处理完一条消息任务之后，在消费另一条消息，执行另一个任务，而不是消息所有消息</span><br><span class="line">    channel.basicQos(1);</span><br><span class="line">    // 定义队列的消费者</span><br><span class="line">    DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,</span><br><span class="line">                byte[] body) throws IOException &#123;</span><br><span class="line">            // body 即消息体</span><br><span class="line">            String msg = new String(body);</span><br><span class="line">            System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 模拟完成任务的耗时：1000ms</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            // 手动ACK</span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 监听队列。</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Recv2 &#123;</span><br><span class="line">    private final static String QUEUE_NAME = &quot;test_work_queue&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">    // 获取到连接</span><br><span class="line">    Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">    // 获取通道</span><br><span class="line">    final Channel channel = connection.createChannel();</span><br><span class="line">    // 声明队列</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class="line">    // 设置每个消费者同时只能处理一条消息，即处理完一条消息任务之后，在消费另一条消息，执行另一个任务，而不是消息所有消息</span><br><span class="line">    channel.basicQos(1);</span><br><span class="line">    // 定义队列的消费者</span><br><span class="line">    DefaultConsumer consumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,</span><br><span class="line">                byte[] body) throws IOException &#123;</span><br><span class="line">            // body 即消息体</span><br><span class="line">            String msg = new String(body);</span><br><span class="line">            System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);</span><br><span class="line">            // 手动ACK</span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 监听队列。</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, consumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者循环生产50条消息，两个消费者消费消息情况如下</p>
<p>三、 消息发布订阅-Fanout</p>
<p>生产者</p>
<p>public class Send {<br>    private final static String EXCHANGE_NAME = “fanout_exchange_test”;</p>
<pre><code>public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明交换机exchange，指定类型为fanout
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);
    // 消息内容
    String message = &quot;Hello everyone&quot;;
    // 发布消息到Exchange
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
    System.out.println(&quot; [生产者] Sent &apos;&quot; + message + &quot;&apos;&quot;);
    channel.close();
    connection.close();
}
}

消费者一

public class Recv {
    private final static String QUEUE_NAME = &quot;fanout_exchange_queue_1&quot;;
    private final static String EXCHANGE_NAME = &quot;fanout_exchange_test&quot;;


public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
    // 定义队列的消费者
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                byte[] body) throws IOException {
            // body 即消息体
            String msg = new String(body);
            System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
        }
    };
    // 监听队列，自动返回完成
    channel.basicConsume(QUEUE_NAME, true, consumer);
}</code></pre><p>}</p>
<p>消费者二</p>
<pre><code>public class Recv2 {
    private final static String QUEUE_NAME = &quot;fanout_exchange_queue_2&quot;;
    private final static String EXCHANGE_NAME = &quot;fanout_exchange_test&quot;;
public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);
    // 绑定队列到交换机
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
    // 定义队列的消费者
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                byte[] body) throws IOException {
            // body 即消息体
            String msg = new String(body);
            System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
        }
    };
    // 监听队列，手动返回完成
    channel.basicConsume(QUEUE_NAME, true, consumer);
}</code></pre><p>}</p>
<p>由于这消费者方是直接将队列绑定到交换机，并没有声明交换机，所以先启动生产者，此时消息将丢失，启动消费者后再启动生产者<br>第一次启动生产者：</p>
<p>启动两个消费者</p>
<p>再次启动生产者</p>
<p>四、发布订阅-direct</p>
<p>在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）。消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。<br>定义两个消费者，指定routing key为不同的类型</p>
<pre><code>public class Recv {
    private final static String QUEUE_NAME = &quot;direct_exchange_queue_1&quot;;
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;
public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);

    // 定义队列的消费者
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                byte[] body) throws IOException {
            // body 即消息体
            String msg = new String(body);
            System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
        }
    };
    // 监听队列，自动ACK
    channel.basicConsume(QUEUE_NAME, true, consumer);
}


}

public class Recv2 {
    private final static String QUEUE_NAME = &quot;direct_exchange_queue_2&quot;;
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;
public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明队列
    channel.queueDeclare(QUEUE_NAME, false, false, false, null);

    // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);

    // 定义队列的消费者
    DefaultConsumer consumer = new DefaultConsumer(channel) {
        // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
        @Override
        public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
                byte[] body) throws IOException {
            // body 即消息体
            String msg = new String(body);
            System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
        }
    };
    // 监听队列，自动ACK
    channel.basicConsume(QUEUE_NAME, true, consumer);
}</code></pre><p>}</p>
<p>消息生产者，先生产一条routing key为update的消息</p>
<pre><code>public class Send {
    private final static String EXCHANGE_NAME = &quot;direct_exchange_test&quot;;
public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();
    // 获取通道
    Channel channel = connection.createChannel();
    // 声明exchange，指定类型为direct
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);
    // 消息内容
    String message = &quot;商品修改， id = 1001&quot;;
    // 发送消息，并且指定routing key 为：insert ,代表新增商品
    channel.basicPublish(EXCHANGE_NAME, &quot;update&quot;, null, message.getBytes());
    System.out.println(&quot; [商品服务：] Sent &apos;&quot; + message + &quot;&apos;&quot;);
    channel.close();
    connection.close();
}</code></pre><p>}</p>
<p>再次发送一条routing key为insert的消息，由于消费者一并没有订阅routing key为insert的消息，所以将不会有打印输出</p>
<p>五、发布订阅-topic<br>Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符<br>通配符规则：<br>#：匹配一个或多个词<br><em>：只能匹配一个词<br>例如：<br>abc.#：能够匹配abc.de.fg 或者 abc.defg<br>abc.</em>：只能匹配abc.de</p>
<p>使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete：</p>
<p>public class Send {<br>    private final static String EXCHANGE_NAME = “topic_exchange_test”;</p>
<pre><code>public static void main(String[] argv) throws Exception {
    // 获取到连接
    Connection connection = ConnectionUtil.getConnection();

    // 获取通道
    Channel channel = connection.createChannel();

    // 声明exchange，指定类型为topic, 交换机持久化
    channel.exchangeDeclare(EXCHANGE_NAME, &quot;topic&quot;,true);

    // 消息内容
    String message = &quot;新增商品 : id = 1001&quot;;

    // 1、发送消息到交换机 2、指定routing key为:insert,代表新增商品 3、消息持久化 4、消息体
    channel.basicPublish(EXCHANGE_NAME, &quot;item.insert&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());
    System.out.println(&quot; [商品服务：] Sent &apos;&quot; + message + &quot;&apos;&quot;);

    channel.close();
    connection.close();
}</code></pre><ul>
<li><p>消费者1</p>
</li>
<li><p>/<br>public class Recv {<br>  private final static String QUEUE_NAME = “topic_exchange_queue_1”;<br>  private final static String EXCHANGE_NAME = “topic_exchange_test”;</p>
<p>  public static void main(String[] argv) throws Exception {</p>
<pre><code>// 获取到连接
Connection connection = ConnectionUtil.getConnection();
// 获取通道
Channel channel = connection.createChannel();
// 声明队列, 声明队列持久化
channel.queueDeclare(QUEUE_NAME, true, false, false, null);

// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete
channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.update&quot;);
channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.delete&quot;);

// 定义队列的消费者
DefaultConsumer consumer = new DefaultConsumer(channel) {
    // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
            byte[] body) throws IOException {
        // body 即消息体
        String msg = new String(body);
        System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);
    }
};
// 监听队列，自动ACK
channel.basicConsume(QUEUE_NAME, true, consumer);</code></pre><p>  }<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>消费者2</li>
<li>/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public class Recv2 &#123;</span><br><span class="line">private final static String QUEUE_NAME = &quot;topic_exchange_queue_2&quot;;</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;topic_exchange_test&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] argv) throws Exception &#123;</span><br><span class="line">        // 获取到连接</span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        // 获取通道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        // 声明队列，指定队列持久化</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, true, false, false, null);</span><br></pre></td></tr></table></figure>
<pre><code>// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete
channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.*&quot;);

// 定义队列的消费者
DefaultConsumer consumer = new DefaultConsumer(channel) {
    // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用
    @Override
    public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties,
            byte[] body) throws IOException {
        // body 即消息体
        String msg = new String(body);
        System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);
    }</code></pre><p>};<br>// 监听队列，自动ACK<br>channel.basicConsume(QUEUE_NAME, true, consumer);<br>​```</p>
<p>}<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">此时，消费者2能够接受的routing key是item.*，他能接受以item开头的消息，消费者1没使用通配符，只能接受指定的类型消息，所以消费者1不能接受到routing key是item.insert*的消息</span><br><span class="line"></span><br><span class="line">六、消息的持久化</span><br><span class="line">队列、Exchange、消息都持久化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三，Spring AMQP简单入门</span><br></pre></td></tr></table></figure>
<p>yml.xml</p>
<p>spring:<br>  rabbitmq:<br>    host: 192.168.248.131<br>    username: admin<br>    password: admin<br>    virtual-host: </p>
<pre><code>//启动类</code></pre><p>@SpringBootApplication<br>public class Application {<br>    public static void main(String[] args) {<br>        SpringApplication.run(Application.class, args);<br>    }<br>}</p>
<p>消费者</p>
<p>/**</p>
<ul>
<li>作为消费者<br>*/<br>@Component<br>public class Listener {<br>// 用注解声明这是一个监听者的注解<br>@RabbitListener(bindings = @QueueBinding(<pre><code>// 绑定队列，声明队列持久化
value = @Queue(value = &quot;spring.test.queue&quot;, durable = &quot;true&quot;),
// 绑定交换机
exchange = @Exchange(
        value = &quot;spring.test.exchange&quot;,// 交换机的名字
        ignoreDeclarationExceptions = &quot;true&quot;,// 忽略声明异常，使用已有的交换机
        type = ExchangeTypes.TOPIC // 交换机的类型
),
// 指定RoutingKey
key = {&quot;#.#&quot;}))</code></pre>public void listen(String msg){<pre><code>System.out.println(&quot;接收到消息：&quot; + msg);</code></pre>}<br>}<br>生产者</li>
</ul>
<p>@RunWith(SpringRunner.class)<br>@SpringBootTest(classes = Application.class)<br>public class MqDemo {</p>
<p>// 通过模板amqpTemplate对象的convertAndSend()方法发送消息<br>@Autowired<br>private AmqpTemplate amqpTemplate;</p>
<p>@Test<br>public void testSend() throws InterruptedException {<br>    String msg = “hello, Spring boot amqp”;<br>    // 指定发送到那个交换机，指定routingKey为a.b<br>    this.amqpTemplate.convertAndSend(“spring.test.exchange”,”a.b”, msg);<br>    // 等待10秒后再结束<br>    Thread.sleep(10000);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动测试类，在启动测试类的时候，就是初始化spring容器，消费者就会被加载，能够接受消息</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>redis学习与提升</title>
    <url>/posts/42bd15f0/</url>
    <content><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="五种常用的基本数据类型"><a href="#五种常用的基本数据类型" class="headerlink" title="五种常用的基本数据类型"></a>五种常用的基本数据类型</h3><p>​        <strong>string</strong>:字符串类型  –》string   基本数据</p><p>​        <strong>hash</strong>:对应hash表类型  –》hashmap  对象</p><p>​        <strong>list</strong>:对应有序列表类型 –》 linkedlist  列表</p><p>​        <strong>set</strong>:对应不可重复类型–》hashset 去重 </p><a id="more"></a>



<p>​        <strong>sorted_set</strong>:排序列表   –》treemap 排序</p>
<h3 id="string类型的基本操作"><a href="#string类型的基本操作" class="headerlink" title="string类型的基本操作"></a>string类型的基本操作</h3><p>​        get key //根据key获取value</p>
<p>​        set key value  //写入一对数据</p>
<p>​        del key //删除但前key对应数据</p>
<p>​        mset key1 value1 key2 value2 //批量添加数据</p>
<p>​        mget key1 key2 //获取多个数据</p>
<p>​        strlen key //获取value长度</p>
<p>​        append key value //追加信息如果该key存在就追加不存在就新建</p>
<p>​        incr key //对该key的value进行+1</p>
<p>​        incrby key increment //对该key 的value进行增加指定的值</p>
<p>​        incrbyfloat key increment //对该key 的value进行增加指定的小数值</p>
<p>​        decr key  //对该key的value进行-1</p>
<p>​        decrby key increment //对该key 的value进行减少指定的值</p>
<p>​        setex key seconds value //设置生命周期存活周期 时间单位为秒</p>
<p>​        psetex key milliseconds value //设置生命周期存活周期 时间单位为毫秒</p>
<h3 id="hash类型的基本操作"><a href="#hash类型的基本操作" class="headerlink" title="hash类型的基本操作"></a>hash类型的基本操作</h3><p>​        hget key  field //根据key获取value</p>
<p>​        hset key field  value  //写入一对数据</p>
<p>​        hdel key  field  //删除但前key对应数据</p>
<p>​        hgetall key //获取但前key下所有数据</p>
<p>​        hmset key1 field1 value1 field2 value2 //批量添加数据</p>
<p>​        hmget key1 field1 field2 //获取多个数据</p>
<p>​        hlen key //获取哈希表中字段的数量</p>
<p>​        hexists key  field //获取哈希表中是否存在该字段</p>
<p>​        hkeys key //获取当前哈希表中所有字段名</p>
<p>​        hvalue key //获取当前哈希表中所有字段值</p>
<p>​        hincrby key field increment //设置指定字段增加范围内的值</p>
<p>​        hincrbyfloat key field increment //增加指定范围内的小数值</p>
<p>​        hsetnx key field value //判断是否存在 存在则放弃 不存在则添加</p>
<h3 id="list类型的基本操作"><a href="#list类型的基本操作" class="headerlink" title="list类型的基本操作"></a>list类型的基本操作</h3><p>​        lpush key value1 value2 //从左边添加数据</p>
<p>​        rpush key value1 value2 //从右边添加数据</p>
<p>​        lrange key start stop //获取数据从第几位获取到第几位</p>
<p>​        lindex key index //获取但前索引位数据</p>
<p>​        llen key //获取当前list的长度</p>
<p>​        lpop key // 从左边移除数据</p>
<p>​        rpop key // 从右边移除数据</p>
<p>​        blpop key1 key2 timeout //从左边获取当前key1值 如果获取不到会等待timeout秒</p>
<p>​        brpop key1 key2 timeout //从右边获取当前key1值 如果获取不到会等待timeout秒</p>
<p>​        lrem key count value  //移除指定数据  count 移除多少个</p>
<h3 id="set类型的基本操作"><a href="#set类型的基本操作" class="headerlink" title="set类型的基本操作"></a>set类型的基本操作</h3><p>​        sadd key member1 member2//增加数据</p>
<p>​        smembers key //查看当前key 下所有数据</p>
<p>​        srem key member1 member2 //删除数据</p>
<p>​        scard key //获取集合大小</p>
<p>​        sismember key member //判断set中是否存在指定数据</p>
<p>​        srandmember key count //随机获取指定个数数据</p>
<p>​        spop key //随机获取集合中的某个数据然后进行移除</p>
<p>​        sinter key1 key2 //获取两个集合的交集  也就是重复那部分数据</p>
<p>​        sunion key1 key2 //获取俩个集合的并集 也就是类似于连个集合去重</p>
<p>​        sdiff key1 key2 //获取key1 对key2的差值 也就是key1中有key2 中没有</p>
<p>​        sinterstore destination key1 key2 //获取交集并赋值到某个集合</p>
<p>​        sunionstore destination key1 key2 //获取并集并赋值到某个集合</p>
<p>​        sdiffstore destination key1 key2 //获取差集并赋值到某个集合</p>
<p>​        smove source destination member //将数据从source 移动到member 中</p>
<h3 id="sorted-set类型的基本操作"><a href="#sorted-set类型的基本操作" class="headerlink" title="sorted_set类型的基本操作"></a>sorted_set类型的基本操作</h3><p>​        zadd key score1 member1 // 增加数据 score 需要排序的行</p>
<p>​        zrange key start stop withscores //获取一段数据 加with scores 则显示member1</p>
<p>​        zrevrange key start stop withscores //获取一段数据反转并反转展示</p>
<p>​        zrem key member member //删除数据 根据key 与member</p>
<p>​        zrangebyscore key min max withscores limit  //获取数据 数据大小在min 和max之间</p>
<p>​        zrevrangebyscore key max min //获取数据并反转</p>
<p>​        zremrangebyrank key start stop //删除数据 从多少位到多少位</p>
<p>​        zremrangebyscore key min max //删除数据数据大小为 min 到max</p>
<p>​        zcard key  //获取数据总量</p>
<p>​        zcount key min max //获取数据总量按数据大小</p>
<p>​        zinterstore destination numkeys key key //获取交集并赋值给destination </p>
<p>​        zunionstore destination   numkeys  key key  //获取数据并集并赋值给destination   </p>
<p>​    </p>
<h3 id="通用操作指令"><a href="#通用操作指令" class="headerlink" title="通用操作指令"></a>通用操作指令</h3><p>expire key secods //为key设置有效期 秒值</p>
<p>pexpire key milliseconds //为key设置有效期 毫秒值</p>
<p>ttl key //获取key的有效时间</p>
<p>type key // 获取key 的类型</p>
<p>persist key //转换key为永久存活</p>
<p>keys pattern//搜索存在的key * 代表所有 ？代表单个字符</p>
<p>rename key newkey //改名</p>
<p>renamenx key newkey//不存在则改名</p>
<p> sort //对集合数据进行排序 但是不动元数据</p>
<h3 id="数据库通用指令"><a href="#数据库通用指令" class="headerlink" title="数据库通用指令"></a>数据库通用指令</h3><p>redis 为了避免数据重复一共把数据库分为了16个</p>
<p>select index //切换数据库  索引为0-15</p>
<p>move key db //移动数据到其他数据库</p>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>概念：持久化顾名思义就是把数据从内存中永久保存到硬盘中，然后每一次使用再从硬盘中读取到内存中。</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>使用RDB持久化语句</p>
<p>​         <strong>save</strong> </p>
<p>每执行一次就会保存一次快照信息</p>
<p>因为redis 是单线程的执行任务是一条条执行的，使用save</p>
<p>的时候可以会因为数据量过大而造成线程阻塞，所以线上环境不建议使用</p>
<p>所以这时候就要使用</p>
<p>​        <strong>bgsave</strong> </p>
<p>后台保存指令 他还调用fork函数生成一个子进程去生成快照文件</p>
<p>在配置文件中配置自动保存 </p>
<p><strong>save 多少秒时间 多少个发生变化</strong> </p>
<p>也就是说在一段时间内 如果有设定多少个线程发生了变化则会自动保存</p>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>aof存储与rdb的不同之处在于rdb记录数据快照，而AOF记录操作的步骤</p>
<p>需要数据恢复时只需要执行一遍指令即可恢复</p>
<p>always（每次存储一次）</p>
<p>​    数据没有误差，但是性能差</p>
<p>everysec(每秒存储)</p>
<p>​    每隔一秒对缓冲区的指令进行保存一次</p>
<p>no(系统控制)</p>
<p>​    又操作系统控制  不可控</p>
<p><strong>配置</strong></p>
<p>appendonly   yes|no  //是否开启</p>
<p>appendfsync  always|everysec|no  //持久化策略</p>
<p><strong>AOF重写</strong> </p>
<p>在很多时候AOF保存的操作中可能会有重复内容出现 从而对数据量大的情况下不太好维护</p>
<p>所以可以使用AOF重写的方式去优化语句 使得语句更加简便 AOF文件也会更加小巧</p>
<p>bgrewriteaof  //手动重写</p>
<p>auto-aof-rewrite-min-size size  //自动重写</p>
<p>auto-aof-rewrite-percentage  percentage  //自动重写</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>multi  //事务开始  </p>
<p>exec //事务结束</p>
<p>discard //取消事务</p>
<p>作用： 在执行了multi后执行语句就不再执行 而是往一个队列里面添加 在使用了exec后才一同执行</p>
<p>事务锁 ：</p>
<p>​    为了保护数据在并发操作上不会出错，</p>
<p>​        watch //监控数据 必须定义在开启事务之前</p>
<p>​        unwatch //取消监控数据</p>
<p>​    如果监控的数据发生变化 则立即取消事务  </p>
<p>分布式锁：</p>
<p>​    setnx lock-key value</p>
<p>​    如果有线程在使用时其他线程不能使用</p>
<p>​    操作完成后可以通过del来释放锁 可以使用定时数据有效时间来摧毁锁</p>
<h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p><strong>定时删除</strong></p>
<p>​    设置一个定时器 监控expire中的元素如果有元素到达过期时间就会立马删除掉</p>
<p>​    优点节约服务器内存 缺点因为会占用队列 所以会影响cpu性能 </p>
<p><strong>惰性删除</strong></p>
<p>就是在一个元素达到过期时间时如果但是服务器压力过高那么服务器则不会去立马删除</p>
<p>等到下次去获取这个元素时再对数据进行删除 </p>
<p>优点节约cpu性能 缺点会多占用内存空间</p>
<p><strong>定期删除</strong></p>
<p>每隔一段时间对内存中的数据进行一次随机抽查 如果抽查到25%的数据都已过期则再重新抽查一遍</p>
<p>把抽查到的过期数据进行删除</p>
<p>是一个比较居中的方案 不是很吃cpu也不是很吃内存</p>
]]></content>
  </entry>
  <entry>
    <title>HashMap底层学习</title>
    <url>/posts/a2777b58/</url>
    <content><![CDATA[<h3 id="一-什么是哈希表"><a href="#一-什么是哈希表" class="headerlink" title="一. 什么是哈希表"></a>一. 什么是哈希表</h3><p><strong><em>其他数据结构</em></strong></p><p><strong>数组：</strong></p><p>​        采用一段连续的存储单元来存储数据。对于指定下标的查找，比较简单，通过给定一个数据进行查找需要遍历数组进行对比，比较麻烦，对于一般的删除插入操作，涉及到了数组元素的移动，也比较麻烦。</p><p><strong>线性链表：</strong></p><p>​        链表的新增修改删除，只需处理结点间的引用即可，比较简单，但是查询需要遍历整个链表进行逐一比较查询，比较麻烦</p><a id="more"></a>




<p><strong>二叉树</strong>：<br>        对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为二次方倍数。</p>
<blockquote>
<p><strong>哈希表：</strong></p>
</blockquote>
<p>​        相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，就是无论多少数据哈希表也只需要一次计算便可得到元素位置。</p>
<p>​        哈希表的底层结构是数组，正是利用了数组根据下标查找某个元素，一次定位就可以达到这种特性，哈希表将要存储的关键字计算出哈希值然后再让哈希值对应着数组某个位置进行插入。</p>
<p><img alt="img" data-src="https://img-blog.csdnimg.cn/20200227144714446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BfRG9yYWVtb24=,size_16,color_FFFFFF,t_70"></p>
<p><strong>哈希冲突</strong></p>
<p>​        两个不同的元素有可能会计算出同样的哈希值，指向同一地址的，这种情况被称为哈希冲突，那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式。</p>
<h3 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h3><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。</span></span><br><span class="line"><span class="comment">//至于为什么这么做，后面会有详细分析。</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure>

<p>Entry是HashMap中的一个静态内部类。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">       <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates new entry.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">           value = v;</span><br><span class="line">           next = n;</span><br><span class="line">           key = k;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果存在链表则需要先获取但前hash对应的数组位置，然后获取数组下的链表，对链表进行遍历比较找到对应的元素。对于添加则是先计算出key的hash值然后在判断但前hash值对应位置是否有无链表，如果有链表则获取遍历链表，再判断有无但前元素对应的key有则覆盖，无则添加到链表尾端。</strong></p>
<p><img alt="img" data-src="https://img-blog.csdnimg.cn/20200227145910227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BfRG9yYWVtb24=,size_16,color_FFFFFF,t_70"></p>
<p>put操作的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//新增一个entry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//capacity一定是2的次幂</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值</span></span><br><span class="line">        <span class="comment">//capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert number &gt;= 0 : "number must be non-negative";</span></span><br><span class="line">        <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">                ? MAXIMUM_CAPACITY</span><br><span class="line">                : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这是一个神奇的函数，用了很多的异或，移位等运算，</span></span><br><span class="line"><span class="comment">//对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回数组下标 确定数组位置</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终存储位置确认流程</strong></p>
<p>​    先获取key的hash值，然后通过hash方法运算计算出最适合集合的hash值, 在通过index for 方法以 h &amp; (length-1); 的方式确定key在数组中的位置，然后进行存储。如果元素为null则确立下标为0.</p>
<p><img alt="img" data-src="https://img-blog.csdnimg.cn/20200227153620930.png"></p>
<p><strong>为什么每次扩容都是2的次幂</strong></p>
<p>因为便于计算下标位置，每次都为2的次方则每次扩容都是将二进制位往前移动了一位的意思，所以在技术存储位置时length-1 则是把除了首位的位置全部变成了1，这样在与hash值进行&amp;计算时更加的方便准确，分布也会更加均匀。减少碰撞几率，增加查询效率。</p>
<p><strong>get方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">　　　　 <span class="comment">//如果key为null,则直接去table[0]处去检索即可。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">        <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null。</p>
]]></content>
  </entry>
  <entry>
    <title>spring-data-jpa入门</title>
    <url>/posts/4b6ca2da/</url>
    <content><![CDATA[<blockquote>
<p>SpringData JPA是spring基于ORM框架、JPA规范的基础上封装的一套JPA应用框架，可以使开发者使用极简的代码实现对数据库的访问和操作。它提供了包括增删改查等在内的基本功能，且易于扩展。</p>
</blockquote><h3 id="1-springdata-jpa、jpa和hibernate三者关系"><a href="#1-springdata-jpa、jpa和hibernate三者关系" class="headerlink" title="1 springdata jpa、jpa和hibernate三者关系"></a>1 springdata jpa、jpa和hibernate三者关系</h3><p>通俗来讲springdata jpa是对jpa规范的一层封装，hibernate实现了jpa规范。spring data jpa 内部封装了hibernate 是使用hibernate进行数据库交互的。</p><a id="more"></a>

<h3 id="2-编写spring配置文件"><a href="#2-编写spring配置文件" class="headerlink" title="2 编写spring配置文件"></a>2 编写spring配置文件</h3><ul>
<li>配置spring相关</li>
<li>数据源信息</li>
<li>jpa的实现方式</li>
<li>配置要用到的实体类</li>
<li>配置jpa实现方的配置信息</li>
<li>配置事务管理器</li>
<li>声明式事务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:jpa=&quot;http://www.springframework.org/schema/data/jpa&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--spring--&gt;</span><br><span class="line">    &lt;!--配置spring的注解扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.lxf&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--spring data jpa--&gt;</span><br><span class="line">    &lt;!--整合spring data jpa--&gt;</span><br><span class="line">    &lt;jpa:repositories base-package=&quot;com.lxf.dao&quot; entity-manager-factory-ref=&quot;entityManagerFactory&quot; transaction-manager-ref=&quot;transactionManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--创建实体管理器工厂,交给spring管理--&gt;</span><br><span class="line">    &lt;bean id=&quot;entityManagerFactory&quot; class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--配置数据源--&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">        &lt;!--配置要扫描的包，实体所在包--&gt;</span><br><span class="line">        &lt;property name=&quot;packagesToScan&quot; value=&quot;com.lxf.entity&quot;/&gt;</span><br><span class="line">        &lt;!--配置jpa的实现方--&gt;</span><br><span class="line">        &lt;property name=&quot;persistenceProvider&quot;&gt;</span><br><span class="line">            &lt;bean class=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa的实现方的配置--&gt;</span><br><span class="line">        &lt;property name=&quot;jpaVendorAdapter&quot;&gt;</span><br><span class="line">            &lt;bean class=&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;&gt;</span><br><span class="line">                &lt;!--数据库类型--&gt;</span><br><span class="line">                &lt;property name=&quot;database&quot; value=&quot;MYSQL&quot;/&gt;</span><br><span class="line">                &lt;!--控制台显示sql语句--&gt;</span><br><span class="line">                &lt;property name=&quot;showSql&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">                &lt;!--是否自动创建数据库表--&gt;</span><br><span class="line">                &lt;property name=&quot;generateDdl&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">                &lt;!--数据库方言--&gt;</span><br><span class="line">                &lt;property name=&quot;databasePlatform&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa方言:高级特性--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--数据源--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/study?serverTimezone=GMT&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;crystal1024&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置事务管理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明式事务--&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-实体关系映射（ORM）"><a href="#3-实体关系映射（ORM）" class="headerlink" title="3 实体关系映射（ORM）"></a>3 实体关系映射（ORM）</h3><h4 id="3-1-ID生成策略"><a href="#3-1-ID生成策略" class="headerlink" title="3.1 ID生成策略"></a>3.1 ID生成策略</h4><p>ID对应数据库表的主键，是保证唯一性的重要属性。JPA提供了以下几种ID生成策略</p>
<ol>
<li><p>GeneratorType.AUTO ，由JPA自动生成</p>
</li>
<li><p>GenerationType.IDENTITY，使用数据库的自增长字段，需要数据库的支持（如SQL Server、MySQL、DB2、Derby等）</p>
</li>
<li><p>GenerationType.SEQUENCE，使用数据库的序列号，需要数据库的支持（如Oracle）</p>
</li>
<li><p>GenerationType.TABLE，使用指定的数据库表记录ID的增长 需要定义一个TableGenerator，在@GeneratedValue中引用。例如：</p>
<p>@TableGenerator( name=”myGenerator”, table=”GENERATORTABLE”, pkColumnName = “ENTITYNAME”, pkColumnValue=”MyEntity”, valueColumnName = “PKVALUE”, allocationSize=1 )</p>
<p>@GeneratedValue(strategy = GenerationType.TABLE,generator=”myGenerator”)</p>
</li>
</ol>
<h4 id="3-2-关联关系"><a href="#3-2-关联关系" class="headerlink" title="3.2 关联关系"></a>3.2 关联关系</h4><p>JPA定义了one-to-one、one-to-many、many-to-one、many-to-many 4种关系。</p>
<p>对于数据库来说，通常在一个表中记录对另一个表的外键关联；对应到实体对象，持有关联数据的一方称为owning-side，另一方称为inverse-side。</p>
<p>为了编程的方便，我们经常会希望在inverse-side也能引用到owning-side的对象，此时就构建了双向关联关系。 在双向关联中，需要在inverse-side定义mappedBy属性，以指明在owning-side是哪一个属性持有的关联数据。</p>
<p>对关联关系映射的要点如下：</p>
<table>
<thead>
<tr>
<th align="center">关系类型</th>
<th align="center">Owning-Side</th>
<th align="center">Inverse-Side</th>
</tr>
</thead>
<tbody><tr>
<td align="center">one-to-one</td>
<td align="center">@OneToOne</td>
<td align="center">@OneToOne(mappedBy=”othersideName”)</td>
</tr>
<tr>
<td align="center">one-to-many / many-to-one</td>
<td align="center">@ManyToOne</td>
<td align="center">@OneToMany(mappedBy=”xxx”)</td>
</tr>
<tr>
<td align="center">many-to-many</td>
<td align="center">@ManyToMany</td>
<td align="center">@ManyToMany(mappedBy =”xxx”)</td>
</tr>
</tbody></table>
<p>其中 many-to-many关系的owning-side可以使用@JoinTable声明自定义关联表，比如Book和Author之间的关联表：</p>
<p>@JoinTable(name = “BOOKAUTHOR”, joinColumns = { @JoinColumn(name = “BOOKID”, referencedColumnName = “id”) }, inverseJoinColumns = { @JoinColumn(name = “AUTHORID”, referencedColumnName = “id”) })</p>
<p>关联关系还可以定制延迟加载和级联操作的行为（owning-side和inverse-side可以分别设置）：</p>
<p>通过设置fetch=FetchType.LAZY 或 fetch=FetchType.EAGER来决定关联对象是延迟加载或立即加载。</p>
<p>通过设置cascade={options}可以设置级联操作的行为，其中options可以是以下组合：</p>
<ul>
<li>CascadeType.MERGE 级联更新</li>
<li>CascadeType.PERSIST 级联保存</li>
<li>CascadeType.REFRESH 级联刷新</li>
<li>CascadeType.REMOVE 级联删除</li>
<li>CascadeType.ALL 级联上述4种操作</li>
</ul>
<h4 id="3-5-继承关系"><a href="#3-5-继承关系" class="headerlink" title="3.5 继承关系"></a>3.5 继承关系</h4><p>JPA通过在父类增加@Inheritance(strategy=InheritanceType.xxx)来声明继承关系。A支持3种继承策略：</p>
<ol>
<li>单表继承（InheritanceType.SINGLETABLE），所有继承树上的类共用一张表，在父类指定（@DiscriminatorColumn）声明并在每个类指定@DiscriminatorValue来区分类型。</li>
<li>类表继承（InheritanceType.JOINED），父子类共同的部分公用一张表，其余部分保存到各自的表，通过join进行关联。</li>
<li>具体表继承（InheritanceType.TABLEPERCLASS)，每个具体类映射到自己的表。</li>
</ol>
<p>其中1和2能够支持多态，但是1需要允许字段为NULL，2需要多个JOIN关系；3最适合关系数据库，对多态支持不好。具体应用时根据需要取舍。</p>
<h6 id="实战示例"><a href="#实战示例" class="headerlink" title="实战示例"></a>实战示例</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.itcast.om.cms.heima.domain;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import javax.persistence.CascadeType;</span><br><span class="line">import javax.persistence.Column;</span><br><span class="line">import javax.persistence.Entity;</span><br><span class="line">import javax.persistence.Id;</span><br><span class="line">import javax.persistence.JoinColumn;</span><br><span class="line">import javax.persistence.Lob;</span><br><span class="line">import javax.persistence.ManyToOne;</span><br><span class="line">import javax.persistence.Temporal;</span><br><span class="line">import javax.persistence.TemporalType;</span><br><span class="line">import javax.persistence.Transient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 资讯内容</span><br><span class="line"> */</span><br><span class="line">@Entity</span><br><span class="line">public class News implements Serializable &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	private static final long serialVersionUID = -2383334094869003498L;</span><br><span class="line">	/*主键*/</span><br><span class="line">	private String uuid;</span><br><span class="line">	/* 是否推荐 */</span><br><span class="line">    private boolean commend = false;</span><br><span class="line">    /* 审核状态,true为审核通过，false为未通过 */</span><br><span class="line">    private Boolean checkstate = false;</span><br><span class="line">    /* 点击统计*/</span><br><span class="line">    private Integer hitcount =1;</span><br><span class="line">    /* 搜索关键词 */</span><br><span class="line">    private String googlekey;</span><br><span class="line">    /* 信息标题*/</span><br><span class="line">    private String title;</span><br><span class="line">    /* 创建日期*/</span><br><span class="line">    private Date createdate = new Date();</span><br><span class="line">    /* 信息内容*/</span><br><span class="line">    private String description;</span><br><span class="line">    /* 该条信息是否可以进行评论*/</span><br><span class="line">    private boolean commentswitch =true;</span><br><span class="line">    /* 信息来源 */</span><br><span class="line">    private String source;</span><br><span class="line">    /* 导语  */</span><br><span class="line">    private String lead;</span><br><span class="line">    /* 配图  */</span><br><span class="line">    private String iconpath;</span><br><span class="line">    public static final String ICONVIRDIR = &quot;/images/news/icon&quot;;</span><br><span class="line">    /* 所属目录*/</span><br><span class="line">    private Information information;</span><br><span class="line">	/* 可以为单独某篇新闻指定模版 */</span><br><span class="line">	private InformationTemplate informationTemplate;</span><br><span class="line"></span><br><span class="line">	@Column(name=&quot;username&quot;)</span><br><span class="line">	private String username;</span><br><span class="line">	@Column(name=&quot;realname&quot;)</span><br><span class="line">	private String realname;</span><br><span class="line">	</span><br><span class="line">    public News() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public News(String uuid) &#123;</span><br><span class="line">        this.uuid = uuid;</span><br><span class="line">    &#125;</span><br><span class="line">    public News(String uuid, String _title) &#123;</span><br><span class="line">    	this.uuid = uuid;</span><br><span class="line">    	this.title = _title;</span><br><span class="line">    &#125;</span><br><span class="line">    @Column(nullable=false)</span><br><span class="line">    public Boolean getCheckstate() &#123;</span><br><span class="line">		return checkstate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setCheckstate(Boolean checkstate) &#123;</span><br><span class="line">		this.checkstate = checkstate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//对应longtext</span><br><span class="line">	@Lob</span><br><span class="line">    public String getLead() &#123;</span><br><span class="line">		return lead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setLead(String lead) &#123;</span><br><span class="line">		this.lead = lead;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getIconpath() &#123;</span><br><span class="line">		return iconpath;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setIconpath(String iconpath) &#123;</span><br><span class="line">		this.iconpath = iconpath;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">     * 获取资讯文件web路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Transient</span><br><span class="line">    public String getVirPath()&#123;</span><br><span class="line">    	if(this.uuid!=null)&#123;</span><br><span class="line">    		SimpleDateFormat sf = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span><br><span class="line">    		SimpleDateFormat sf2 = new SimpleDateFormat(&quot;HHmmss&quot;);</span><br><span class="line">    		String format = sf.format(this.createdate);</span><br><span class="line">    		String format2 = sf2.format(this.createdate);</span><br><span class="line">    		return &quot;/news/&quot;+format+&quot;/&quot;+ format2+ &quot;.html&quot;;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return null;</span><br><span class="line">    &#125;</span><br><span class="line">	/**</span><br><span class="line">     * 获取配图文件web路径</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Transient</span><br><span class="line">    public String getVirIconPath()&#123;</span><br><span class="line">    	if(this.iconpath!=null)&#123;</span><br><span class="line">    		return ICONVIRDIR+ &quot;/&quot;+ iconpath;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //标明主键</span><br><span class="line">    @Id @Column(length=36)</span><br><span class="line">    public String getUuid() &#123;</span><br><span class="line">		return uuid;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setUuid(String uuid) &#123;</span><br><span class="line">		this.uuid = uuid;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//外键表关联 一对多查询</span><br><span class="line">    @ManyToOne(cascade=CascadeType.REFRESH, optional=true)</span><br><span class="line">    @JoinColumn(name=&quot;informationtemplate_id&quot;)</span><br><span class="line">	public InformationTemplate getInformationTemplate() &#123;</span><br><span class="line">		return informationTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setInformationTemplate(InformationTemplate informationTemplate) &#123;</span><br><span class="line">		this.informationTemplate = informationTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    @Column(length=50)</span><br><span class="line">    public String getGooglekey() &#123;</span><br><span class="line">		return googlekey;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setGooglekey(String googlekey) &#123;</span><br><span class="line">		this.googlekey = googlekey;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Column(nullable=false)</span><br><span class="line">    public boolean getCommend() &#123;</span><br><span class="line">        return commend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCommend(boolean _commend) &#123;</span><br><span class="line">        this.commend = _commend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Column(nullable=false)</span><br><span class="line">    public Integer getHitcount() &#123;</span><br><span class="line">        return hitcount;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setHitcount(Integer _hitcount) &#123;</span><br><span class="line">        this.hitcount = _hitcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Column(nullable=false,length=100)</span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String _title) &#123;</span><br><span class="line">        this.title = _title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	//时间类型格式化</span><br><span class="line">    @Temporal(value=TemporalType.TIMESTAMP)</span><br><span class="line">    public Date getCreatedate() &#123;</span><br><span class="line">        return createdate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCreatedate(Date _createdate) &#123;</span><br><span class="line">        this.createdate = _createdate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Lob</span><br><span class="line">	public String getDescription() &#123;</span><br><span class="line">		return description;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setDescription(String description) &#123;</span><br><span class="line">		this.description = description;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    @Column(nullable=false)</span><br><span class="line">    public boolean getCommentswitch() &#123;</span><br><span class="line">        return commentswitch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCommentswitch(boolean commentswitch) &#123;</span><br><span class="line">        this.commentswitch = commentswitch;</span><br><span class="line">    &#125;</span><br><span class="line">    @Column(length=100)</span><br><span class="line">    public String getSource() &#123;</span><br><span class="line">		return source;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setSource(String source) &#123;</span><br><span class="line">		this.source = source;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@ManyToOne(cascade=&#123;CascadeType.REFRESH&#125;,optional=true)</span><br><span class="line">    @JoinColumn(name = &quot;information_id&quot;)     </span><br><span class="line">    public Information getInformation() &#123;</span><br><span class="line">        return information;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInformation(Information information) &#123;</span><br><span class="line">        this.information = information;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        int hash = 0;</span><br><span class="line">        hash += (this.uuid != null ? this.uuid.hashCode() : 0);</span><br><span class="line">        return hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object object) &#123;</span><br><span class="line">        if (!(object instanceof News)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        News other = (News)object;</span><br><span class="line">        if (this.uuid != other.uuid &amp;&amp; (this.uuid == null || !this.uuid.equals(other.uuid))) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;News [uuid=&quot; + uuid + &quot;, googlekey=&quot; + googlekey + &quot;, title=&quot;</span><br><span class="line">				+ title + &quot;, description=&quot; + description + &quot;, source=&quot; + source</span><br><span class="line">				+ &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getUsername() &#123;</span><br><span class="line">		return username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setUsername(String username) &#123;</span><br><span class="line">		this.username = username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getRealname() &#123;</span><br><span class="line">		return realname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setRealname(String realname) &#123;</span><br><span class="line">		this.realname = realname;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-编写dao层接口"><a href="#4-编写dao层接口" class="headerlink" title="4 编写dao层接口"></a>4 编写dao层接口</h3><ul>
<li><p>需要继承两个接口</p>
<ul>
<li>JpaRepository：封装了增删改查分页排序等基本操作，具体可以看JpaRepository的父类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[Repository] --&gt;B(CrudRepository)</span><br><span class="line">B --&gt; C(PagingAndSortingRepository)</span><br><span class="line">C --&gt;D(JpaRepository)</span><br></pre></td></tr></table></figure>

<ul>
<li>JpaSpecificationExecutor：封装了标准查询</li>
</ul>
</li>
<li><p>提供相应的泛型</p>
<ul>
<li>JpaRepository <ul>
<li>操作的实体类型</li>
<li>实体中主键类型</li>
</ul>
</li>
<li>JpaSpecificationExecutor <ul>
<li>操作的实体类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao extends JpaRepository&lt;User,Integer&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>会通过动态代理自动生成相应方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//参数插入的几种格式</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select * from user where name = :name and age = :age"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String userName,@<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select * from user where name = ? and age = ?"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName1</span><span class="params">( String userName, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"select * from user where name = ?1 and age = ?2"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName1</span><span class="params">( String userName, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据更新或者增加</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">	<span class="meta">@Modifying</span>(clearAutomatically = <span class="keyword">true</span>)</span><br><span class="line">	<span class="meta">@Query</span>(value = <span class="string">"update information set title = ?1 , description = ?2 , keywords = ?3     WHERE uuid = ?4"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">updataInformation</span> <span class="params">(String title,String description,String keywords,String     uuid)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="语句操作"><a href="#语句操作" class="headerlink" title="语句操作"></a>语句操作</h5><p>除了调用spring data jpa内置的api，我们也可以在dao接口中定义我们自己的方法，通过@Query声明jpql或sql语句。</p>
<ul>
<li>@Query <ul>
<li>value：数据库操作语句</li>
<li>nativeQuery：是否是原生查询，默认false，即默认使用jpql查询</li>
</ul>
</li>
<li>@Modifying：声明当前是一个更新操作，需要修改数据库数据。 <ul>
<li>只能用于void或int/Integer的返回类型</li>
<li>因为需要修改数据库数据，未防止修改失败造成未知后果，需要搭配事务管理来是使用</li>
</ul>
</li>
<li>@Transactional：添加事务管理支持 <ul>
<li>一般需要设置rollbackFor或者noRollbackFor，来表示什么情况下进行事务回滚</li>
</ul>
</li>
<li>@Rollback：是否可以回滚，默认true</li>
</ul>
<h5 id="约定规则查询"><a href="#约定规则查询" class="headerlink" title="约定规则查询"></a>约定规则查询</h5><p>spring data jpa制定了一些约定，如果按照这些约定来定义方法名，则会自动解析出sql语句。</p>
<blockquote>
<p>findBy + 属性名 + 查询方式 + （And|Or） + 属性名 + 查询方式…</p>
</blockquote>
<table>
<thead>
<tr>
<th>查询方式</th>
<th>方法命名</th>
<th>sql where字句</th>
</tr>
</thead>
<tbody><tr>
<td>And</td>
<td>findByNameAndPwd</td>
<td>where name= ? and pwd =?</td>
</tr>
<tr>
<td>Or</td>
<td>findByNameOrSex</td>
<td>where name= ? or sex=?</td>
</tr>
<tr>
<td>Is,Equals</td>
<td>findById,findByIdEquals</td>
<td>where id= ?</td>
</tr>
<tr>
<td>Between</td>
<td>findByIdBetween</td>
<td>where id between ? and ?</td>
</tr>
<tr>
<td>LessThan</td>
<td>findByIdLessThan</td>
<td>where id &lt; ?</td>
</tr>
<tr>
<td>LessThanEquals</td>
<td>findByIdLessThanEquals</td>
<td>where id &lt;= ?</td>
</tr>
<tr>
<td>GreaterThan</td>
<td>findByIdGreaterThan</td>
<td>where id &gt; ?</td>
</tr>
<tr>
<td>GreaterThanEquals</td>
<td>findByIdGreaterThanEquals</td>
<td>where id &gt; = ?</td>
</tr>
<tr>
<td>After</td>
<td>findByIdAfter</td>
<td>where id &gt; ?</td>
</tr>
<tr>
<td>Before</td>
<td>findByIdBefore</td>
<td>where id &lt; ?</td>
</tr>
<tr>
<td>IsNull</td>
<td>findByNameIsNull</td>
<td>where name is null</td>
</tr>
<tr>
<td>isNotNull,NotNull</td>
<td>findByNameNotNull</td>
<td>where name is not null</td>
</tr>
<tr>
<td>Like</td>
<td>findByNameLike</td>
<td>where name like ?</td>
</tr>
<tr>
<td>NotLike</td>
<td>findByNameNotLike</td>
<td>where name not like ?</td>
</tr>
<tr>
<td>StartingWith</td>
<td>findByNameStartingWith</td>
<td>where name like ‘?%’</td>
</tr>
<tr>
<td>EndingWith</td>
<td>findByNameEndingWith</td>
<td>where name like ‘%?’</td>
</tr>
<tr>
<td>Containing</td>
<td>findByNameContaining</td>
<td>where name like ‘%?%’</td>
</tr>
<tr>
<td>OrderBy</td>
<td>findByIdOrderByXDesc</td>
<td>where id=? order by x desc</td>
</tr>
<tr>
<td>Not</td>
<td>findByNameNot</td>
<td>where name &lt;&gt; ?</td>
</tr>
<tr>
<td>In</td>
<td>findByIdIn(Collection&lt;?&gt; c)</td>
<td>where id in (?)</td>
</tr>
<tr>
<td>NotIn</td>
<td>findByIdNotIn(Collection&lt;?&gt; c)</td>
<td>where id not  in (?)</td>
</tr>
<tr>
<td>True</td>
<td>findByAaaTue</td>
<td>where aaa = true</td>
</tr>
<tr>
<td>False</td>
<td>findByAaaFalse</td>
<td>where aaa = false</td>
</tr>
<tr>
<td>IgnoreCase</td>
<td>findByNameIgnoreCase</td>
<td>where UPPER(name)=UPPER(?)</td>
</tr>
</tbody></table>
<p>简单挑几个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao extends JpaRepository&lt;User, Integer&gt;, JpaSpecificationExecutor&lt;User&gt; &#123;</span><br><span class="line">    public User findByName(String name);</span><br><span class="line"></span><br><span class="line">    public User findByNameLike(String name);</span><br><span class="line"></span><br><span class="line">    public User findByNameLikeAndAge(String name, int age);</span><br><span class="line"></span><br><span class="line">    public List&lt;User&gt; findByIdBetween(int idMin, int idMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-标准查询（Specification）"><a href="#5-标准查询（Specification）" class="headerlink" title="5 标准查询（Specification）"></a>5 标准查询（Specification）</h3><p>我们上面提到过，springdata jpa的dao层一般继承2个接口JpaRepository和JpaSpecificationExecutor。JpaRepository封装了crud、统计、排序、分页的常见操作，而JpaSpecificationExecutor基于JPA的criteria查询封装了另一种查询方式，我们之前一直在使用JpaRepositoru中的方法，下面来看下JpaSpecificationExecutor接口，它里面只提供了5个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">    //查询一个</span><br><span class="line">    Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">    //查询全部</span><br><span class="line">    List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">    //查询全部  提供分页功能</span><br><span class="line">    Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">    //查询全部，提供排序功能</span><br><span class="line">    List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">    //统计</span><br><span class="line">    long count(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这5个方法有个共同点，接收一个Specification参数。</p>
<h5 id="Specification"><a href="#Specification" class="headerlink" title="Specification"></a>Specification</h5><p>Specification是对JPA规范中Root、CriteriaQuery、CriteriaBuilder的一层封装，用于构建过滤条件。实例化Specification需要实现它的toPerdicate方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//参数含义在我的另一文JPA规范中有介绍，简单说来Root用于获得查询属性，CriteriaBuilder用于构建过滤条件，CriteriaQuery用于指定最终查询语句，这里一般不会使用，默认为where语句。</span><br><span class="line">Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);</span><br></pre></td></tr></table></figure>

<p>注意这里创建出来的是where查询语句。</p>
<p>来个简单示例，查询表中年龄大于等于18的所有河南人：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    Specification&lt;User&gt; specification = new Specification&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">            //分别构造各个单属性的过滤条件</span><br><span class="line">            Predicate namePredicate = criteriaBuilder.like(root.get(&quot;address&quot;), &quot;河南%&quot;);</span><br><span class="line">            Predicate agePredicate = criteriaBuilder.ge(root.get(&quot;age&quot;), 18);//大于等于</span><br><span class="line"></span><br><span class="line">            //组合成最终的过滤条件</span><br><span class="line">            Predicate predicate = criteriaBuilder.and(namePredicate, agePredicate);</span><br><span class="line">            return predicate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    //查询</span><br><span class="line">    List&lt;User&gt; users = userDao.findAll(specification);</span><br><span class="line">    users.forEach(new Consumer&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(User user) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要添加排序和分页，可以使用Sort和Pageable。</p>
<ul>
<li>Sort：排序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort sort = new Sort(Sort.Direction.DESC,&quot;id&quot;);//排序属性可以设置多个</span><br><span class="line">List&lt;User&gt; users = userDao.findAll(specification,sort);</span><br></pre></td></tr></table></figure>

<ul>
<li>Pageable：分页，是一个接口，可以通过PageRequest构建实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sort sort = new Sort(Sort.Direction.DESC,&quot;id&quot;);</span><br><span class="line">//Pageable pageable = PageRequest.of(0,10);//pageIndex，pageSize</span><br><span class="line">Pageable pageable = PageRequest.of(0,10,sort);</span><br><span class="line">Page&lt;User&gt; users = userDao.findAll(specification, pageable);</span><br><span class="line">users.forEach(new Consumer&lt;User&gt;() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void accept(User user) &#123;</span><br><span class="line">      System.out.println(user);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/posts/5205ee75/</url>
    <content><![CDATA[<h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h4 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h4><ul>
<li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li>
<li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li>
</ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><a id="more"></a>

<h4 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h4><p><strong>== 解读</strong></p>
<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classCat&#123;</span><br><span class="line">    publicCat(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    publicvoidsetName(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat c1 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">Cat c2 = <span class="keyword">new</span> Cat(<span class="string">"王磊"</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicbooleanequals(Object obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"老王"</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">publicbooleanequals(Object anObject)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"通话"</span>;</span><br><span class="line">String str2 = <span class="string">"重地"</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">"str1：%d | str2：%d"</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br></pre></td></tr></table></figure>

<p>执行的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1：1179395 | str2：1179395</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4. final 在 Java 中有什么作用？"></a>4. final 在 Java 中有什么作用？</h4><ul>
<li>final 修饰的类叫最终类，该类不能被继承。</li>
<li>final 修饰的方法不能被重写。</li>
<li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li>
</ul>
<h4 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a>5. Java 中的 Math. round(-1. 5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h4><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a>8. String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuffer. reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder. append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System. out. println(stringBuilder. reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure>

<h4 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h4><ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> classCat&#123;</span><br><span class="line">    publicstaticvoidsayHi()&#123;</span><br><span class="line">        System. out. println(<span class="string">"hi~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h4><ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img alt="编译器保存图" data-src="https://images.gitbook.cn/58edb860-3be3-11e9-af57-196eefd310b5"></p>
<h4 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h4><ul>
<li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li>
<li>构造函数：抽象类可以有构造函数；接口不能有。</li>
<li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li>
<li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li>
</ul>
<h4 id="15-Java-中-IO-流分为几种？"><a href="#15-Java-中-IO-流分为几种？" class="headerlink" title="15. Java 中 IO 流分为几种？"></a>15. Java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h4><ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
<h4 id="17-Files的常用方法都有哪些？"><a href="#17-Files的常用方法都有哪些？" class="headerlink" title="17. Files的常用方法都有哪些？"></a>17. Files的常用方法都有哪些？</h4><ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="18-Java-容器都有哪些？"><a href="#18-Java-容器都有哪些？" class="headerlink" title="18. Java 容器都有哪些？"></a>18. Java 容器都有哪些？</h4><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<ul>
<li>Collection</li>
<li>List<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector</li>
<li>Stack</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
<li>Map</li>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
<li>ConcurrentHashMap</li>
<li>Hashtable</li>
</ul>
<h4 id="19-Collection-和-Collections-有什么区别？"><a href="#19-Collection-和-Collections-有什么区别？" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a>19. Collection 和 Collections 有什么区别？</h4><ul>
<li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li>
<li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li>
</ul>
<h4 id="20-List、Set、Map-之间的区别是什么？"><a href="#20-List、Set、Map-之间的区别是什么？" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a>20. List、Set、Map 之间的区别是什么？</h4><p>List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>三者之间的区别，如下表：</p>
<p><img alt="区别图" data-src="https://images.gitbook.cn/6e7001c0-3be3-11e9-af57-196eefd310b5"></p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？"><a href="#21-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a>21. HashMap 和 Hashtable 有什么区别？</h4><ul>
<li>存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</li>
<li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ul>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a>23. 说一下 HashMap 的实现原理？</h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h4 id="24-说一下-HashSet-的实现原理？"><a href="#24-说一下-HashSet-的实现原理？" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a>24. 说一下 HashSet 的实现原理？</h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？"><a href="#25-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a>25. ArrayList 和 LinkedList 的区别是什么？</h4><ul>
<li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li>
<li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li>
<li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li>
</ul>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="26-如何实现数组和-List-之间的转换？"><a href="#26-如何实现数组和-List-之间的转换？" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a>26. 如何实现数组和 List 之间的转换？</h4><ul>
<li>数组转 List：使用 Arrays. asList(array) 进行转换。</li>
<li>List 转数组：使用 List 自带的 toArray() 方法。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list. add(<span class="string">"王磊"</span>);</span><br><span class="line">list. add(<span class="string">"的博客"</span>);</span><br><span class="line">list. toArray();</span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> String[]&#123;<span class="string">"王磊"</span>,<span class="string">"的博客"</span>&#125;;</span><br><span class="line">Arrays. asList(array);</span><br></pre></td></tr></table></figure>

<h4 id="27-ArrayList-和-Vector-的区别是什么？"><a href="#27-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a>27. ArrayList 和 Vector 的区别是什么？</h4><ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
<h4 id="28-Array-和-ArrayList-有何区别？"><a href="#28-Array-和-ArrayList-有何区别？" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a>28. Array 和 ArrayList 有何区别？</h4><ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a>29. 在 Queue 中 poll()和 remove()有什么区别？</h4><ul>
<li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li>
<li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">queue. offer(<span class="string">"string"</span>); <span class="comment">// add</span></span><br><span class="line">System. out. println(queue. poll());</span><br><span class="line">System. out. println(queue. remove());</span><br><span class="line">System. out. println(queue. size());</span><br></pre></td></tr></table></figure>

<h4 id="30-哪些集合类是线程安全的？"><a href="#30-哪些集合类是线程安全的？" class="headerlink" title="30. 哪些集合类是线程安全的？"></a>30. 哪些集合类是线程安全的？</h4><p>Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？"><a href="#31-迭代器-Iterator-是什么？" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a>31. 迭代器 Iterator 是什么？</h4><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？"><a href="#32-Iterator-怎么使用？有什么特点？" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a>32. Iterator 怎么使用？有什么特点？</h4><p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="33-Iterator-和-ListIterator-有什么区别？"><a href="#33-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a>33. Iterator 和 ListIterator 有什么区别？</h4><ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h4 id="34-怎么确保一个集合不能被修改？"><a href="#34-怎么确保一个集合不能被修改？" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a>34. 怎么确保一个集合不能被修改？</h4><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list. add(<span class="string">"x"</span>);</span><br><span class="line">Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);</span><br><span class="line">clist. add(<span class="string">"y"</span>); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. println(list. size());</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="35-并行和并发有什么区别？"><a href="#35-并行和并发有什么区别？" class="headerlink" title="35. 并行和并发有什么区别？"></a>35. 并行和并发有什么区别？</h4><ul>
<li>并行：多个处理器或多核处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</li>
</ul>
<p>如下图：</p>
<p><img alt="并发和并行" data-src="https://images.gitbook.cn/44c76fe0-3d80-11e9-8c5c-8b54d319dad1"></p>
<p>并发 = 两个队列和一台咖啡机。</p>
<p>并行 = 两个队列和两台咖啡机。</p>
<h4 id="36-线程和进程的区别？"><a href="#36-线程和进程的区别？" class="headerlink" title="36. 线程和进程的区别？"></a>36. 线程和进程的区别？</h4><p>一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h4 id="37-守护线程是什么？"><a href="#37-守护线程是什么？" class="headerlink" title="37. 守护线程是什么？"></a>37. 守护线程是什么？</h4><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h4 id="38-创建线程有哪几种方式？"><a href="#38-创建线程有哪几种方式？" class="headerlink" title="38. 创建线程有哪几种方式？"></a>38. 创建线程有哪几种方式？</h4><p>创建线程有三种方式：</p>
<ul>
<li>继承 Thread 重写 run 方法；</li>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口。</li>
</ul>
<h4 id="39-说一下-runnable-和-callable-有什么区别？"><a href="#39-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a>39. 说一下 runnable 和 callable 有什么区别？</h4><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<h4 id="40-线程有哪些状态？"><a href="#40-线程有哪些状态？" class="headerlink" title="40. 线程有哪些状态？"></a>40. 线程有哪些状态？</h4><p>线程的状态：</p>
<ul>
<li>NEW 尚未启动</li>
<li>RUNNABLE 正在执行中</li>
<li>BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</li>
<li>WAITING 永久等待状态</li>
<li>TIMED_WAITING 等待指定的时间重新被唤醒的状态</li>
<li>TERMINATED 执行完成</li>
</ul>
<h4 id="41-sleep-和-wait-有什么区别？"><a href="#41-sleep-和-wait-有什么区别？" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a>41. sleep() 和 wait() 有什么区别？</h4><ul>
<li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li>
<li>释放锁：sleep() 不释放锁；wait() 释放锁。</li>
<li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li>
</ul>
<h4 id="42-notify-和-notifyAll-有什么区别？"><a href="#42-notify-和-notifyAll-有什么区别？" class="headerlink" title="42. notify()和 notifyAll()有什么区别？"></a>42. notify()和 notifyAll()有什么区别？</h4><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h4 id="43-线程的-run-和-start-有什么区别？"><a href="#43-线程的-run-和-start-有什么区别？" class="headerlink" title="43. 线程的 run() 和 start() 有什么区别？"></a>43. 线程的 run() 和 start() 有什么区别？</h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h4 id="44-创建线程池有哪几种方式？"><a href="#44-创建线程池有哪几种方式？" class="headerlink" title="44. 创建线程池有哪几种方式？"></a>44. 创建线程池有哪几种方式？</h4><p>线程池创建有七种方式，最核心的是最后一种：</p>
<ul>
<li>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</li>
<li>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</li>
<li>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</li>
<li>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</li>
<li>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</li>
<li>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</li>
<li>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</li>
</ul>
<h4 id="45-线程池都有哪些状态？"><a href="#45-线程池都有哪些状态？" class="headerlink" title="45. 线程池都有哪些状态？"></a>45. 线程池都有哪些状态？</h4><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</li>
</ul>
<h4 id="46-线程池中-submit-和-execute-方法有什么区别？"><a href="#46-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a>46. 线程池中 submit() 和 execute() 方法有什么区别？</h4><ul>
<li>execute()：只能执行 Runnable 类型的任务。</li>
<li>submit()：可以执行 Runnable 和 Callable 类型的任务。</li>
</ul>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h4 id="47-在-Java-程序中怎么保证多线程的运行安全？"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a>47. 在 Java 程序中怎么保证多线程的运行安全？</h4><ul>
<li>方法一：使用安全类，比如 Java. util. concurrent 下的类。</li>
<li>方法二：使用自动锁 synchronized。</li>
<li>方法三：使用手动锁 Lock。</li>
</ul>
<p>手动锁 Java 示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock. lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">"获得锁"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System. out. println(<span class="string">"释放锁"</span>);</span><br><span class="line">    lock. unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="48-多线程中-synchronized-锁升级的原理是什么？"><a href="#48-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a>48. 多线程中 synchronized 锁升级的原理是什么？</h4><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h4 id="49-什么是死锁？"><a href="#49-什么是死锁？" class="headerlink" title="49. 什么是死锁？"></a>49. 什么是死锁？</h4><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h4 id="50-怎么防止死锁？"><a href="#50-怎么防止死锁？" class="headerlink" title="50. 怎么防止死锁？"></a>50. 怎么防止死锁？</h4><ul>
<li>尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</li>
<li>尽量使用 Java. util. concurrent 并发类代替自己手写锁。</li>
<li>尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</li>
<li>尽量减少同步的代码块。</li>
</ul>
<h4 id="51-ThreadLocal-是什么？有哪些使用场景？"><a href="#51-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景？"></a>51. ThreadLocal 是什么？有哪些使用场景？</h4><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h4 id="52-说一下-synchronized-底层实现原理？"><a href="#52-说一下-synchronized-底层实现原理？" class="headerlink" title="52. 说一下 synchronized 底层实现原理？"></a>52. 说一下 synchronized 底层实现原理？</h4><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<h4 id="53-synchronized-和-volatile-的区别是什么？"><a href="#53-synchronized-和-volatile-的区别是什么？" class="headerlink" title="53. synchronized 和 volatile 的区别是什么？"></a>53. synchronized 和 volatile 的区别是什么？</h4><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h4 id="54-synchronized-和-Lock-有什么区别？"><a href="#54-synchronized-和-Lock-有什么区别？" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a>54. synchronized 和 Lock 有什么区别？</h4><ul>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
<h4 id="55-synchronized-和-ReentrantLock-区别是什么？"><a href="#55-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a>55. synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<ul>
<li>ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</li>
<li>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</li>
<li>ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</li>
</ul>
<h4 id="56-说一下-atomic-的原理？"><a href="#56-说一下-atomic-的原理？" class="headerlink" title="56. 说一下 atomic 的原理？"></a>56. 说一下 atomic 的原理？</h4><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="57-什么是反射？"><a href="#57-什么是反射？" class="headerlink" title="57. 什么是反射？"></a>57. 什么是反射？</h4><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h4 id="58-什么是-Java-序列化？什么情况下需要序列化？"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a>58. 什么是 Java 序列化？什么情况下需要序列化？</h4><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p>
<p>以下情况需要使用 Java 序列化：</p>
<ul>
<li>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li>
<li>想用套接字在网络上传送对象的时候；</li>
<li>想通过RMI（远程方法调用）传输对象的时候。</li>
</ul>
<h4 id="59-动态代理是什么？有哪些应用？"><a href="#59-动态代理是什么？有哪些应用？" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a>59. 动态代理是什么？有哪些应用？</h4><p>动态代理是运行时动态生成代理类。</p>
<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h4 id="60-怎么实现动态代理？"><a href="#60-怎么实现动态代理？" class="headerlink" title="60. 怎么实现动态代理？"></a>60. 怎么实现动态代理？</h4><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<h3 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h3><h4 id="61-为什么要使用克隆？"><a href="#61-为什么要使用克隆？" class="headerlink" title="61. 为什么要使用克隆？"></a>61. 为什么要使用克隆？</h4><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h4 id="62-如何实现对象克隆？"><a href="#62-如何实现对象克隆？" class="headerlink" title="62. 如何实现对象克隆？"></a>62. 如何实现对象克隆？</h4><ul>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ul>
<h4 id="63-深拷贝和浅拷贝区别是什么？"><a href="#63-深拷贝和浅拷贝区别是什么？" class="headerlink" title="63. 深拷贝和浅拷贝区别是什么？"></a>63. 深拷贝和浅拷贝区别是什么？</h4><ul>
<li>浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</li>
<li>深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</li>
</ul>
<h3 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h3><h4 id="64-JSP-和-servlet-有什么区别？"><a href="#64-JSP-和-servlet-有什么区别？" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a>64. JSP 和 servlet 有什么区别？</h4><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>
<h4 id="65-JSP-有哪些内置对象？作用分别是什么？"><a href="#65-JSP-有哪些内置对象？作用分别是什么？" class="headerlink" title="65. JSP 有哪些内置对象？作用分别是什么？"></a>65. JSP 有哪些内置对象？作用分别是什么？</h4><p>JSP 有 9 大内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web 应用的配置对象；</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h4 id="66-说一下-JSP-的-4-种作用域？"><a href="#66-说一下-JSP-的-4-种作用域？" class="headerlink" title="66. 说一下 JSP 的 4 种作用域？"></a>66. 说一下 JSP 的 4 种作用域？</h4><ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</li>
<li>application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h4 id="67-session-和-cookie-有什么区别？"><a href="#67-session-和-cookie-有什么区别？" class="headerlink" title="67. session 和 cookie 有什么区别？"></a>67. session 和 cookie 有什么区别？</h4><ul>
<li>存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</li>
<li>安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</li>
<li>存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</li>
</ul>
<h4 id="68-说一下-session-的工作原理？"><a href="#68-说一下-session-的工作原理？" class="headerlink" title="68. 说一下 session 的工作原理？"></a>68. 说一下 session 的工作原理？</h4><p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h4 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</h4><p>可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h4 id="70-spring-mvc-和-struts-的区别是什么？"><a href="#70-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="70. spring mvc 和 struts 的区别是什么？"></a>70. spring mvc 和 struts 的区别是什么？</h4><ul>
<li>拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</li>
<li>数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li>
<li>拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</li>
<li>对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</li>
</ul>
<h4 id="71-如何避免-SQL-注入？"><a href="#71-如何避免-SQL-注入？" class="headerlink" title="71. 如何避免 SQL 注入？"></a>71. 如何避免 SQL 注入？</h4><ul>
<li>使用预处理 PreparedStatement。</li>
<li>使用正则表达式过滤掉字符中的特殊字符。</li>
</ul>
<h4 id="72-什么是-XSS-攻击，如何避免？"><a href="#72-什么是-XSS-攻击，如何避免？" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a>72. 什么是 XSS 攻击，如何避免？</h4><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h4 id="73-什么是-CSRF-攻击，如何避免？"><a href="#73-什么是-CSRF-攻击，如何避免？" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a>73. 什么是 CSRF 攻击，如何避免？</h4><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加 token 并验证。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="74-throw-和-throws-的区别？"><a href="#74-throw-和-throws-的区别？" class="headerlink" title="74. throw 和 throws 的区别？"></a>74. throw 和 throws 的区别？</h4><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h4 id="75-final、finally、finalize-有什么区别？"><a href="#75-final、finally、finalize-有什么区别？" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a>75. final、finally、finalize 有什么区别？</h4><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h4 id="76-try-catch-finally-中哪个部分可以省略？"><a href="#76-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="76. try-catch-finally 中哪个部分可以省略？"></a>76. try-catch-finally 中哪个部分可以省略？</h4><p>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h4 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h4 id="78-常见的异常类有哪些？"><a href="#78-常见的异常类有哪些？" class="headerlink" title="78. 常见的异常类有哪些？"></a>78. 常见的异常类有哪些？</h4><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>79. http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301：永久重定向。</p>
<p>302：暂时重定向。</p>
<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h4 id="80-forward-和-redirect-的区别？"><a href="#80-forward-和-redirect-的区别？" class="headerlink" title="80. forward 和 redirect 的区别？"></a>80. forward 和 redirect 的区别？</h4><p>forward 是转发 和 redirect 是重定向：</p>
<ul>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h4 id="81-简述-tcp-和-udp的区别？"><a href="#81-简述-tcp-和-udp的区别？" class="headerlink" title="81. 简述 tcp 和 udp的区别？"></a>81. 简述 tcp 和 udp的区别？</h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
<h4 id="82-tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="82. tcp 为什么要三次握手，两次不行吗？为什么？"></a>82. tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<h4 id="83-说一下-tcp-粘包是怎么产生的？"><a href="#83-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的？"></a>83. 说一下 tcp 粘包是怎么产生的？</h4><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
<h4 id="84-OSI-的七层模型都有哪些？"><a href="#84-OSI-的七层模型都有哪些？" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a>84. OSI 的七层模型都有哪些？</h4><ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h4 id="85-get-和-post-请求有哪些区别？"><a href="#85-get-和-post-请求有哪些区别？" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a>85. get 和 post 请求有哪些区别？</h4><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h4 id="86-如何实现跨域？"><a href="#86-如何实现跨域？" class="headerlink" title="86. 如何实现跨域？"></a>86. 如何实现跨域？</h4><p>实现跨域有以下几种方案：</p>
<ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
<h4 id="87-说一下-JSONP-实现原理？"><a href="#87-说一下-JSONP-实现原理？" class="headerlink" title="87. 说一下 JSONP 实现原理？"></a>87. 说一下 JSONP 实现原理？</h4><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="88-说一下你熟悉的设计模式？"><a href="#88-说一下你熟悉的设计模式？" class="headerlink" title="88. 说一下你熟悉的设计模式？"></a>88. 说一下你熟悉的设计模式？</h4><ul>
<li>单例模式：保证被创建一次，节省系统开销。</li>
<li>工厂模式（简单工厂、抽象工厂）：解耦代码。</li>
<li>观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</li>
<li>外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</li>
<li>模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</li>
<li>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</li>
</ul>
<h4 id="89-简单工厂和抽象工厂有什么区别？"><a href="#89-简单工厂和抽象工厂有什么区别？" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a>89. 简单工厂和抽象工厂有什么区别？</h4><ul>
<li>简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</li>
<li>工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</li>
<li>抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</li>
</ul>
<h3 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h3><h4 id="90-为什么要使用-spring？"><a href="#90-为什么要使用-spring？" class="headerlink" title="90. 为什么要使用 spring？"></a>90. 为什么要使用 spring？</h4><ul>
<li>spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</li>
<li>spring 提供了事务支持，使得事务操作变的更加方便。</li>
<li>spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</li>
<li>更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</li>
</ul>
<h4 id="91-解释一下什么是-aop？"><a href="#91-解释一下什么是-aop？" class="headerlink" title="91. 解释一下什么是 aop？"></a>91. 解释一下什么是 aop？</h4><p>aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h4 id="92-解释一下什么是-ioc？"><a href="#92-解释一下什么是-ioc？" class="headerlink" title="92. 解释一下什么是 ioc？"></a>92. 解释一下什么是 ioc？</h4><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h4 id="93-spring-有哪些主要模块？"><a href="#93-spring-有哪些主要模块？" class="headerlink" title="93. spring 有哪些主要模块？"></a>93. spring 有哪些主要模块？</h4><ul>
<li>spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</li>
<li>spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</li>
<li>spring dao：Data Access Object 提供了JDBC的抽象层。</li>
<li>spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</li>
<li>spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</li>
<li>spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</li>
</ul>
<h4 id="94-spring-常用的注入方式有哪些？"><a href="#94-spring-常用的注入方式有哪些？" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a>94. spring 常用的注入方式有哪些？</h4><ul>
<li>setter 属性注入</li>
<li>构造方法注入</li>
<li>注解方式注入</li>
</ul>
<h4 id="95-spring-中的-bean-是线程安全的吗？"><a href="#95-spring-中的-bean-是线程安全的吗？" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a>95. spring 中的 bean 是线程安全的吗？</h4><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<ul>
<li>有状态就是有数据存储功能。</li>
<li>无状态就是不会保存数据。</li>
</ul>
<h4 id="96-spring-支持几种-bean-的作用域？"><a href="#96-spring-支持几种-bean-的作用域？" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a>96. spring 支持几种 bean 的作用域？</h4><p>spring 支持 5 种作用域，如下：</p>
<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：</li>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>
</ul>
<p><strong>注意：</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h4 id="97-spring-自动装配-bean-有哪些方式？"><a href="#97-spring-自动装配-bean-有哪些方式？" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a>97. spring 自动装配 bean 有哪些方式？</h4><ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h4 id="98-spring-事务实现方式有哪些？"><a href="#98-spring-事务实现方式有哪些？" class="headerlink" title="98. spring 事务实现方式有哪些？"></a>98. spring 事务实现方式有哪些？</h4><ul>
<li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li>
<li>编码方式：提供编码的形式管理和维护事务。</li>
</ul>
<h4 id="99-说一下-spring-的事务隔离？"><a href="#99-说一下-spring-的事务隔离？" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a>99. 说一下 spring 的事务隔离？</h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>ISOLATION<em>READ</em>UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
<p>ISOLATION<em>READ</em>COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
<p>ISOLATION<em>REPEATABLE</em>READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
<p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="100-说一下-spring-mvc-运行流程？"><a href="#100-说一下-spring-mvc-运行流程？" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a>100. 说一下 spring mvc 运行流程？</h4><ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h4 id="101-spring-mvc-有哪些组件？"><a href="#101-spring-mvc-有哪些组件？" class="headerlink" title="101. spring mvc 有哪些组件？"></a>101. spring mvc 有哪些组件？</h4><ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h4 id="102-RequestMapping-的作用是什么？"><a href="#102-RequestMapping-的作用是什么？" class="headerlink" title="102. @RequestMapping 的作用是什么？"></a>102. @RequestMapping 的作用是什么？</h4><p>将 http 请求映射到相应的类/方法上。</p>
<h4 id="103-Autowired-的作用是什么？"><a href="#103-Autowired-的作用是什么？" class="headerlink" title="103. @Autowired 的作用是什么？"></a>103. @Autowired 的作用是什么？</h4><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
<h3 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h3><h4 id="104-什么是-spring-boot？"><a href="#104-什么是-spring-boot？" class="headerlink" title="104. 什么是 spring boot？"></a>104. 什么是 spring boot？</h4><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h4 id="105-为什么要用-spring-boot？"><a href="#105-为什么要用-spring-boot？" class="headerlink" title="105. 为什么要用 spring boot？"></a>105. 为什么要用 spring boot？</h4><ul>
<li>配置简单</li>
<li>独立运行</li>
<li>自动装配</li>
<li>无代码生成和 xml 配置</li>
<li>提供应用监控</li>
<li>易上手</li>
<li>提升开发效率</li>
</ul>
<h4 id="106-spring-boot-核心配置文件是什么？"><a href="#106-spring-boot-核心配置文件是什么？" class="headerlink" title="106. spring boot 核心配置文件是什么？"></a>106. spring boot 核心配置文件是什么？</h4><p>spring boot 核心的两个配置文件：</p>
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li>
</ul>
<h4 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="107. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>107. spring boot 配置文件有哪几种类型？它们有什么区别？</h4><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p>
<p>. properties 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring. RabbitMQ. port=5672</span><br></pre></td></tr></table></figure>

<p>. yml 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    RabbitMQ:</span><br><span class="line">        port: 5672</span><br></pre></td></tr></table></figure>

<p>. yml 格式不支持 @PropertySource 注解导入。</p>
<h4 id="108-spring-boot-有哪些方式可以实现热部署？"><a href="#108-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="108. spring boot 有哪些方式可以实现热部署？"></a>108. spring boot 有哪些方式可以实现热部署？</h4><ul>
<li>使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</li>
<li>使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</li>
</ul>
<h4 id="109-jpa-和-hibernate-有什么区别？"><a href="#109-jpa-和-hibernate-有什么区别？" class="headerlink" title="109. jpa 和 hibernate 有什么区别？"></a>109. jpa 和 hibernate 有什么区别？</h4><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h4 id="110-什么是-spring-cloud？"><a href="#110-什么是-spring-cloud？" class="headerlink" title="110. 什么是 spring cloud？"></a>110. 什么是 spring cloud？</h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h4 id="111-spring-cloud-断路器的作用是什么？"><a href="#111-spring-cloud-断路器的作用是什么？" class="headerlink" title="111. spring cloud 断路器的作用是什么？"></a>111. spring cloud 断路器的作用是什么？</h4><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h4 id="112-spring-cloud-的核心组件有哪些？"><a href="#112-spring-cloud-的核心组件有哪些？" class="headerlink" title="112. spring cloud 的核心组件有哪些？"></a>112. spring cloud 的核心组件有哪些？</h4><ul>
<li>Eureka：服务注册于发现。</li>
<li>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</li>
<li>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</li>
<li>Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</li>
<li>Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</li>
</ul>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h4 id="113-为什么要使用-hibernate？"><a href="#113-为什么要使用-hibernate？" class="headerlink" title="113. 为什么要使用 hibernate？"></a>113. 为什么要使用 hibernate？</h4><ul>
<li>hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</li>
<li>hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</li>
<li>可以很方便的进行数据库的移植工作。</li>
<li>提供了缓存机制，是程序执行更改的高效。</li>
</ul>
<h4 id="114-什么是-ORM-框架？"><a href="#114-什么是-ORM-框架？" class="headerlink" title="114. 什么是 ORM 框架？"></a>114. 什么是 ORM 框架？</h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h4 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？" class="headerlink" title="115. hibernate 中如何在控制台查看打印的 SQL 语句？"></a>115. hibernate 中如何在控制台查看打印的 SQL 语句？</h4><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h4 id="116-hibernate-有几种查询方式？"><a href="#116-hibernate-有几种查询方式？" class="headerlink" title="116. hibernate 有几种查询方式？"></a>116. hibernate 有几种查询方式？</h4><p>三种：hql、原生 SQL、条件查询 Criteria。</p>
<h4 id="117-hibernate-实体类可以被定义为-final-吗？"><a href="#117-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="117. hibernate 实体类可以被定义为 final 吗？"></a>117. hibernate 实体类可以被定义为 final 吗？</h4><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h4 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h4><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h4 id="119-hibernate-是如何工作的？"><a href="#119-hibernate-是如何工作的？" class="headerlink" title="119. hibernate 是如何工作的？"></a>119. hibernate 是如何工作的？</h4><ul>
<li>读取并解析配置文件。</li>
<li>读取并解析映射文件，创建 SessionFactory。</li>
<li>打开 Session。</li>
<li>创建事务。</li>
<li>进行持久化操作。</li>
<li>提交事务。</li>
<li>关闭 Session。</li>
<li>关闭 SessionFactory。</li>
</ul>
<h4 id="120-get-和-load-的区别？"><a href="#120-get-和-load-的区别？" class="headerlink" title="120. get()和 load()的区别？"></a>120. get()和 load()的区别？</h4><ul>
<li>数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</li>
<li>load()支持延迟加载；get() 不支持延迟加载。</li>
</ul>
<h4 id="121-说一下-hibernate-的缓存机制？"><a href="#121-说一下-hibernate-的缓存机制？" class="headerlink" title="121. 说一下 hibernate 的缓存机制？"></a>121. 说一下 hibernate 的缓存机制？</h4><p>hibernate 常用的缓存有一级缓存和二级缓存：</p>
<p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p>
<p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h4 id="122-hibernate-对象有哪些状态？"><a href="#122-hibernate-对象有哪些状态？" class="headerlink" title="122. hibernate 对象有哪些状态？"></a>122. hibernate 对象有哪些状态？</h4><ul>
<li>临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</li>
<li>持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</li>
<li>游离状态：Session 关闭之后对象就是游离状态。</li>
</ul>
<h4 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h4><ul>
<li>getCurrentSession 会绑定当前线程，而 openSession 则不会。</li>
<li>getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</li>
</ul>
<h4 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="124. hibernate 实体类必须要有无参构造函数吗？为什么？"></a>124. hibernate 实体类必须要有无参构造函数吗？为什么？</h4><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="125-MyBatis-中-和-的区别是什么？"><a href="#125-MyBatis-中-和-的区别是什么？" class="headerlink" title="125. MyBatis 中 #{}和 ${}的区别是什么？"></a>125. MyBatis 中 #{}和 ${}的区别是什么？</h4><p><code>\#{}</code>是预编译处理，<code>${}</code>是字符替换。 在使用 <code>#{}</code>时，MyBatis 会将 SQL 中的 <code>#{}</code>替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p>
<h4 id="126-MyBatis-有几种分页方式？"><a href="#126-MyBatis-有几种分页方式？" class="headerlink" title="126. MyBatis 有几种分页方式？"></a>126. MyBatis 有几种分页方式？</h4><p>分页方式：逻辑分页和物理分页。</p>
<p><strong>逻辑分页：</strong> 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
<p><strong>物理分页：</strong> 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<h4 id="127-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="127. RowBounds 是一次性查询全部结果吗？为什么？"></a>127. RowBounds 是一次性查询全部结果吗？为什么？</h4><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：<span class="exturl" data-url="aHR0cDovL3Q=" title="http://t">http://t<i class="fa fa-external-link"></i></span>. cn/EfSE2g3</p>
<h4 id="128-MyBatis-逻辑分页和物理分页的区别是什么？"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="128. MyBatis 逻辑分页和物理分页的区别是什么？"></a>128. MyBatis 逻辑分页和物理分页的区别是什么？</h4><ul>
<li>逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</li>
<li>物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</li>
</ul>
<h4 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a>129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p>
<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>
<h4 id="130-说一下-MyBatis-的一级缓存和二级缓存？"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？" class="headerlink" title="130. 说一下 MyBatis 的一级缓存和二级缓存？"></a>130. 说一下 MyBatis 的一级缓存和二级缓存？</h4><ul>
<li>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</li>
<li>二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</li>
</ul>
<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h4 id="131-MyBatis-和-hibernate-的区别有哪些？"><a href="#131-MyBatis-和-hibernate-的区别有哪些？" class="headerlink" title="131. MyBatis 和 hibernate 的区别有哪些？"></a>131. MyBatis 和 hibernate 的区别有哪些？</h4><ul>
<li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</li>
<li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</li>
<li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li>
<li>二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</li>
</ul>
<h4 id="132-MyBatis-有哪些执行器（Executor）？"><a href="#132-MyBatis-有哪些执行器（Executor）？" class="headerlink" title="132. MyBatis 有哪些执行器（Executor）？"></a>132. MyBatis 有哪些执行器（Executor）？</h4><p>MyBatis 有三种基本的Executor执行器：</p>
<ul>
<li>SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</li>
<li>ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</li>
<li>BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</li>
</ul>
<h4 id="133-MyBatis-分页插件的实现原理是什么？"><a href="#133-MyBatis-分页插件的实现原理是什么？" class="headerlink" title="133. MyBatis 分页插件的实现原理是什么？"></a>133. MyBatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h4 id="134-MyBatis-如何编写一个自定义插件？"><a href="#134-MyBatis-如何编写一个自定义插件？" class="headerlink" title="134. MyBatis 如何编写一个自定义插件？"></a>134. MyBatis 如何编写一个自定义插件？</h4><p><strong>自定义插件实现原理</strong></p>
<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>
<ul>
<li>Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</li>
<li>StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</li>
<li>ParameterHandler：拦截参数的处理；</li>
<li>ResultSetHandler：拦截结果集的处理。</li>
</ul>
<p><strong>自定义插件实现关键</strong></p>
<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interfaceInterceptor&#123;   </span><br><span class="line">   <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span><span class="keyword">throws</span> Throwable</span>;       </span><br><span class="line">   <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;    </span><br><span class="line">   voidsetProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li>
<li>plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</li>
<li>intercept 方法就是要进行拦截的时候要执行的方法。</li>
</ul>
<p><strong>自定义插件实现示例</strong></p>
<p>官方插件实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor. <span class="class"><span class="keyword">class</span>, <span class="title">method</span></span>= <span class="string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement. <span class="class"><span class="keyword">class</span>, <span class="title">Object</span>. <span class="title">class</span>, <span class="title">RowBounds</span>. <span class="title">class</span>, <span class="title">ResultHandler</span>. <span class="title">class</span>&#125;)&#125;)</span></span><br><span class="line"><span class="class"><span class="title">publicclassTestInterceptorimplementsInterceptor</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     Object target = invocation. getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">     Method method = invocation. getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">     Object[] args = invocation. getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">     <span class="comment">// do something . . . . . .  方法拦截前执行代码块</span></span><br><span class="line">     Object result = invocation. proceed();</span><br><span class="line">     <span class="comment">// do something . . . . . . . 方法拦截后执行代码块</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Plugin. wrap(target, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="135-RabbitMQ-的使用场景有哪些？"><a href="#135-RabbitMQ-的使用场景有哪些？" class="headerlink" title="135. RabbitMQ 的使用场景有哪些？"></a>135. RabbitMQ 的使用场景有哪些？</h4><ul>
<li>抢购活动，削峰填谷，防止系统崩塌。</li>
<li>延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</li>
<li>解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</li>
</ul>
<h4 id="136-RabbitMQ-有哪些重要的角色？"><a href="#136-RabbitMQ-有哪些重要的角色？" class="headerlink" title="136. RabbitMQ 有哪些重要的角色？"></a>136. RabbitMQ 有哪些重要的角色？</h4><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<ul>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h4 id="137-RabbitMQ-有哪些重要的组件？"><a href="#137-RabbitMQ-有哪些重要的组件？" class="headerlink" title="137. RabbitMQ 有哪些重要的组件？"></a>137. RabbitMQ 有哪些重要的组件？</h4><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
<h4 id="138-RabbitMQ-中-vhost-的作用是什么？"><a href="#138-RabbitMQ-中-vhost-的作用是什么？" class="headerlink" title="138. RabbitMQ 中 vhost 的作用是什么？"></a>138. RabbitMQ 中 vhost 的作用是什么？</h4><p>vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h4 id="139-RabbitMQ-的消息是怎么发送的？"><a href="#139-RabbitMQ-的消息是怎么发送的？" class="headerlink" title="139. RabbitMQ 的消息是怎么发送的？"></a>139. RabbitMQ 的消息是怎么发送的？</h4><p>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h4 id="140-RabbitMQ-怎么保证消息的稳定性？"><a href="#140-RabbitMQ-怎么保证消息的稳定性？" class="headerlink" title="140. RabbitMQ 怎么保证消息的稳定性？"></a>140. RabbitMQ 怎么保证消息的稳定性？</h4><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
<h4 id="141-RabbitMQ-怎么避免消息丢失？"><a href="#141-RabbitMQ-怎么避免消息丢失？" class="headerlink" title="141. RabbitMQ 怎么避免消息丢失？"></a>141. RabbitMQ 怎么避免消息丢失？</h4><ul>
<li>把消息持久化磁盘，保证服务器重启消息不丢失。</li>
<li>每个集群中至少有一个物理磁盘，保证消息落入磁盘。</li>
</ul>
<h4 id="142-要保证消息持久化成功的条件有哪些？"><a href="#142-要保证消息持久化成功的条件有哪些？" class="headerlink" title="142. 要保证消息持久化成功的条件有哪些？"></a>142. 要保证消息持久化成功的条件有哪些？</h4><ul>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
</ul>
<p>以上四个条件都满足才能保证消息持久化成功。</p>
<h4 id="143-RabbitMQ-持久化有什么缺点？"><a href="#143-RabbitMQ-持久化有什么缺点？" class="headerlink" title="143. RabbitMQ 持久化有什么缺点？"></a>143. RabbitMQ 持久化有什么缺点？</h4><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h4 id="144-RabbitMQ-有几种广播类型？"><a href="#144-RabbitMQ-有几种广播类型？" class="headerlink" title="144. RabbitMQ 有几种广播类型？"></a>144. RabbitMQ 有几种广播类型？</h4><ul>
<li>direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</li>
<li>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</li>
<li>fanout：分发模式，把消费分发给所有订阅者。</li>
<li>topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</li>
</ul>
<h4 id="145-RabbitMQ-怎么实现延迟消息队列？"><a href="#145-RabbitMQ-怎么实现延迟消息队列？" class="headerlink" title="145. RabbitMQ 怎么实现延迟消息队列？"></a>145. RabbitMQ 怎么实现延迟消息队列？</h4><p>延迟队列的实现有两种方式：</p>
<ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
<h4 id="146-RabbitMQ-集群有什么用？"><a href="#146-RabbitMQ-集群有什么用？" class="headerlink" title="146. RabbitMQ 集群有什么用？"></a>146. RabbitMQ 集群有什么用？</h4><p>集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h4 id="147-RabbitMQ-节点的类型有哪些？"><a href="#147-RabbitMQ-节点的类型有哪些？" class="headerlink" title="147. RabbitMQ 节点的类型有哪些？"></a>147. RabbitMQ 节点的类型有哪些？</h4><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
<h4 id="148-RabbitMQ-集群搭建需要注意哪些问题？"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？" class="headerlink" title="148. RabbitMQ 集群搭建需要注意哪些问题？"></a>148. RabbitMQ 集群搭建需要注意哪些问题？</h4><ul>
<li>各节点之间使用“–link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
<h4 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a>149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h4><p>不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
<h4 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h4><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<h4 id="151-RabbitMQ-对集群节点停止顺序有要求吗？"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？" class="headerlink" title="151. RabbitMQ 对集群节点停止顺序有要求吗？"></a>151. RabbitMQ 对集群节点停止顺序有要求吗？</h4><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="152. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h4><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
<h4 id="153-kafka-有几种数据保留的策略？"><a href="#153-kafka-有几种数据保留的策略？" class="headerlink" title="153. kafka 有几种数据保留的策略？"></a>153. kafka 有几种数据保留的策略？</h4><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
<h4 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h4><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
<h4 id="155-什么情况会导致-kafka-运行变慢？"><a href="#155-什么情况会导致-kafka-运行变慢？" class="headerlink" title="155. 什么情况会导致 kafka 运行变慢？"></a>155. 什么情况会导致 kafka 运行变慢？</h4><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h4 id="156-使用-kafka-集群需要注意什么？"><a href="#156-使用-kafka-集群需要注意什么？" class="headerlink" title="156. 使用 kafka 集群需要注意什么？"></a>156. 使用 kafka 集群需要注意什么？</h4><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h4 id="157-zookeeper-是什么？"><a href="#157-zookeeper-是什么？" class="headerlink" title="157. zookeeper 是什么？"></a>157. zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h4 id="158-zookeeper-都有哪些功能？"><a href="#158-zookeeper-都有哪些功能？" class="headerlink" title="158. zookeeper 都有哪些功能？"></a>158. zookeeper 都有哪些功能？</h4><ul>
<li>集群管理：监控节点存活状态、运行请求等。</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
<h4 id="159-zookeeper-有几种部署模式？"><a href="#159-zookeeper-有几种部署模式？" class="headerlink" title="159. zookeeper 有几种部署模式？"></a>159. zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p>
<ul>
<li>单机部署：一台集群上运行；</li>
<li>集群部署：多台集群运行；</li>
<li>伪集群部署：一台集群启动多个 zookeeper 实例运行。</li>
</ul>
<h4 id="160-zookeeper-怎么保证主从节点的状态同步？"><a href="#160-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="160. zookeeper 怎么保证主从节点的状态同步？"></a>160. zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h4 id="161-集群中为什么要有主节点？"><a href="#161-集群中为什么要有主节点？" class="headerlink" title="161. 集群中为什么要有主节点？"></a>161. 集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
<h4 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？" class="headerlink" title="162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a>162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
<h4 id="163-说一下-zookeeper-的通知机制？"><a href="#163-说一下-zookeeper-的通知机制？" class="headerlink" title="163. 说一下 zookeeper 的通知机制？"></a>163. 说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="164-数据库的三范式是什么？"><a href="#164-数据库的三范式是什么？" class="headerlink" title="164. 数据库的三范式是什么？"></a>164. 数据库的三范式是什么？</h4><ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<h4 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？" class="headerlink" title="165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a>165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</h4><ul>
<li>表类型如果是 MyISAM ，那 id 就是 8。</li>
<li>表类型如果是 InnoDB，那 id 就是 6。</li>
</ul>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h4 id="166-如何获取当前数据库版本？"><a href="#166-如何获取当前数据库版本？" class="headerlink" title="166. 如何获取当前数据库版本？"></a>166. 如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h4 id="167-说一下-ACID-是什么？"><a href="#167-说一下-ACID-是什么？" class="headerlink" title="167. 说一下 ACID 是什么？"></a>167. 说一下 ACID 是什么？</h4><ul>
<li>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h4 id="168-char-和-varchar-的区别是什么？"><a href="#168-char-和-varchar-的区别是什么？" class="headerlink" title="168. char 和 varchar 的区别是什么？"></a>168. char 和 varchar 的区别是什么？</h4><ul>
<li><strong>char(n)</strong> ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</li>
</ul>
<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<ul>
<li><strong>varchar(n)</strong> ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</li>
</ul>
<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h4 id="169-float-和-double-的区别是什么？"><a href="#169-float-和-double-的区别是什么？" class="headerlink" title="169. float 和 double 的区别是什么？"></a>169. float 和 double 的区别是什么？</h4><ul>
<li>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</li>
<li>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</li>
</ul>
<h4 id="170-MySQL-的内连接、左连接、右连接有什么区别？"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？" class="headerlink" title="170. MySQL 的内连接、左连接、右连接有什么区别？"></a>170. MySQL 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h4 id="171-MySQL-索引是怎么实现的？"><a href="#171-MySQL-索引是怎么实现的？" class="headerlink" title="171. MySQL 索引是怎么实现的？"></a>171. MySQL 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h4 id="172-怎么验证-MySQL-的索引是否满足需求？"><a href="#172-怎么验证-MySQL-的索引是否满足需求？" class="headerlink" title="172. 怎么验证 MySQL 的索引是否满足需求？"></a>172. 怎么验证 MySQL 的索引是否满足需求？</h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h4 id="173-说一下数据库的事务隔离？"><a href="#173-说一下数据库的事务隔离？" class="headerlink" title="173. 说一下数据库的事务隔离？"></a>173. 说一下数据库的事务隔离？</h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>
<blockquote>
<p>transaction-isolation = REPEATABLE-READ</p>
</blockquote>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<ul>
<li>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</li>
<li>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</li>
<li>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li>
</ul>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="174-说一下-MySQL-常用的引擎？"><a href="#174-说一下-MySQL-常用的引擎？" class="headerlink" title="174. 说一下 MySQL 常用的引擎？"></a>174. 说一下 MySQL 常用的引擎？</h4><ul>
<li>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li>
<li>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li>
</ul>
<h4 id="175-说一下-MySQL-的行锁和表锁？"><a href="#175-说一下-MySQL-的行锁和表锁？" class="headerlink" title="175. 说一下 MySQL 的行锁和表锁？"></a>175. 说一下 MySQL 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<ul>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h4 id="176-说一下乐观锁和悲观锁？"><a href="#176-说一下乐观锁和悲观锁？" class="headerlink" title="176. 说一下乐观锁和悲观锁？"></a>176. 说一下乐观锁和悲观锁？</h4><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>
</ul>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h4 id="177-MySQL-问题排查都有哪些手段？"><a href="#177-MySQL-问题排查都有哪些手段？" class="headerlink" title="177. MySQL 问题排查都有哪些手段？"></a>177. MySQL 问题排查都有哪些手段？</h4><ul>
<li>使用 show processlist 命令查看当前所有连接信息。</li>
<li>使用 explain 命令查询 SQL 语句执行计划。</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h4 id="178-如何做-MySQL-的性能优化？"><a href="#178-如何做-MySQL-的性能优化？" class="headerlink" title="178. 如何做 MySQL 的性能优化？"></a>178. 如何做 MySQL 的性能优化？</h4><ul>
<li>为搜索字段创建索引。</li>
<li>避免使用 select *，列出需要查询的字段。</li>
<li>垂直分割分表。</li>
<li>选择正确的存储引擎。</li>
</ul>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="179-Redis-是什么？都有哪些使用场景？"><a href="#179-Redis-是什么？都有哪些使用场景？" class="headerlink" title="179. Redis 是什么？都有哪些使用场景？"></a>179. Redis 是什么？都有哪些使用场景？</h4><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>
<p>Redis 使用场景：</p>
<ul>
<li>记录帖子点赞数、点击数、评论数；</li>
<li>缓存近期热帖；</li>
<li>缓存文章详情信息；</li>
<li>记录用户会话信息。</li>
</ul>
<h4 id="180-Redis-有哪些功能？"><a href="#180-Redis-有哪些功能？" class="headerlink" title="180. Redis 有哪些功能？"></a>180. Redis 有哪些功能？</h4><ul>
<li>数据缓存功能</li>
<li>分布式锁的功能</li>
<li>支持数据持久化</li>
<li>支持事务</li>
<li>支持消息队列</li>
</ul>
<h4 id="181-Redis-和-memcache-有什么区别？"><a href="#181-Redis-和-memcache-有什么区别？" class="headerlink" title="181. Redis 和 memcache 有什么区别？"></a>181. Redis 和 memcache 有什么区别？</h4><ul>
<li>存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</li>
<li>数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</li>
<li>使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
<li>value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</li>
</ul>
<h4 id="182-Redis-为什么是单线程的？"><a href="#182-Redis-为什么是单线程的？" class="headerlink" title="182. Redis 为什么是单线程的？"></a>182. Redis 为什么是单线程的？</h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h4 id="183-什么是缓存穿透？怎么解决？"><a href="#183-什么是缓存穿透？怎么解决？" class="headerlink" title="183. 什么是缓存穿透？怎么解决？"></a>183. 什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4 id="184-Redis-支持的数据类型有哪些？"><a href="#184-Redis-支持的数据类型有哪些？" class="headerlink" title="184. Redis 支持的数据类型有哪些？"></a>184. Redis 支持的数据类型有哪些？</h4><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>
<h4 id="185-Redis-支持的-Java-客户端都有哪些？"><a href="#185-Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="185. Redis 支持的 Java 客户端都有哪些？"></a>185. Redis 支持的 Java 客户端都有哪些？</h4><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>
<h4 id="186-jedis-和-Redisson-有哪些区别？"><a href="#186-jedis-和-Redisson-有哪些区别？" class="headerlink" title="186. jedis 和 Redisson 有哪些区别？"></a>186. jedis 和 Redisson 有哪些区别？</h4><ul>
<li>jedis：提供了比较全面的 Redis 命令的支持。</li>
<li>Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</li>
</ul>
<h4 id="187-怎么保证缓存和数据库数据的一致性？"><a href="#187-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="187. 怎么保证缓存和数据库数据的一致性？"></a>187. 怎么保证缓存和数据库数据的一致性？</h4><ul>
<li>合理设置缓存的过期时间。</li>
<li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li>
</ul>
<h4 id="188-Redis-持久化有几种方式？"><a href="#188-Redis-持久化有几种方式？" class="headerlink" title="188. Redis 持久化有几种方式？"></a>188. Redis 持久化有几种方式？</h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<ul>
<li>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</li>
<li>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</li>
</ul>
<h4 id="189-Redis-怎么实现分布式锁？"><a href="#189-Redis-怎么实现分布式锁？" class="headerlink" title="189. Redis 怎么实现分布式锁？"></a>189. Redis 怎么实现分布式锁？</h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
<h4 id="190-Redis-分布式锁有什么缺陷？"><a href="#190-Redis-分布式锁有什么缺陷？" class="headerlink" title="190. Redis 分布式锁有什么缺陷？"></a>190. Redis 分布式锁有什么缺陷？</h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h4 id="191-Redis-如何做内存优化？"><a href="#191-Redis-如何做内存优化？" class="headerlink" title="191. Redis 如何做内存优化？"></a>191. Redis 如何做内存优化？</h4><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h4 id="192-Redis-淘汰策略有哪些？"><a href="#192-Redis-淘汰策略有哪些？" class="headerlink" title="192. Redis 淘汰策略有哪些？"></a>192. Redis 淘汰策略有哪些？</h4><ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<h4 id="193-Redis-常见的性能问题有哪些？该如何解决？"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="193. Redis 常见的性能问题有哪些？该如何解决？"></a>193. Redis 常见的性能问题有哪些？该如何解决？</h4><ul>
<li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</li>
<li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li>
</ul>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="194-说一下-JVM-的主要组成部分？及其作用？"><a href="#194-说一下-JVM-的主要组成部分？及其作用？" class="headerlink" title="194. 说一下 JVM 的主要组成部分？及其作用？"></a>194. 说一下 JVM 的主要组成部分？及其作用？</h4><ul>
<li>类加载器（ClassLoader）</li>
<li>运行时数据区（Runtime Data Area）</li>
<li>执行引擎（Execution Engine）</li>
<li>本地库接口（Native Interface）</li>
</ul>
<p><strong>组件的作用：</strong> 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h4 id="195-说一下-JVM-运行时数据区？"><a href="#195-说一下-JVM-运行时数据区？" class="headerlink" title="195. 说一下 JVM 运行时数据区？"></a>195. 说一下 JVM 运行时数据区？</h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<ul>
<li>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</li>
<li>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</li>
<li>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</li>
<li>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</li>
<li>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li>
</ul>
<h4 id="196-说一下堆栈的区别？"><a href="#196-说一下堆栈的区别？" class="headerlink" title="196. 说一下堆栈的区别？"></a>196. 说一下堆栈的区别？</h4><ul>
<li>功能方面：堆是用来存放对象的，栈是用来执行程序的。</li>
<li>共享性：堆是线程共享的，栈是线程私有的。</li>
<li>空间大小：堆大小远远大于栈。</li>
</ul>
<h4 id="197-队列和栈是什么？有什么区别？"><a href="#197-队列和栈是什么？有什么区别？" class="headerlink" title="197. 队列和栈是什么？有什么区别？"></a>197. 队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。</p>
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p>
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h4 id="198-什么是双亲委派模型？"><a href="#198-什么是双亲委派模型？" class="headerlink" title="198. 什么是双亲委派模型？"></a>198. 什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li>
<li>其他类加载器：</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载<java_home style="box-sizing: border-box; outline: 0px !important;">\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home></li>
<li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li>
</ul>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h4 id="199-说一下类装载的执行过程？"><a href="#199-说一下类装载的执行过程？" class="headerlink" title="199. 说一下类装载的执行过程？"></a>199. 说一下类装载的执行过程？</h4><p>类装载分为以下 5 个步骤：</p>
<ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>检查：检查加载的 class 文件的正确性；</li>
<li>准备：给类中的静态变量分配内存空间；</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作。</li>
</ul>
<h4 id="200-怎么判断对象是否可以被回收？"><a href="#200-怎么判断对象是否可以被回收？" class="headerlink" title="200. 怎么判断对象是否可以被回收？"></a>200. 怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p>
<ul>
<li>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</li>
<li>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li>
</ul>
<h4 id="201-Java-中都有哪些引用类型？"><a href="#201-Java-中都有哪些引用类型？" class="headerlink" title="201. Java 中都有哪些引用类型？"></a>201. Java 中都有哪些引用类型？</h4><ul>
<li>强引用：发生 gc 的时候不会被回收。</li>
<li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li>
<li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li>
<li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li>
</ul>
<h4 id="202-说一下-JVM-有哪些垃圾回收算法？"><a href="#202-说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="202. 说一下 JVM 有哪些垃圾回收算法？"></a>202. 说一下 JVM 有哪些垃圾回收算法？</h4><ul>
<li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li>
<li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li>
<li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li>
<li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li>
</ul>
<h4 id="203-说一下-JVM-有哪些垃圾回收器？"><a href="#203-说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="203. 说一下 JVM 有哪些垃圾回收器？"></a>203. 说一下 JVM 有哪些垃圾回收器？</h4><ul>
<li>Serial：最早的单线程串行垃圾回收器。</li>
<li>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</li>
<li>ParNew：是 Serial 的多线程版本。</li>
<li>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</li>
<li>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</li>
<li>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</li>
<li>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</li>
</ul>
<h4 id="204-详细介绍一下-CMS-垃圾回收器？"><a href="#204-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="204. 详细介绍一下 CMS 垃圾回收器？"></a>204. 详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h4 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS</li>
<li>整堆回收器：G1</li>
</ul>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h4 id="206-简述分代垃圾回收器是怎么工作的？"><a href="#206-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="206. 简述分代垃圾回收器是怎么工作的？"></a>206. 简述分代垃圾回收器是怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<ul>
<li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</li>
<li>清空 Eden 和 From Survivor 分区；</li>
<li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li>
</ul>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h4 id="207-说一下-JVM-调优的工具？"><a href="#207-说一下-JVM-调优的工具？" class="headerlink" title="207. 说一下 JVM 调优的工具？"></a>207. 说一下 JVM 调优的工具？</h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
<h4 id="208-常用的-JVM-调优的参数都有哪些？"><a href="#208-常用的-JVM-调优的参数都有哪些？" class="headerlink" title="208. 常用的 JVM 调优的参数都有哪些？"></a>208. 常用的 JVM 调优的参数都有哪些？</h4><ul>
<li>-Xms2g：初始化推大小为 2g；</li>
<li>-Xmx2g：堆最大内存为 2g；</li>
<li>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</li>
<li>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</li>
<li>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</li>
<li>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</li>
<li>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</li>
<li>-XX:+PrintGC：开启打印 gc 信息；</li>
<li>-XX:+PrintGCDetails：打印 gc 详细信息。</li>
</ul>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这不止是一份面试清单，更是一种“被期望的责任”，因为有无数个待面试着，希望从这篇文章中，找出通往期望公司的“钥匙”，所以上面的每道选题都是结合我自身的经验，于千万个面试题中经过艰辛的两周，一个题一个题筛选出来再校对好答案和格式做出来的，面试的答案也是再三斟酌，生怕误人子弟是小，影响他人的“仕途”才是大过，所以如有纰漏，还请读者朋友们在评论区不吝指出。</p>
<p>也希望您能把这篇文章分享给更多的朋友，让它帮助更多的人。</p>
<p>帮助他人，快乐自己，最后，感谢您的阅读。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><p><img alt="img" data-src> </p>
<p>共包含 208 道面试题，本文的宗旨是为读者朋友们整理一份详实而又权威的面试清单，下面一起进入主题吧。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><h3 id="-2"><a href="#-2" class="headerlink" title></a></h3><h3 id="Java-基础-1"><a href="#Java-基础-1" class="headerlink" title="Java 基础"></a><strong>Java 基础</strong></h3><h4 id="1-JDK-和-JRE-有什么区别？-1"><a href="#1-JDK-和-JRE-有什么区别？-1" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a><strong>1. JDK 和 JRE 有什么区别？</strong></h4><p>· JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</p>
<p>· JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</p>
<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p>
<h4 id="2-和-equals-的区别是什么？-1"><a href="#2-和-equals-的区别是什么？-1" class="headerlink" title="2. == 和 equals 的区别是什么？"></a><strong>2. == 和 equals 的区别是什么？</strong></h4><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>
<p>· 基本类型：比较的是值是否相同；</p>
<p>· 引用类型：比较的是引用是否相同；</p>
<p>代码示例：</p>
<p>String x = “string”;</p>
<p>String y = “string”;</p>
<p>String z = new String(“string”);</p>
<p>System.out.println(x==y); // true</p>
<p>System.out.println(x==z); // false</p>
<p>System.out.println(x.equals(y)); // true</p>
<p>System.out.println(x.equals(z)); // true</p>
<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>
<p><strong>equals 解读</strong></p>
<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：class Cat {</p>
<p>​    public Cat(String name) {</p>
<p>​        this.name = name;}</p>
<p>​    private String name;</p>
<p>​    public String getName() {</p>
<p>​        return name; }</p>
<p>​    public void setName(String name) {</p>
<p>​        this.name = name;</p>
<p>​    }</p>
<p>Cat c1 = new Cat(“王磊”);</p>
<p>Cat c2 = new Cat(“王磊”);</p>
<p>System.out.println(c1.equals(c2)); // false</p>
<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<p>public boolean equals(Object obj) {</p>
<p>​        return (this == obj);}}</p>
<p>原来 equals 本质上就是 ==。</p>
<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>
<p>String s1 = new String(“老王”);</p>
<p>String s2 = new String(“老王”);</p>
<p>System.out.println(s1.equals(s2)); // true</p>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<p>public boolean equals(Object anObject) {</p>
<p>​    if (this == anObject) {</p>
<p>​        return true; }</p>
<p>​    if (anObject instanceof String) {</p>
<p>​        String anotherString = (String)anObject;</p>
<p>​        int n = value.length;</p>
<p>​        if (n == anotherString.value.length) {</p>
<p>​            char v1[] = value;</p>
<p>​            char v2[] = anotherString.value;</p>
<p>​            int i = 0;</p>
<p>​            while (n– != 0) {</p>
<p>​                if (v1[i] != v2[i])</p>
<p>​                    return false;</p>
<p>​                i++;}</p>
<p>​            return true;    }  }</p>
<p>​    return false;}</p>
<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>
<h4 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？-1"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？-1" class="headerlink" title="3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a><strong>3. 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</strong></h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p>
<p>代码示例：</p>
<p>String str1 = “通话”;</p>
<p>String str2 = “重地”;</p>
<p>System. out. println(String. format(“str1：%d | str2：%d”,  str1. hashCode(),str2. hashCode()));</p>
<p>System. out. println(str1. equals(str2));</p>
<p>执行的结果：</p>
<p>str1：1179395 | str2：1179395</p>
<p>false</p>
<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>
<h4 id="4-final-在-Java-中有什么作用？-1"><a href="#4-final-在-Java-中有什么作用？-1" class="headerlink" title="4. final 在 Java 中有什么作用？"></a><strong>4. final 在 Java 中有什么作用？</strong></h4><p>· final 修饰的类叫最终类，该类不能被继承。</p>
<p>· final 修饰的方法不能被重写。</p>
<p>· final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>
<h4 id="5-Java-中的-Math-round-1-5-等于多少？-1"><a href="#5-Java-中的-Math-round-1-5-等于多少？-1" class="headerlink" title="5. Java 中的 Math. round(-1. 5) 等于多少？"></a><strong>5. Java 中的 Math. round(-1. 5) 等于多少？</strong></h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p>
<h4 id="6-String-属于基础的数据类型吗？-1"><a href="#6-String-属于基础的数据类型吗？-1" class="headerlink" title="6. String 属于基础的数据类型吗？"></a><strong>6. String 属于基础的数据类型吗？</strong></h4><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p>
<h4 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？-1"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？-1" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a><strong>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</strong></h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>
<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>
<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>
<h4 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？-1"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？-1" class="headerlink" title="8. String str=”i”与 String str=new String(“i”)一样吗？"></a><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>
<h4 id="9-如何将字符串反转？-1"><a href="#9-如何将字符串反转？-1" class="headerlink" title="9. 如何将字符串反转？"></a><strong>9. 如何将字符串反转？</strong></h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
<p>示例代码：</p>
<p><em>// StringBuffer reverse</em></p>
<p>StringBuffer stringBuffer = <strong>new</strong> StringBuffer();</p>
<p>stringBuffer. append(“abcdefg”);</p>
<p>System. out. println(stringBuffer. reverse()); <em>// gfedcba// StringBuilder reverse</em></p>
<p>StringBuilder stringBuilder = <strong>new</strong> StringBuilder();</p>
<p>stringBuilder. append(“abcdefg”);</p>
<p>System. out. println(stringBuilder. reverse()); <em>// gfedcba</em></p>
<h4 id="10-String-类的常用方法都有那些？-1"><a href="#10-String-类的常用方法都有那些？-1" class="headerlink" title="10. String 类的常用方法都有那些？"></a><strong>10. String 类的常用方法都有那些？</strong></h4><p>· indexOf()：返回指定字符的索引。</p>
<p>· charAt()：返回指定索引处的字符。</p>
<p>· replace()：字符串替换。</p>
<p>· trim()：去除字符串两端空白。</p>
<p>· split()：分割字符串，返回一个分割后的字符串数组。</p>
<p>· getBytes()：返回字符串的 byte 类型数组。</p>
<p>· length()：返回字符串长度。</p>
<p>· toLowerCase()：将字符串转成小写字母。</p>
<p>· toUpperCase()：将字符串转成大写字符。</p>
<p>· substring()：截取字符串。</p>
<p>· equals()：字符串比较。</p>
<h4 id="11-抽象类必须要有抽象方法吗？-1"><a href="#11-抽象类必须要有抽象方法吗？-1" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a><strong>11. 抽象类必须要有抽象方法吗？</strong></h4><p>不需要，抽象类不一定非要有抽象方法。</p>
<p>示例代码：</p>
<p><strong>abstract</strong> <strong>class</strong> <strong>Cat</strong> {</p>
<p>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>sayHi</strong>() {</p>
<p>​        System. out. println(“hi~”);</p>
<p>​    }</p>
<p>}</p>
<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>
<h4 id="12-普通类和抽象类有哪些区别？-1"><a href="#12-普通类和抽象类有哪些区别？-1" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a><strong>12. 普通类和抽象类有哪些区别？</strong></h4><p>· 普通类不能包含抽象方法，抽象类可以包含抽象方法。</p>
<p>· 抽象类不能直接实例化，普通类可以直接实例化。</p>
<h4 id="13-抽象类能使用-final-修饰吗？-1"><a href="#13-抽象类能使用-final-修饰吗？-1" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a><strong>13. 抽象类能使用 final 修饰吗？</strong></h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p>
<p><img alt="img" data-src> </p>
<h4 id="14-接口和抽象类有什么区别？-1"><a href="#14-接口和抽象类有什么区别？-1" class="headerlink" title="14. 接口和抽象类有什么区别？"></a><strong>14. 接口和抽象类有什么区别？</strong></h4><p>· 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p>
<p>· 构造函数：抽象类可以有构造函数；接口不能有。</p>
<p>· 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p>
<p>· 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>
<h4 id="15-Java-中-IO-流分为几种？-1"><a href="#15-Java-中-IO-流分为几种？-1" class="headerlink" title="15. Java 中 IO 流分为几种？"></a><strong>15. Java 中 IO 流分为几种？</strong></h4><p>按功能来分：输入流（input）、输出流（output）。</p>
<p>按类型来分：字节流和字符流。</p>
<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>
<h4 id="16-BIO、NIO、AIO-有什么区别？-1"><a href="#16-BIO、NIO、AIO-有什么区别？-1" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a><strong>16. BIO、NIO、AIO 有什么区别？</strong></h4><p>· BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>
<p>· NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>
<p>· AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
<h4 id="17-Files的常用方法都有哪些？-1"><a href="#17-Files的常用方法都有哪些？-1" class="headerlink" title="17. Files的常用方法都有哪些？"></a><strong>17. Files的常用方法都有哪些？</strong></h4><p>· Files. exists()：检测文件路径是否存在。</p>
<p>· Files. createFile()：创建文件。</p>
<p>· Files. createDirectory()：创建文件夹。</p>
<p>· Files. delete()：删除一个文件或目录。</p>
<p>· Files. copy()：复制文件。</p>
<p>· Files. move()：移动文件。</p>
<p>· Files. size()：查看文件个数。</p>
<p>· Files. read()：读取文件。</p>
<p>· Files. write()：写入文件。</p>
<h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a><strong>容器</strong></h3><h4 id="18-Java-容器都有哪些？-1"><a href="#18-Java-容器都有哪些？-1" class="headerlink" title="18. Java 容器都有哪些？"></a><strong>18. Java 容器都有哪些？</strong></h4><p>· Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p>
<p>· Collection</p>
<p>· List</p>
<p>· ArrayList</p>
<p>· LinkedList</p>
<p>· Vector</p>
<p>· Stack</p>
<p>· Set</p>
<p>· HashSet</p>
<p>· LinkedHashSet</p>
<p>· TreeSet</p>
<p>· Map</p>
<p>· HashMap</p>
<p>· LinkedHashMap</p>
<p>· TreeMap</p>
<p>· ConcurrentHashMap</p>
<p>· Hashtable</p>
<h4 id="19-Collection-和-Collections-有什么区别？-1"><a href="#19-Collection-和-Collections-有什么区别？-1" class="headerlink" title="19. Collection 和 Collections 有什么区别？"></a><strong>19. Collection 和 Collections 有什么区别？</strong></h4><p>· Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</p>
<p>· Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p>
<h4 id="20-List、Set、Map-之间的区别是什么？-1"><a href="#20-List、Set、Map-之间的区别是什么？-1" class="headerlink" title="20. List、Set、Map 之间的区别是什么？"></a><strong>20. List、Set、Map 之间的区别是什么？</strong></h4><p>· List、Set、Map 的区别主要体现在两个方面：元素是否有序、是否允许元素重复。</p>
<p>· 三者之间的区别，如下表：</p>
<p><img alt="img" data-src> </p>
<h4 id="21-HashMap-和-Hashtable-有什么区别？-1"><a href="#21-HashMap-和-Hashtable-有什么区别？-1" class="headerlink" title="21. HashMap 和 Hashtable 有什么区别？"></a><strong>21. HashMap 和 Hashtable 有什么区别？</strong></h4><p>· 存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。</p>
<p>· 线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</p>
<p>· 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</p>
<h4 id="22-如何决定使用-HashMap-还是-TreeMap？-1"><a href="#22-如何决定使用-HashMap-还是-TreeMap？-1" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a><strong>22. 如何决定使用 HashMap 还是 TreeMap？</strong></h4><p>对于在 Map 中插入、删除、定位一个元素这类操作，HashMap 是最好的选择，因为相对而言 HashMap 的插入会更快，但如果你要对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择。</p>
<h4 id="23-说一下-HashMap-的实现原理？-1"><a href="#23-说一下-HashMap-的实现原理？-1" class="headerlink" title="23. 说一下 HashMap 的实现原理？"></a><strong>23. 说一下 HashMap 的实现原理？</strong></h4><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p>
<h4 id="24-说一下-HashSet-的实现原理？-1"><a href="#24-说一下-HashSet-的实现原理？-1" class="headerlink" title="24. 说一下 HashSet 的实现原理？"></a><strong>24. 说一下 HashSet 的实现原理？</strong></h4><p>HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p>
<h4 id="25-ArrayList-和-LinkedList-的区别是什么？-1"><a href="#25-ArrayList-和-LinkedList-的区别是什么？-1" class="headerlink" title="25. ArrayList 和 LinkedList 的区别是什么？"></a><strong>25. ArrayList 和 LinkedList 的区别是什么？</strong></h4><p>· 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</p>
<p>· 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
<p>· 增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
<h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h4 id="-4"><a href="#-4" class="headerlink" title></a></h4><h4 id="26-如何实现数组和-List-之间的转换？-1"><a href="#26-如何实现数组和-List-之间的转换？-1" class="headerlink" title="26. 如何实现数组和 List 之间的转换？"></a><strong>26. 如何实现数组和 List 之间的转换？</strong></h4><p>· 数组转 List：使用 Arrays. asList(array) 进行转换。</p>
<p>· List 转数组：使用 List 自带的 toArray() 方法。</p>
<p>代码示例：</p>
<p><em>// list to array</em></p>
<p>List<string> list = <strong>new</strong> ArrayList<string>();</string></string></p>
<p>list. add(“王磊”);</p>
<p>list. add(“的博客”);</p>
<p>list. toArray();<em>// array to list</em></p>
<p>String[] array = <strong>new</strong> String[]{“王磊”,”的博客”};</p>
<p>Arrays. asList(array);</p>
<h4 id="27-ArrayList-和-Vector-的区别是什么？-1"><a href="#27-ArrayList-和-Vector-的区别是什么？-1" class="headerlink" title="27. ArrayList 和 Vector 的区别是什么？"></a><strong>27. ArrayList 和 Vector 的区别是什么？</strong></h4><p>· 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</p>
<p>· 性能：ArrayList 在性能方面要优于 Vector。</p>
<p>· 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p>
<h4 id="28-Array-和-ArrayList-有何区别？-1"><a href="#28-Array-和-ArrayList-有何区别？-1" class="headerlink" title="28. Array 和 ArrayList 有何区别？"></a><strong>28. Array 和 ArrayList 有何区别？</strong></h4><p>· Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p>
<p>· Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p>
<p>· Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p>
<h4 id="29-在-Queue-中-poll-和-remove-有什么区别？-1"><a href="#29-在-Queue-中-poll-和-remove-有什么区别？-1" class="headerlink" title="29. 在 Queue 中 poll()和 remove()有什么区别？"></a><strong>29. 在 Queue 中 poll()和 remove()有什么区别？</strong></h4><p>· 相同点：都是返回第一个元素，并在队列中删除返回的对象。</p>
<p>· 不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</p>
<p>代码示例：</p>
<p>Queue<string> queue = <strong>new</strong> LinkedList<string>();</string></string></p>
<p>queue. offer(“string”); <em>// add</em></p>
<p>System. out. println(queue. poll());</p>
<p>System. out. println(queue. remove());</p>
<p>System. out. println(queue. size());</p>
<h4 id="30-哪些集合类是线程安全的？-1"><a href="#30-哪些集合类是线程安全的？-1" class="headerlink" title="30. 哪些集合类是线程安全的？"></a><strong>30. 哪些集合类是线程安全的？</strong></h4><p>· Vector、Hashtable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的，不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。</p>
<h4 id="31-迭代器-Iterator-是什么？-1"><a href="#31-迭代器-Iterator-是什么？-1" class="headerlink" title="31. 迭代器 Iterator 是什么？"></a><strong>31. 迭代器 Iterator 是什么？</strong></h4><p>· Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p>
<h4 id="32-Iterator-怎么使用？有什么特点？-1"><a href="#32-Iterator-怎么使用？有什么特点？-1" class="headerlink" title="32. Iterator 怎么使用？有什么特点？"></a><strong>32. Iterator 怎么使用？有什么特点？</strong></h4><p>Iterator 使用代码如下：</p>
<p>List<string> list = <strong>new</strong> ArrayList&lt;&gt;();</string></p>
<p>Iterator<string> it = list. iterator();<strong>while</strong>(it. hasNext()){</string></p>
<p>  String obj = it. next();</p>
<p>  System. out. println(obj);</p>
<p>}</p>
<p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
<h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><h4 id="33-Iterator-和-ListIterator-有什么区别？-1"><a href="#33-Iterator-和-ListIterator-有什么区别？-1" class="headerlink" title="33. Iterator 和 ListIterator 有什么区别？"></a><strong>33. Iterator 和 ListIterator 有什么区别？</strong></h4><p>· Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</p>
<p>· Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</p>
<p>· ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<h4 id="34-怎么确保一个集合不能被修改？-1"><a href="#34-怎么确保一个集合不能被修改？-1" class="headerlink" title="34. 怎么确保一个集合不能被修改？"></a><strong>34. 怎么确保一个集合不能被修改？</strong></h4><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
<p>示例代码如下：</p>
<p>List<string> list = <strong>new</strong> ArrayList&lt;&gt;();</string></p>
<p>list. add(“x”);</p>
<p>Collection<string> clist = Collections. unmodifiableCollection(list);</string></p>
<p>clist. add(“y”); <em>// 运行时此行报错</em></p>
<p>System. out. println(list. size());</p>
<h3 id="-6"><a href="#-6" class="headerlink" title></a></h3><h3 id="-7"><a href="#-7" class="headerlink" title></a></h3><h3 id="-8"><a href="#-8" class="headerlink" title></a></h3><h3 id="-9"><a href="#-9" class="headerlink" title></a></h3><h3 id="-10"><a href="#-10" class="headerlink" title></a></h3><h3 id="-11"><a href="#-11" class="headerlink" title></a></h3><h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a><strong>多线程</strong></h3><h4 id="35-并行和并发有什么区别？-1"><a href="#35-并行和并发有什么区别？-1" class="headerlink" title="35. 并行和并发有什么区别？"></a><strong>35. 并行和并发有什么区别？</strong></h4><p>· 并行：多个处理器或多核处理器同时处理多个任务。</p>
<p>· 并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。</p>
<p>如下图：</p>
<p><img alt="img" data-src> </p>
<p>· 并发 = 两个队列和一台咖啡机。</p>
<p>· 并行 = 两个队列和两台咖啡机。</p>
<h4 id="36-线程和进程的区别？-1"><a href="#36-线程和进程的区别？-1" class="headerlink" title="36. 线程和进程的区别？"></a><strong>36. 线程和进程的区别？</strong></h4><p>· 一个程序下至少有一个进程，一个进程下至少有一个线程，一个进程下也可以有多个线程来增加程序的执行速度。</p>
<h4 id="37-守护线程是什么？-1"><a href="#37-守护线程是什么？-1" class="headerlink" title="37. 守护线程是什么？"></a><strong>37. 守护线程是什么？</strong></h4><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h4 id="38-创建线程有哪几种方式？-1"><a href="#38-创建线程有哪几种方式？-1" class="headerlink" title="38. 创建线程有哪几种方式？"></a><strong>38. 创建线程有哪几种方式？</strong></h4><p>创建线程有三种方式：</p>
<p>· 继承 Thread 重写 run 方法；</p>
<p>· 实现 Runnable 接口；</p>
<p>· 实现 Callable 接口。</p>
<h4 id="39-说一下-runnable-和-callable-有什么区别？-1"><a href="#39-说一下-runnable-和-callable-有什么区别？-1" class="headerlink" title="39. 说一下 runnable 和 callable 有什么区别？"></a><strong>39. 说一下 runnable 和 callable 有什么区别？</strong></h4><p>runnable 没有返回值，callable 可以拿到有返回值，callable 可以看作是 runnable 的补充。</p>
<h4 id="40-线程有哪些状态？-1"><a href="#40-线程有哪些状态？-1" class="headerlink" title="40. 线程有哪些状态？"></a><strong>40. 线程有哪些状态？</strong></h4><p>线程的状态：</p>
<p>· NEW 尚未启动</p>
<p>· RUNNABLE 正在执行中</p>
<p>· BLOCKED 阻塞的（被同步锁或者IO锁阻塞）</p>
<p>· WAITING 永久等待状态</p>
<p>· TIMED_WAITING 等待指定的时间重新被唤醒的状态</p>
<p>· TERMINATED 执行完成</p>
<h4 id="41-sleep-和-wait-有什么区别？-1"><a href="#41-sleep-和-wait-有什么区别？-1" class="headerlink" title="41. sleep() 和 wait() 有什么区别？"></a><strong>41. sleep() 和 wait() 有什么区别？</strong></h4><p>· 类的不同：sleep() 来自 Thread，wait() 来自 Object。</p>
<p>· 释放锁：sleep() 不释放锁；wait() 释放锁。</p>
<p>· 用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</p>
<h4 id="-12"><a href="#-12" class="headerlink" title></a></h4><h4 id="42-notify-和-notifyAll-有什么区别？-1"><a href="#42-notify-和-notifyAll-有什么区别？-1" class="headerlink" title="42. notify()和 notifyAll()有什么区别？"></a><strong>42. notify()和 notifyAll()有什么区别？</strong></h4><p>notifyAll()会唤醒所有的线程，notify()之后唤醒一个线程。notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h4 id="43-线程的-run-和-start-有什么区别？-1"><a href="#43-线程的-run-和-start-有什么区别？-1" class="headerlink" title="43. 线程的 run() 和 start() 有什么区别？"></a><strong>43. 线程的 run() 和 start() 有什么区别？</strong></h4><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<h4 id="44-创建线程池有哪几种方式？-1"><a href="#44-创建线程池有哪几种方式？-1" class="headerlink" title="44. 创建线程池有哪几种方式？"></a><strong>44. 创建线程池有哪几种方式？</strong></h4><p>线程池创建有七种方式，最核心的是最后一种：</p>
<p>newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；</p>
<p>newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；</p>
<p>newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；</p>
<p>newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；</p>
<p>newScheduledThreadPool(int corePoolSize)：和newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；</p>
<p>newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序；</p>
<p>ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
<h4 id="45-线程池都有哪些状态？-1"><a href="#45-线程池都有哪些状态？-1" class="headerlink" title="45. 线程池都有哪些状态？"></a><strong>45. 线程池都有哪些状态？</strong></h4><p>· RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</p>
<p>· SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。</p>
<p>· STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。</p>
<p>· TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。</p>
<p>· TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。</p>
<h4 id="46-线程池中-submit-和-execute-方法有什么区别？-1"><a href="#46-线程池中-submit-和-execute-方法有什么区别？-1" class="headerlink" title="46. 线程池中 submit() 和 execute() 方法有什么区别？"></a><strong>46. 线程池中 submit() 和 execute() 方法有什么区别？</strong></h4><p>· execute()：只能执行 Runnable 类型的任务。</p>
<p>· submit()：可以执行 Runnable 和 Callable 类型的任务。</p>
<p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p>
<h4 id="47-在-Java-程序中怎么保证多线程的运行安全？-1"><a href="#47-在-Java-程序中怎么保证多线程的运行安全？-1" class="headerlink" title="47. 在 Java 程序中怎么保证多线程的运行安全？"></a><strong>47. 在 Java 程序中怎么保证多线程的运行安全？</strong></h4><p>· 方法一：使用安全类，比如 Java. util. concurrent 下的类。</p>
<p>· 方法二：使用自动锁 synchronized。</p>
<p>· 方法三：使用手动锁 Lock。</p>
<p>手动锁 Java 示例代码如下：</p>
<p>Lock lock = <strong>new</strong> ReentrantLock();</p>
<p>lock. lock();<strong>try</strong> {</p>
<p>​    System. out. println(“获得锁”);</p>
<p>} <strong>catch</strong> (Exception e) {</p>
<p>​    <em>//</em> <em>TODO:</em> <em>handle exception</em></p>
<p>} <strong>finally</strong> {</p>
<p>​    System. out. println(“释放锁”);</p>
<p>​    lock. unlock();</p>
<p>}</p>
<h4 id="48-多线程中-synchronized-锁升级的原理是什么？-1"><a href="#48-多线程中-synchronized-锁升级的原理是什么？-1" class="headerlink" title="48. 多线程中 synchronized 锁升级的原理是什么？"></a><strong>48. 多线程中 synchronized 锁升级的原理是什么？</strong></h4><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h4 id="49-什么是死锁？-1"><a href="#49-什么是死锁？-1" class="headerlink" title="49. 什么是死锁？"></a><strong>49. 什么是死锁？</strong></h4><p>当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
<h4 id="50-怎么防止死锁？-1"><a href="#50-怎么防止死锁？-1" class="headerlink" title="50. 怎么防止死锁？"></a><strong>50. 怎么防止死锁？</strong></h4><p>· 尽量使用 tryLock(long timeout, TimeUnit unit)的方法(ReentrantLock、ReentrantReadWriteLock)，设置超时时间，超时可以退出防止死锁。</p>
<p>· 尽量使用 Java. util. concurrent 并发类代替自己手写锁。</p>
<p>· 尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。</p>
<p>· 尽量减少同步的代码块。</p>
<h4 id="51-ThreadLocal-是什么？有哪些使用场景？-1"><a href="#51-ThreadLocal-是什么？有哪些使用场景？-1" class="headerlink" title="51. ThreadLocal 是什么？有哪些使用场景？"></a><strong>51. ThreadLocal 是什么？有哪些使用场景？</strong></h4><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
<h4 id="52-说一下-synchronized-底层实现原理？-1"><a href="#52-说一下-synchronized-底层实现原理？-1" class="headerlink" title="52. 说一下 synchronized 底层实现原理？"></a><strong>52. 说一下 synchronized 底层实现原理？</strong></h4><p>synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<h4 id="53-synchronized-和-volatile-的区别是什么？-1"><a href="#53-synchronized-和-volatile-的区别是什么？-1" class="headerlink" title="53. synchronized 和 volatile 的区别是什么？"></a><strong>53. synchronized 和 volatile 的区别是什么？</strong></h4><p>· volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p>
<p>· volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p>
<p>· volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p>
<h4 id="54-synchronized-和-Lock-有什么区别？-1"><a href="#54-synchronized-和-Lock-有什么区别？-1" class="headerlink" title="54. synchronized 和 Lock 有什么区别？"></a><strong>54. synchronized 和 Lock 有什么区别？</strong></h4><p>· synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</p>
<p>· synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p>
<p>· 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h4 id="55-synchronized-和-ReentrantLock-区别是什么？-1"><a href="#55-synchronized-和-ReentrantLock-区别是什么？-1" class="headerlink" title="55. synchronized 和 ReentrantLock 区别是什么？"></a><strong>55. synchronized 和 ReentrantLock 区别是什么？</strong></h4><p>synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 6 中对 synchronized 进行了非常多的改进。</p>
<p>主要区别如下：</p>
<p>· ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</p>
<p>· ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；</p>
<p>· ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。</p>
<p>· volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p>
<h4 id="56-说一下-atomic-的原理？-1"><a href="#56-说一下-atomic-的原理？-1" class="headerlink" title="56. 说一下 atomic 的原理？"></a><strong>56. 说一下 atomic 的原理？</strong></h4><p>atomic 主要利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<h3 id="-13"><a href="#-13" class="headerlink" title></a></h3><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a><strong>反射</strong></h3><h4 id="57-什么是反射？-1"><a href="#57-什么是反射？-1" class="headerlink" title="57. 什么是反射？"></a><strong>57. 什么是反射？</strong></h4><p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<h4 id="58-什么是-Java-序列化？什么情况下需要序列化？-1"><a href="#58-什么是-Java-序列化？什么情况下需要序列化？-1" class="headerlink" title="58. 什么是 Java 序列化？什么情况下需要序列化？"></a><strong>58. 什么是 Java 序列化？什么情况下需要序列化？</strong></h4><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p>
<p>以下情况需要使用 Java 序列化：</p>
<p>· 想把的内存中的对象状态保存到一个文件中或者数据库中时候；</p>
<p>· 想用套接字在网络上传送对象的时候；</p>
<p>· 想通过RMI（远程方法调用）传输对象的时候。</p>
<h4 id="59-动态代理是什么？有哪些应用？-1"><a href="#59-动态代理是什么？有哪些应用？-1" class="headerlink" title="59. 动态代理是什么？有哪些应用？"></a><strong>59. 动态代理是什么？有哪些应用？</strong></h4><p>动态代理是运行时动态生成代理类。</p>
<p>动态代理的应用有 spring aop、hibernate 数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。</p>
<h4 id="60-怎么实现动态代理？-1"><a href="#60-怎么实现动态代理？-1" class="headerlink" title="60. 怎么实现动态代理？"></a><strong>60. 怎么实现动态代理？</strong></h4><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p>
<h3 id="对象拷贝-1"><a href="#对象拷贝-1" class="headerlink" title="对象拷贝"></a><strong>对象拷贝</strong></h3><p>\61. 为什么要使用克隆？</p>
<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法了。</p>
<h4 id="62-如-何实现对象克隆？"><a href="#62-如-何实现对象克隆？" class="headerlink" title="62. 如**何实现对象克隆？**"></a><strong>62. 如**</strong>何实现对象克隆？**</h4><p>· 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</p>
<p>· 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
<h4 id="63-深拷贝和浅拷贝区别是什么？-1"><a href="#63-深拷贝和浅拷贝区别是什么？-1" class="headerlink" title="63. 深拷贝和浅拷贝区别是什么？"></a><strong>63. 深拷贝和浅拷贝区别是什么？</strong></h4><p>· 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
<p>· 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>
<h3 id="Java-Web-1"><a href="#Java-Web-1" class="headerlink" title="Java Web"></a><strong>Java Web</strong></h3><h4 id="64-JSP-和-servlet-有什么区别？-1"><a href="#64-JSP-和-servlet-有什么区别？-1" class="headerlink" title="64. JSP 和 servlet 有什么区别？"></a><strong>64. JSP 和 servlet 有什么区别？</strong></h4><p>JSP 是 servlet 技术的扩展，本质上就是 servlet 的简易方式。servlet 和 JSP 最主要的不同点在于，servlet 的应用逻辑是在 Java 文件中，并且完全从表示层中的 html 里分离开来，而 JSP 的情况是 Java 和 html 可以组合成一个扩展名为 JSP 的文件。JSP 侧重于视图，servlet 主要用于控制逻辑。</p>
<h4 id="65-JSP-有哪些内置对象？作用分别是什么？-1"><a href="#65-JSP-有哪些内置对象？作用分别是什么？-1" class="headerlink" title="65. JSP 有哪些内置对象？作用分别是什么？"></a><strong>65. JSP 有哪些内置对象？作用分别是什么？</strong></h4><p>JSP 有 9 大内置对象：</p>
<p>· request：封装客户端的请求，其中包含来自 get 或 post 请求的参数；</p>
<p>· response：封装服务器对客户端的响应；</p>
<p>· pageContext：通过该对象可以获取其他对象；</p>
<p>· session：封装用户会话的对象；</p>
<p>· application：封装服务器运行环境的对象；</p>
<p>· out：输出服务器响应的输出流对象；</p>
<p>· config：Web 应用的配置对象；</p>
<p>· page：JSP 页面本身（相当于 Java 程序中的 this）；</p>
<p>· exception：封装页面抛出异常的对象。</p>
<h4 id="-14"><a href="#-14" class="headerlink" title></a></h4><h4 id="66-说一下-JSP-的-4-种作用域？-1"><a href="#66-说一下-JSP-的-4-种作用域？-1" class="headerlink" title="66. 说一下 JSP 的 4 种作用域？"></a><strong>66. 说一下 JSP 的 4 种作用域？</strong></h4><p>· page：代表与一个页面相关的对象和属性。</p>
<p>· request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</p>
<p>· session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的 session 中。</p>
<p>· application：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</p>
<h4 id="67-session-和-cookie-有什么区别？-1"><a href="#67-session-和-cookie-有什么区别？-1" class="headerlink" title="67. session 和 cookie 有什么区别？"></a><strong>67. session 和 cookie 有什么区别？</strong></h4><p>· 存储位置不同：session 存储在服务器端；cookie 存储在浏览器端。</p>
<p>· 安全性不同：cookie 安全性一般，在浏览器存储，可以被伪造和修改。</p>
<p>· 容量和个数限制：cookie 有容量限制，每个站点下的 cookie 也有个数限制。</p>
<p>· 存储的多样性：session 可以存储在 Redis 中、数据库中、应用程序中；而 cookie 只能存储在浏览器中。</p>
<h4 id="68-说一下-session-的工作原理？-1"><a href="#68-说一下-session-的工作原理？-1" class="headerlink" title="68. 说一下 session 的工作原理？"></a><strong>68. 说一下 session 的工作原理？</strong></h4><p>· session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h4 id="69-如果客户端禁止-cookie-能实现-session-还能用吗？-1"><a href="#69-如果客户端禁止-cookie-能实现-session-还能用吗？-1" class="headerlink" title="69. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a><strong>69. 如果客户端禁止 cookie 能实现 session 还能用吗？</strong></h4><p>· 可以用，session 只是依赖 cookie 存储 sessionid，如果 cookie 被禁用了，可以使用 url 中添加 sessionid 的方式保证 session 能正常使用。</p>
<h4 id="70-spring-mvc-和-struts-的区别是什么？-1"><a href="#70-spring-mvc-和-struts-的区别是什么？-1" class="headerlink" title="70. spring mvc 和 struts 的区别是什么？"></a><strong>70. spring mvc 和 struts 的区别是什么？</strong></h4><p>· 拦截级别：struts2 是类级别的拦截；spring mvc 是方法级别的拦截。</p>
<p>· 数据独立性：spring mvc 的方法之间基本上独立的，独享 request 和 response 数据，请求数据通过参数获取，处理结果通过 ModelMap 交回给框架，方法之间不共享变量；而 struts2 虽然方法之间也是独立的，但其所有 action 变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</p>
<p>· 拦截机制：struts2 有以自己的 interceptor 机制，spring mvc 用的是独立的 aop 方式，这样导致struts2 的配置文件量比 spring mvc 大。</p>
<p>· 对 ajax 的支持：spring mvc 集成了ajax，所有 ajax 使用很方便，只需要一个注解 @ResponseBody 就可以实现了；而 struts2 一般需要安装插件或者自己写代码才行。</p>
<h4 id="71-如何避免-SQL-注入？-1"><a href="#71-如何避免-SQL-注入？-1" class="headerlink" title="71. 如何避免 SQL 注入？"></a><strong>71. 如何避免 SQL 注入？</strong></h4><p>· 使用预处理 PreparedStatement。</p>
<p>· 使用正则表达式过滤掉字符中的特殊字符。</p>
<h4 id="72-什么是-XSS-攻击，如何避免？-1"><a href="#72-什么是-XSS-攻击，如何避免？-1" class="headerlink" title="72. 什么是 XSS 攻击，如何避免？"></a><strong>72. 什么是 XSS 攻击，如何避免？</strong></h4><p>XSS 攻击：即跨站脚本攻击，它是 Web 程序中常见的漏洞。原理是攻击者往 Web 页面里插入恶意的脚本代码（css 代码、Javascript 代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，如盗取用户 cookie、破坏页面结构、重定向到其他网站等。</p>
<p>预防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h4 id="73-什么是-CSRF-攻击，如何避免？-1"><a href="#73-什么是-CSRF-攻击，如何避免？-1" class="headerlink" title="73. 什么是 CSRF 攻击，如何避免？"></a><strong>73. 什么是 CSRF 攻击，如何避免？</strong></h4><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品，虚拟货币转账等。</p>
<p>防御手段：</p>
<p>· 验证请求来源地址；</p>
<p>· 关键操作添加验证码；</p>
<p>· 在请求地址添加 token 并验证。</p>
<h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a><strong>异常</strong></h3><h4 id="74-throw-和-throws-的区别？-1"><a href="#74-throw-和-throws-的区别？-1" class="headerlink" title="74. throw 和 throws 的区别？"></a><strong>74. throw 和 throws 的区别？</strong></h4><p>· throw：是真实抛出一个异常。</p>
<p>· throws：是声明可能会抛出一个异常。</p>
<h4 id="-15"><a href="#-15" class="headerlink" title></a></h4><h4 id="75-final、finally、finalize-有什么区别？-1"><a href="#75-final、finally、finalize-有什么区别？-1" class="headerlink" title="75. final、finally、finalize 有什么区别？"></a><strong>75. final、finally、finalize 有什么区别？</strong></h4><p>· final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</p>
<p>· finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</p>
<p>· finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</p>
<h4 id="76-try-catch-finally-中哪个部分可以省略？-1"><a href="#76-try-catch-finally-中哪个部分可以省略？-1" class="headerlink" title="76. try-catch-finally 中哪个部分可以省略？"></a><strong>76. try-catch-finally 中哪个部分可以省略？</strong></h4><p>· try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</p>
<h4 id="77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？-1"><a href="#77-try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？-1" class="headerlink" title="77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a><strong>77. try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></h4><p>· finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</p>
<h4 id="78-常见的异常类有哪些？-1"><a href="#78-常见的异常类有哪些？-1" class="headerlink" title="78. 常见的异常类有哪些？"></a><strong>78. 常见的异常类有哪些？</strong></h4><p>· NullPointerException 空指针异常</p>
<p>· ClassNotFoundException 指定类不存在</p>
<p>· NumberFormatException 字符串转换为数字异常</p>
<p>· IndexOutOfBoundsException 数组下标越界异常</p>
<p>· ClassCastException 数据类型转换异常</p>
<p>· FileNotFoundException 文件未找到异常</p>
<p>· NoSuchMethodException 方法不存在异常</p>
<p>· IOException IO 异常</p>
<p>· SocketException Socket 异常</p>
<h3 id="-16"><a href="#-16" class="headerlink" title></a></h3><h3 id="-17"><a href="#-17" class="headerlink" title></a></h3><h3 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a><strong>网络</strong></h3><h4 id="79-http-响应码-301-和-302-代表的是什么？有什么区别？-1"><a href="#79-http-响应码-301-和-302-代表的是什么？有什么区别？-1" class="headerlink" title="79. http 响应码 301 和 302 代表的是什么？有什么区别？"></a><strong>79. http 响应码 301 和 302 代表的是什么？有什么区别？</strong></h4><p>301：永久重定向。</p>
<p>302：暂时重定向。</p>
<p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
<h4 id="80-forward-和-redirect-的区别？-1"><a href="#80-forward-和-redirect-的区别？-1" class="headerlink" title="80. forward 和 redirect 的区别？"></a><strong>80. forward 和 redirect 的区别？</strong></h4><p>forward 是转发 和 redirect 是重定向：</p>
<p>· 地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</p>
<p>· 数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</p>
<p>· 效率：forward 比 redirect 效率高。</p>
<h4 id="81-简述-tcp-和-udp的区别？-1"><a href="#81-简述-tcp-和-udp的区别？-1" class="headerlink" title="81. 简述 tcp 和 udp的区别？"></a><strong>81. 简述 tcp 和 udp的区别？</strong></h4><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
<p>两者的区别大致如下：</p>
<p>· tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</p>
<p>· tcp 提供可靠的服务（数据传输），udp 无法保证；</p>
<p>· tcp 面向字节流，udp 面向报文；</p>
<p>· tcp 数据传输慢，udp 数据传输快；</p>
<h4 id="82-tcp-为什么要三次握手，两次不行吗？为什么？-1"><a href="#82-tcp-为什么要三次握手，两次不行吗？为什么？-1" class="headerlink" title="82. tcp 为什么要三次握手，两次不行吗？为什么？"></a><strong>82. tcp 为什么要三次握手，两次不行吗？为什么？</strong></h4><p>如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</p>
<h4 id="-18"><a href="#-18" class="headerlink" title></a></h4><h4 id="83-说一下-tcp-粘包是怎么产生的？-1"><a href="#83-说一下-tcp-粘包是怎么产生的？-1" class="headerlink" title="83. 说一下 tcp 粘包是怎么产生的？"></a><strong>83. 说一下 tcp 粘包是怎么产生的？</strong></h4><p>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：</p>
<p>· 发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</p>
<p>· 接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</p>
<h4 id="84-OSI-的七层模型都有哪些？-1"><a href="#84-OSI-的七层模型都有哪些？-1" class="headerlink" title="84. OSI 的七层模型都有哪些？"></a><strong>84. OSI 的七层模型都有哪些？</strong></h4><p>· 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</p>
<p>· 数据链路层：负责建立和管理节点间的链路。</p>
<p>· 网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</p>
<p>· 传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</p>
<p>· 会话层：向两个实体的表示层提供建立和使用连接的方法。</p>
<p>· 表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</p>
<p>· 应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>
<h4 id="85-get-和-post-请求有哪些区别？-1"><a href="#85-get-和-post-请求有哪些区别？-1" class="headerlink" title="85. get 和 post 请求有哪些区别？"></a><strong>85. get 和 post 请求有哪些区别？</strong></h4><p>· get 请求会被浏览器主动缓存，而 post 不会。</p>
<p>· get 传递参数有大小限制，而 post 没有。</p>
<p>· post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</p>
<h4 id="86-如何实现跨域？-1"><a href="#86-如何实现跨域？-1" class="headerlink" title="86. 如何实现跨域？"></a><strong>86. 如何实现跨域？</strong></h4><p>实现跨域有以下几种方案：</p>
<p>· 服务器端运行跨域 设置 CORS 等于 *；</p>
<p>· 在单个接口使用注解 @CrossOrigin 运行跨域；</p>
<p>· 使用 jsonp 跨域；</p>
<h4 id="87-说一下-JSONP-实现原理？-1"><a href="#87-说一下-JSONP-实现原理？-1" class="headerlink" title="87. 说一下 JSONP 实现原理？"></a><strong>87. 说一下 JSONP 实现原理？</strong></h4><p>jsonp：JSON with Padding，它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</p>
<h3 id="-19"><a href="#-19" class="headerlink" title></a></h3><h3 id="设计模式-1"><a href="#设计模式-1" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h3><h4 id="88-说一下你熟悉的设计模式？-1"><a href="#88-说一下你熟悉的设计模式？-1" class="headerlink" title="88. 说一下你熟悉的设计模式？"></a><strong>88. 说一下你熟悉的设计模式？</strong></h4><p>· 单例模式：保证被创建一次，节省系统开销。</p>
<p>· 工厂模式（简单工厂、抽象工厂）：解耦代码。</p>
<p>· 观察者模式：定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。</p>
<p>· 外观模式：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。</p>
<p>· 模版方法模式：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。</p>
<p>· 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<h4 id="89-简单工厂和抽象工厂有什么区别？-1"><a href="#89-简单工厂和抽象工厂有什么区别？-1" class="headerlink" title="89. 简单工厂和抽象工厂有什么区别？"></a><strong>89. 简单工厂和抽象工厂有什么区别？</strong></h4><p>· 简单工厂：用来生产同一等级结构中的任意产品，对于增加新的产品，无能为力。</p>
<p>· 工厂方法：用来生产同一等级结构中的固定产品，支持增加任意产品。</p>
<p>· 抽象工厂：用来生产不同产品族的全部产品，对于增加新的产品，无能为力；支持增加产品族。</p>
<h3 id="Spring-Spring-MVC-1"><a href="#Spring-Spring-MVC-1" class="headerlink" title="Spring/Spring MVC"></a><strong>Spring/Spring MVC</strong></h3><h4 id="90-为什么要使用-spring？-1"><a href="#90-为什么要使用-spring？-1" class="headerlink" title="90. 为什么要使用 spring？"></a><strong>90. 为什么要使用 spring？</strong></h4><p>· spring 提供 ioc 技术，容器会帮你管理依赖的对象，从而不需要自己创建和管理依赖对象了，更轻松的实现了程序的解耦。</p>
<p>· spring 提供了事务支持，使得事务操作变的更加方便。</p>
<p>· spring 提供了面向切片编程，这样可以更方便的处理某一类的问题。</p>
<p>· 更方便的框架集成，spring 可以很方便的集成其他框架，比如 MyBatis、hibernate 等。</p>
<h4 id="91-解释一下什么是-aop？-1"><a href="#91-解释一下什么是-aop？-1" class="headerlink" title="91. 解释一下什么是 aop？"></a><strong>91. 解释一下什么是 aop？</strong></h4><p>· aop 是面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p>
<p>· 简单来说就是统一处理某一“切面”（类）的问题的编程思想，比如统一处理日志、异常等。</p>
<h4 id="92-解释一下什么是-ioc？-1"><a href="#92-解释一下什么是-ioc？-1" class="headerlink" title="92. 解释一下什么是 ioc？"></a><strong>92. 解释一下什么是 ioc？</strong></h4><p>ioc：Inversionof Control（中文：控制反转）是 spring 的核心，对于 spring 框架来说，就是由 spring 来负责控制对象的生命周期和对象间的关系。</p>
<p>简单来说，控制指的是当前对象对内部成员的控制权；控制反转指的是，这种控制权不由当前对象管理了，由其他（类,第三方容器）来管理。</p>
<h4 id="93-spring-有哪些主要模块？-1"><a href="#93-spring-有哪些主要模块？-1" class="headerlink" title="93. spring 有哪些主要模块？"></a><strong>93. spring 有哪些主要模块？</strong></h4><p>· spring core：框架的最基础部分，提供 ioc 和依赖注入特性。</p>
<p>· spring context：构建于 core 封装包基础上的 context 封装包，提供了一种框架式的对象访问方法。</p>
<p>· spring dao：Data Access Object 提供了JDBC的抽象层。</p>
<p>· spring aop：提供了面向切面的编程实现，让你可以自定义拦截器、切点等。</p>
<p>· spring Web：提供了针对 Web 开发的集成特性，例如文件上传，利用 servlet listeners 进行 ioc 容器初始化和针对 Web 的 ApplicationContext。</p>
<p>· spring Web mvc：spring 中的 mvc 封装包提供了 Web 应用的 Model-View-Controller（MVC）的实现。</p>
<h4 id="94-spring-常用的注入方式有哪些？-1"><a href="#94-spring-常用的注入方式有哪些？-1" class="headerlink" title="94. spring 常用的注入方式有哪些？"></a><strong>94. spring 常用的注入方式有哪些？</strong></h4><p>· setter 属性注入</p>
<p>· 构造方法注入</p>
<p>· 注解方式注入</p>
<h4 id="95-spring-中的-bean-是线程安全的吗？-1"><a href="#95-spring-中的-bean-是线程安全的吗？-1" class="headerlink" title="95. spring 中的 bean 是线程安全的吗？"></a><strong>95. spring 中的 bean 是线程安全的吗？</strong></h4><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p>
<p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所有某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”变更为“prototype”，这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p>
<p>· 有状态就是有数据存储功能。</p>
<p>· 无状态就是不会保存数据。</p>
<h4 id="96-spring-支持几种-bean-的作用域？-1"><a href="#96-spring-支持几种-bean-的作用域？-1" class="headerlink" title="96. spring 支持几种 bean 的作用域？"></a><strong>96. spring 支持几种 bean 的作用域？</strong></h4><p>spring 支持 5 种作用域，如下：</p>
<p>· singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</p>
<p>· prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</p>
<p>· Web 环境下的作用域：</p>
<p>· request：每次 http 请求都会创建一个 bean；</p>
<p>· session：同一个 http session 共享一个 bean 实例；</p>
<p>· global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</p>
<p><strong>注意：</strong> 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</p>
<h4 id="97-spring-自动装配-bean-有哪些方式？-1"><a href="#97-spring-自动装配-bean-有哪些方式？-1" class="headerlink" title="97. spring 自动装配 bean 有哪些方式？"></a><strong>97. spring 自动装配 bean 有哪些方式？</strong></h4><p>· no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</p>
<p>· byName：它根据 bean 的名称注入对象依赖项。</p>
<p>· byType：它根据类型注入对象依赖项。</p>
<p>· 构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</p>
<p>· autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</p>
<h4 id="98-spring-事务实现方式有哪些？-1"><a href="#98-spring-事务实现方式有哪些？-1" class="headerlink" title="98. spring 事务实现方式有哪些？"></a><strong>98. spring 事务实现方式有哪些？</strong></h4><p>· 声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</p>
<p>· 编码方式：提供编码的形式管理和维护事务。</p>
<h4 id="99-说一下-spring-的事务隔离？-1"><a href="#99-说一下-spring-的事务隔离？-1" class="headerlink" title="99. 说一下 spring 的事务隔离？"></a><strong>99. 说一下 spring 的事务隔离？</strong></h4><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
<p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
<p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
<p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
<p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
<p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="100-说一下-spring-mvc-运行流程？-1"><a href="#100-说一下-spring-mvc-运行流程？-1" class="headerlink" title="100. 说一下 spring mvc 运行流程？"></a><strong>100. 说一下 spring mvc 运行流程？</strong></h4><p>· spring mvc 先将请求发送给 DispatcherServlet。</p>
<p>· DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</p>
<p>· DispatcherServlet 再把请求提交到对应的 Controller。</p>
<p>· Controller 进行业务逻辑处理后，会返回一个ModelAndView。</p>
<p>· Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</p>
<p>· 视图对象负责渲染返回给客户端。</p>
<h4 id="101-spring-mvc-有哪些组件？-1"><a href="#101-spring-mvc-有哪些组件？-1" class="headerlink" title="101. spring mvc 有哪些组件？"></a><strong>101. spring mvc 有哪些组件？</strong></h4><p>· 前置控制器 DispatcherServlet。</p>
<p>· 映射控制器 HandlerMapping。</p>
<p>· 处理器 Controller。</p>
<p>· 模型和视图 ModelAndView。</p>
<p>· 视图解析器 ViewResolver。</p>
<h4 id="-20"><a href="#-20" class="headerlink" title></a></h4><h4 id="-21"><a href="#-21" class="headerlink" title></a></h4><h4 id="102-RequestMapping-的作用是什么？-1"><a href="#102-RequestMapping-的作用是什么？-1" class="headerlink" title="102. @RequestMapping 的作用是什么？"></a><strong>102. @RequestMapping 的作用是什么？</strong></h4><p>将 http 请求映射到相应的类/方法上。</p>
<h4 id="103-Autowired-的作用是什么？-1"><a href="#103-Autowired-的作用是什么？-1" class="headerlink" title="103. @Autowired 的作用是什么？"></a><strong>103. @Autowired 的作用是什么？</strong></h4><p>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，通过@Autowired 的使用来消除 set/get 方法。</p>
<h3 id="Spring-Boot-Spring-Cloud-1"><a href="#Spring-Boot-Spring-Cloud-1" class="headerlink" title="Spring Boot/Spring Cloud"></a><strong>Spring Boot/Spring Cloud</strong></h3><h4 id="104-什么是-spring-boot？-1"><a href="#104-什么是-spring-boot？-1" class="headerlink" title="104. 什么是 spring boot？"></a><strong>104. 什么是 spring boot？</strong></h4><p>spring boot 是为 spring 服务的，是用来简化新 spring 应用的初始搭建以及开发过程的。</p>
<h4 id="105-为什么要用-spring-boot？-1"><a href="#105-为什么要用-spring-boot？-1" class="headerlink" title="105. 为什么要用 spring boot？"></a><strong>105. 为什么要用 spring boot？</strong></h4><p>· 配置简单</p>
<p>· 独立运行</p>
<p>· 自动装配</p>
<p>· 无代码生成和 xml 配置</p>
<p>· 提供应用监控</p>
<p>· 易上手</p>
<p>· 提升开发效率</p>
<h4 id="106-spring-boot-核心配置文件是什么？-1"><a href="#106-spring-boot-核心配置文件是什么？-1" class="headerlink" title="106. spring boot 核心配置文件是什么？"></a><strong>106. spring boot 核心配置文件是什么？</strong></h4><p>spring boot 核心的两个配置文件：</p>
<p>· bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</p>
<p>· application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</p>
<h4 id="107-spring-boot-配置文件有哪几种类型？它们有什么区别？-1"><a href="#107-spring-boot-配置文件有哪几种类型？它们有什么区别？-1" class="headerlink" title="107. spring boot 配置文件有哪几种类型？它们有什么区别？"></a><strong>107. spring boot 配置文件有哪几种类型？它们有什么区别？</strong></h4><p>配置文件有 . properties 格式和 . yml 格式，它们主要的区别是书法风格不同。</p>
<p>. properties 配置如下：</p>
<p>spring. RabbitMQ. port=5672</p>
<p>. yml 配置如下：</p>
<p>spring:</p>
<p>​    RabbitMQ:</p>
<p>​        port: 5672</p>
<p>. yml 格式不支持 @PropertySource 注解导入。</p>
<h4 id="108-spring-boot-有哪些方式可以实现热部署？-1"><a href="#108-spring-boot-有哪些方式可以实现热部署？-1" class="headerlink" title="108. spring boot 有哪些方式可以实现热部署？"></a><strong>108. spring boot 有哪些方式可以实现热部署？</strong></h4><p>· 使用 devtools 启动热部署，添加 devtools 库，在配置文件中把 spring. devtools. restart. enabled 设置为 true；</p>
<p>· 使用 Intellij Idea 编辑器，勾上自动编译或手动重新编译。</p>
<h4 id="109-jpa-和-hibernate-有什么区别？-1"><a href="#109-jpa-和-hibernate-有什么区别？-1" class="headerlink" title="109. jpa 和 hibernate 有什么区别？"></a><strong>109. jpa 和 hibernate 有什么区别？</strong></h4><p>jpa 全称 Java Persistence API，是 Java 持久化接口规范，hibernate 属于 jpa 的具体实现。</p>
<h4 id="110-什么是-spring-cloud？-1"><a href="#110-什么是-spring-cloud？-1" class="headerlink" title="110. 什么是 spring cloud？"></a><strong>110. 什么是 spring cloud？</strong></h4><p>spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 spring boot 的开发风格做到一键启动和部署。</p>
<h4 id="111-spring-cloud-断路器的作用是什么？-1"><a href="#111-spring-cloud-断路器的作用是什么？-1" class="headerlink" title="111. spring cloud 断路器的作用是什么？"></a><strong>111. spring cloud 断路器的作用是什么？</strong></h4><p>在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p>
<h4 id="-22"><a href="#-22" class="headerlink" title></a></h4><h4 id="112-spring-cloud-的核心组件有哪些？-1"><a href="#112-spring-cloud-的核心组件有哪些？-1" class="headerlink" title="112. spring cloud 的核心组件有哪些？"></a><strong>112. spring cloud 的核心组件有哪些？</strong></h4><p>· Eureka：服务注册于发现。</p>
<p>· Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。</p>
<p>· Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。</p>
<p>· Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</p>
<p>· Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。</p>
<h3 id="Hibernate-1"><a href="#Hibernate-1" class="headerlink" title="Hibernate"></a><strong>Hibernate</strong></h3><h4 id="113-为什么要使用-hibernate？-1"><a href="#113-为什么要使用-hibernate？-1" class="headerlink" title="113. 为什么要使用 hibernate？"></a><strong>113. 为什么要使用 hibernate？</strong></h4><p>· hibernate 是对 jdbc 的封装，大大简化了数据访问层的繁琐的重复性代码。</p>
<p>· hibernate 是一个优秀的 ORM 实现，很多程度上简化了 DAO 层的编码功能。</p>
<p>· 可以很方便的进行数据库的移植工作。</p>
<p>· 提供了缓存机制，是程序执行更改的高效。</p>
<h4 id="114-什么是-ORM-框架？-1"><a href="#114-什么是-ORM-框架？-1" class="headerlink" title="114. 什么是 ORM 框架？"></a><strong>114. 什么是 ORM 框架？</strong></h4><p>ORM（Object Relation Mapping）对象关系映射，是把数据库中的关系数据映射成为程序中的对象。</p>
<p>使用 ORM 的优点：提高了开发效率降低了开发成本、开发更简单更对象化、可移植更强。</p>
<h4 id="115-hibernate-中如何在控制台查看打印的-SQL-语句？-1"><a href="#115-hibernate-中如何在控制台查看打印的-SQL-语句？-1" class="headerlink" title="115. hibernate 中如何在控制台查看打印的 SQL 语句？"></a><strong>115. hibernate 中如何在控制台查看打印的 SQL 语句？</strong></h4><p>在 Config 里面把 hibernate. show_SQL 设置为 true 就可以。但不建议开启，开启之后会降低程序的运行效率。</p>
<h4 id="116-hibernate-有几种查询方式？-1"><a href="#116-hibernate-有几种查询方式？-1" class="headerlink" title="116. hibernate 有几种查询方式？"></a><strong>116. hibernate 有几种查询方式？</strong></h4><p>三种：hql、原生 SQL、条件查询 Criteria。</p>
<h4 id="-23"><a href="#-23" class="headerlink" title></a></h4><h4 id="117-hibernate-实体类可以被定义为-final-吗？-1"><a href="#117-hibernate-实体类可以被定义为-final-吗？-1" class="headerlink" title="117. hibernate 实体类可以被定义为 final 吗？"></a><strong>117. hibernate 实体类可以被定义为 final 吗？</strong></h4><p>实体类可以定义为 final 类，但这样的话就不能使用 hibernate 代理模式下的延迟关联提供性能了，所以不建议定义实体类为 final。</p>
<h4 id="118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？-1"><a href="#118-在-hibernate-中使用-Integer-和-int-做映射有什么区别？-1" class="headerlink" title="118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a><strong>118. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</strong></h4><p>Integer 类型为对象，它的值允许为 null，而 int 属于基础数据类型，值不能为 null。</p>
<h4 id="119-hibernate-是如何工作的？-1"><a href="#119-hibernate-是如何工作的？-1" class="headerlink" title="119. hibernate 是如何工作的？"></a><strong>119. hibernate 是如何工作的？</strong></h4><p>· 读取并解析配置文件。</p>
<p>· 读取并解析映射文件，创建 SessionFactory。</p>
<p>· 打开 Session。</p>
<p>· 创建事务。</p>
<p>· 进行持久化操作。</p>
<p>· 提交事务。</p>
<p>· 关闭 Session。</p>
<p>· 关闭 SessionFactory。</p>
<h4 id="120-get-和-load-的区别？-1"><a href="#120-get-和-load-的区别？-1" class="headerlink" title="120. get()和 load()的区别？"></a><strong>120. get()和 load()的区别？</strong></h4><p>· 数据查询时，没有 OID 指定的对象，get() 返回 null；load() 返回一个代理对象。</p>
<p>· load()支持延迟加载；get() 不支持延迟加载。</p>
<h4 id="121-说一下-hibernate-的缓存机制？-1"><a href="#121-说一下-hibernate-的缓存机制？-1" class="headerlink" title="121. 说一下 hibernate 的缓存机制？"></a><strong>121. 说一下 hibernate 的缓存机制？</strong></h4><p>hibernate 常用的缓存有一级缓存和二级缓存：</p>
<p>一级缓存：也叫 Session 缓存，只在 Session 作用范围内有效，不需要用户干涉，由 hibernate 自身维护，可以通过：evict(object)清除 object 的缓存；clear()清除一级缓存中的所有缓存；flush()刷出缓存；</p>
<p>二级缓存：应用级别的缓存，在所有 Session 中都有效，支持配置第三方的缓存，如：EhCache。</p>
<h4 id="-24"><a href="#-24" class="headerlink" title></a></h4><h4 id="122-hibernate-对象有哪些状态？-1"><a href="#122-hibernate-对象有哪些状态？-1" class="headerlink" title="122. hibernate 对象有哪些状态？"></a><strong>122. hibernate 对象有哪些状态？</strong></h4><p>· 临时/瞬时状态：直接 new 出来的对象，该对象还没被持久化（没保存在数据库中），不受 Session 管理。</p>
<p>· 持久化状态：当调用 Session 的 save/saveOrupdate/get/load/list 等方法的时候，对象就是持久化状态。</p>
<p>· 游离状态：Session 关闭之后对象就是游离状态。</p>
<h4 id="123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？-1"><a href="#123-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？-1" class="headerlink" title="123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a><strong>123. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</strong></h4><p>· getCurrentSession 会绑定当前线程，而 openSession 则不会。</p>
<p>· getCurrentSession 事务是 Spring 控制的，并且不需要手动关闭，而 openSession 需要我们自己手动开启和提交事务。</p>
<h4 id="124-hibernate-实体类必须要有无参构造函数吗？为什么？-1"><a href="#124-hibernate-实体类必须要有无参构造函数吗？为什么？-1" class="headerlink" title="124. hibernate 实体类必须要有无参构造函数吗？为什么？"></a><strong>124. hibernate 实体类必须要有无参构造函数吗？为什么？</strong></h4><p>hibernate 中每个实体类必须提供一个无参构造函数，因为 hibernate 框架要使用 reflection api，通过调用 ClassnewInstance() 来创建实体类的实例，如果没有无参的构造函数就会抛出异常。</p>
<h3 id="MyBatis-1"><a href="#MyBatis-1" class="headerlink" title="MyBatis"></a><strong>MyBatis</strong></h3><h4 id="125-MyBatis-中-和-的区别是什么？-1"><a href="#125-MyBatis-中-和-的区别是什么？-1" class="headerlink" title="125. MyBatis 中 #{}和 ${}的区别是什么？"></a><strong>125. MyBatis 中 #{}和 ${}的区别是什么？</strong></h4><p>#{}是预编译处理，${}是字符替换。 在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。</p>
<h4 id="126-MyBatis-有几种分页方式？-1"><a href="#126-MyBatis-有几种分页方式？-1" class="headerlink" title="126. MyBatis 有几种分页方式？"></a><strong>126. MyBatis 有几种分页方式？</strong></h4><p>分页方式：逻辑分页和物理分页。</p>
<p><strong>逻辑分页：</strong> 使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索。</p>
<p><strong>物理分页：</strong> 自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据的形式。</p>
<h4 id="127-RowBounds-是一次性查询全部结果吗？为什么？-1"><a href="#127-RowBounds-是一次性查询全部结果吗？为什么？-1" class="headerlink" title="127. RowBounds 是一次性查询全部结果吗？为什么？"></a><strong>127. RowBounds 是一次性查询全部结果吗？为什么？</strong></h4><p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据，因为 MyBatis 是对 jdbc 的封装，在 jdbc 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在你执行 next()的时候，去查询更多的数据。就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，所以你要取 4 次才能把钱取完。只是对于 jdbc 来说，当你调用 next()的时候会自动帮你完成查询工作。这样做的好处可以有效的防止内存溢出。</p>
<p>Fetch Size 官方相关文档：<span class="exturl" data-url="aHR0cDovL3Q=" title="http://t">http://t<i class="fa fa-external-link"></i></span>. cn/EfSE2g3</p>
<h4 id="128-MyBatis-逻辑分页和物理分页的区别是什么？-1"><a href="#128-MyBatis-逻辑分页和物理分页的区别是什么？-1" class="headerlink" title="128. MyBatis 逻辑分页和物理分页的区别是什么？"></a><strong>128. MyBatis 逻辑分页和物理分页的区别是什么？</strong></h4><p>· 逻辑分页是一次性查询很多数据，然后再在结果中检索分页的数据。这样做弊端是需要消耗大量的内存、有内存溢出的风险、对数据库压力较大。</p>
<p>· 物理分页是从数据库查询指定条数的数据，弥补了一次性全部查出的所有数据的种种缺点，比如需要大量的内存，对数据库查询压力较大等问题。</p>
<h4 id="129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？-1"><a href="#129-MyBatis-是否支持延迟加载？延迟加载的原理是什么？-1" class="headerlink" title="129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？"></a><strong>129. MyBatis 是否支持延迟加载？延迟加载的原理是什么？</strong></h4><p>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可。</p>
<p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。</p>
<h4 id="130-说一下-MyBatis-的一级缓存和二级缓存？-1"><a href="#130-说一下-MyBatis-的一级缓存和二级缓存？-1" class="headerlink" title="130. 说一下 MyBatis 的一级缓存和二级缓存？"></a><strong>130. 说一下 MyBatis 的一级缓存和二级缓存？</strong></h4><p>· 一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，它的声明周期是和 SQLSession 一致的，有多个 SQLSession 或者分布式的环境中数据库操作，可能会出现脏数据。当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认一级缓存是开启的。</p>
<p>· 二级缓存：也是基于 PerpetualCache 的 HashMap 本地缓存，不同在于其存储作用域为 Mapper 级别的，如果多个SQLSession之间需要共享缓存，则需要使用到二级缓存，并且二级缓存可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态)。</p>
<p>开启二级缓存数据查询流程：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p>缓存更新机制：当某一个作用域(一级缓存 Session/二级缓存 Mapper)进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h4 id="131-MyBatis-和-hibernate-的区别有哪些？-1"><a href="#131-MyBatis-和-hibernate-的区别有哪些？-1" class="headerlink" title="131. MyBatis 和 hibernate 的区别有哪些？"></a><strong>131. MyBatis 和 hibernate 的区别有哪些？</strong></h4><p>· 灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便。</p>
<p>· 可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差。</p>
<p>· 学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</p>
<p>· 二级缓存：hibernate 拥有更好的二级缓存，它的二级缓存可以自行更换为第三方的二级缓存。</p>
<h4 id="132-MyBatis-有哪些执行器（Executor）？-1"><a href="#132-MyBatis-有哪些执行器（Executor）？-1" class="headerlink" title="132. MyBatis 有哪些执行器（Executor）？"></a><strong>132. MyBatis 有哪些执行器（Executor）？</strong></h4><p>MyBatis 有三种基本的Executor执行器：</p>
<p>· SimpleExecutor：每执行一次 update 或 select 就开启一个 Statement 对象，用完立刻关闭 Statement 对象；</p>
<p>· ReuseExecutor：执行 update 或 select，以 SQL 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后不关闭 Statement 对象，而是放置于 Map 内供下一次使用。简言之，就是重复使用 Statement 对象；</p>
<p>· BatchExecutor：执行 update（没有 select，jdbc 批处理不支持 select），将所有 SQL 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理，与 jdbc 批处理相同。</p>
<h4 id="133-MyBatis-分页插件的实现原理是什么？-1"><a href="#133-MyBatis-分页插件的实现原理是什么？-1" class="headerlink" title="133. MyBatis 分页插件的实现原理是什么？"></a><strong>133. MyBatis 分页插件的实现原理是什么？</strong></h4><p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 SQL，然后重写 SQL，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<h4 id="134-MyBatis-如何编写一个自定义插件？-1"><a href="#134-MyBatis-如何编写一个自定义插件？-1" class="headerlink" title="134. MyBatis 如何编写一个自定义插件？"></a><strong>134. MyBatis 如何编写一个自定义插件？</strong></h4><p><strong>自定义插件实现原理</strong></p>
<p>MyBatis 自定义插件针对 MyBatis 四大对象（Executor、StatementHandler、ParameterHandler、ResultSetHandler）进行拦截：</p>
<p>· Executor：拦截内部执行器，它负责调用 StatementHandler 操作数据库，并把结果集通过 ResultSetHandler 进行自动映射，另外它还处理了二级缓存的操作；</p>
<p>· StatementHandler：拦截 SQL 语法构建的处理，它是 MyBatis 直接和数据库执行 SQL 脚本的对象，另外它也实现了 MyBatis 的一级缓存；</p>
<p>· ParameterHandler：拦截参数的处理；</p>
<p>· ResultSetHandler：拦截结果集的处理。</p>
<p><strong>自定义插件实现关键</strong></p>
<p>MyBatis 插件要实现 Interceptor 接口，接口包含的方法，如下：</p>
<p><strong>public</strong> <strong>interface</strong> <strong>Interceptor</strong> {   </p>
<p>   Object <strong>intercept</strong>(Invocation invocation) <strong>throws</strong> Throwable;       </p>
<p>   Object <strong>plugin</strong>(Object target);    </p>
<p>   <strong>void</strong> <strong>setProperties</strong>(Properties properties);</p>
<p>}</p>
<p>· setProperties 方法是在 MyBatis 进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</p>
<p>· plugin 方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin. wrap(target, this)；</p>
<p>· intercept 方法就是要进行拦截的时候要执行的方法。</p>
<p><strong>自定义插件实现示例</strong></p>
<p>官方插件实现：</p>
<p>@Intercepts({@Signature(type = Executor. <strong>class</strong>, <strong>method</strong> = “query”,</p>
<p>​        args = {MappedStatement. <strong>class</strong>, <strong>Object</strong>. <strong>class</strong>, <strong>RowBounds</strong>. <strong>class</strong>, <strong>ResultHandler</strong>. <strong>class</strong>})})<strong>public</strong> <strong>class</strong> <strong>TestInterceptor</strong> <strong>implements</strong> <strong>Interceptor</strong> {</p>
<p>   <strong>public</strong> Object <strong>intercept</strong>(Invocation invocation) <strong>throws</strong> Throwable {</p>
<p>​     Object target = invocation. getTarget(); <em>//被代理对象</em></p>
<p>​     Method method = invocation. getMethod(); <em>//代理方法</em></p>
<p>​     Object[] args = invocation. getArgs(); <em>//方法参数</em></p>
<p>​     <em>// do something . . . . . .  方法拦截前执行代码块</em></p>
<p>​     Object result = invocation. proceed();</p>
<p>​     <em>// do something . . . . . . . 方法拦截后执行代码块</em></p>
<p>​     <strong>return</strong> result;  }</p>
<p>   <strong>public</strong> Object <strong>plugin</strong>(Object target) {</p>
<p>​     <strong>return</strong> Plugin. wrap(target, <strong>this</strong>);</p>
<p>   }</p>
<p>}</p>
<h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h3><h4 id="135-RabbitMQ-的使用场景有哪些？-1"><a href="#135-RabbitMQ-的使用场景有哪些？-1" class="headerlink" title="135. RabbitMQ 的使用场景有哪些？"></a><strong>135. RabbitMQ 的使用场景有哪些？</strong></h4><p>· 抢购活动，削峰填谷，防止系统崩塌。</p>
<p>· 延迟信息处理，比如 10 分钟之后给下单未付款的用户发送邮件提醒。</p>
<p>· 解耦系统，对于新增的功能可以单独写模块扩展，比如用户确认评价之后，新增了给用户返积分的功能，这个时候不用在业务代码里添加新增积分的功能，只需要把新增积分的接口订阅确认评价的消息队列即可，后面再添加任何功能只需要订阅对应的消息队列即可。</p>
<h4 id="136-RabbitMQ-有哪些重要的角色？-1"><a href="#136-RabbitMQ-有哪些重要的角色？-1" class="headerlink" title="136. RabbitMQ 有哪些重要的角色？"></a><strong>136. RabbitMQ 有哪些重要的角色？</strong></h4><p>RabbitMQ 中重要的角色有：生产者、消费者和代理：</p>
<p>· 生产者：消息的创建者，负责创建和推送数据到消息服务器；</p>
<p>· 消费者：消息的接收方，用于处理数据和确认消息；</p>
<p>· 代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</p>
<h4 id="137-RabbitMQ-有哪些重要的组件？-1"><a href="#137-RabbitMQ-有哪些重要的组件？-1" class="headerlink" title="137. RabbitMQ 有哪些重要的组件？"></a><strong>137. RabbitMQ 有哪些重要的组件？</strong></h4><p>· ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</p>
<p>· Channel（信道）：消息推送使用的通道。</p>
<p>· Exchange（交换器）：用于接受、分配消息。</p>
<p>· Queue（队列）：用于存储生产者的消息。</p>
<p>· RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</p>
<p>· BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</p>
<h4 id="138-RabbitMQ-中-vhost-的作用是什么？-1"><a href="#138-RabbitMQ-中-vhost-的作用是什么？-1" class="headerlink" title="138. RabbitMQ 中 vhost 的作用是什么？"></a><strong>138. RabbitMQ 中 vhost 的作用是什么？</strong></h4><p>· vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p>
<h4 id="139-RabbitMQ-的消息是怎么发送的？-1"><a href="#139-RabbitMQ-的消息是怎么发送的？-1" class="headerlink" title="139. RabbitMQ 的消息是怎么发送的？"></a><strong>139. RabbitMQ 的消息是怎么发送的？</strong></h4><p>· 首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。</p>
<h4 id="140-RabbitMQ-怎么保证消息的稳定性？-1"><a href="#140-RabbitMQ-怎么保证消息的稳定性？-1" class="headerlink" title="140. RabbitMQ 怎么保证消息的稳定性？"></a><strong>140. RabbitMQ 怎么保证消息的稳定性？</strong></h4><p>· 提供了事务的功能。</p>
<p>· 通过将 channel 设置为 confirm（确认）模式。</p>
<h4 id="141-RabbitMQ-怎么避免消息丢失？-1"><a href="#141-RabbitMQ-怎么避免消息丢失？-1" class="headerlink" title="141. RabbitMQ 怎么避免消息丢失？"></a><strong>141. RabbitMQ 怎么避免消息丢失？</strong></h4><p>· 把消息持久化磁盘，保证服务器重启消息不丢失。</p>
<p>· 每个集群中至少有一个物理磁盘，保证消息落入磁盘。</p>
<h4 id="142-要保证消息持久化成功的条件有哪些？-1"><a href="#142-要保证消息持久化成功的条件有哪些？-1" class="headerlink" title="142. 要保证消息持久化成功的条件有哪些？"></a><strong>142. 要保证消息持久化成功的条件有哪些？</strong></h4><p>· 声明队列必须设置持久化 durable 设置为 true.</p>
<p>· 消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</p>
<p>· 消息已经到达持久化交换器。</p>
<p>· 消息已经到达持久化队列。</p>
<p>· 以上四个条件都满足才能保证消息持久化成功。</p>
<h4 id="143-RabbitMQ-持久化有什么缺点？-1"><a href="#143-RabbitMQ-持久化有什么缺点？-1" class="headerlink" title="143. RabbitMQ 持久化有什么缺点？"></a><strong>143. RabbitMQ 持久化有什么缺点？</strong></h4><p>· 持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p>
<h4 id="144-RabbitMQ-有几种广播类型？-1"><a href="#144-RabbitMQ-有几种广播类型？-1" class="headerlink" title="144. RabbitMQ 有几种广播类型？"></a><strong>144. RabbitMQ 有几种广播类型？</strong></h4><p>· direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。</p>
<p>· headers：与 direct 类似，只是性能很差，此类型几乎用不到。</p>
<p>· fanout：分发模式，把消费分发给所有订阅者。</p>
<p>· topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。</p>
<h4 id="145-RabbitMQ-怎么实现延迟消息队列？-1"><a href="#145-RabbitMQ-怎么实现延迟消息队列？-1" class="headerlink" title="145. RabbitMQ 怎么实现延迟消息队列？"></a><strong>145. RabbitMQ 怎么实现延迟消息队列？</strong></h4><p>延迟队列的实现有两种方式：</p>
<p>· 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</p>
<p>· 使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</p>
<h4 id="146-RabbitMQ-集群有什么用？-1"><a href="#146-RabbitMQ-集群有什么用？-1" class="headerlink" title="146. RabbitMQ 集群有什么用？"></a><strong>146. RabbitMQ 集群有什么用？</strong></h4><p>集群主要有以下两个用途：</p>
<p>· 高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</p>
<p>· 高容量：集群可以承载更多的消息量。</p>
<h4 id="147-RabbitMQ-节点的类型有哪些？-1"><a href="#147-RabbitMQ-节点的类型有哪些？-1" class="headerlink" title="147. RabbitMQ 节点的类型有哪些？"></a><strong>147. RabbitMQ 节点的类型有哪些？</strong></h4><p>· 磁盘节点：消息会存储到磁盘。</p>
<p>· 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</p>
<h4 id="148-RabbitMQ-集群搭建需要注意哪些问题？-1"><a href="#148-RabbitMQ-集群搭建需要注意哪些问题？-1" class="headerlink" title="148. RabbitMQ 集群搭建需要注意哪些问题？"></a><strong>148. RabbitMQ 集群搭建需要注意哪些问题？</strong></h4><p>· 各节点之间使用“–link”连接，此属性不能忽略。</p>
<p>· 各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</p>
<p>· 整个集群中必须包含一个磁盘节点。</p>
<h4 id="-25"><a href="#-25" class="headerlink" title></a></h4><h4 id="-26"><a href="#-26" class="headerlink" title></a></h4><h4 id="149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？-1"><a href="#149-RabbitMQ-每个节点是其他节点的完整拷贝吗？为什么？-1" class="headerlink" title="149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？"></a><strong>149. RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</strong></h4><p>不是，原因有以下两个：</p>
<p>· 存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</p>
<p>· 性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</p>
<h4 id="150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？-1"><a href="#150-RabbitMQ-集群中唯一一个磁盘节点崩溃了会发生什么情况？-1" class="headerlink" title="150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a><strong>150. RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</strong></h4><p>如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作：</p>
<p>· 不能创建队列</p>
<p>· 不能创建交换器</p>
<p>· 不能创建绑定</p>
<p>· 不能添加用户</p>
<p>· 不能更改权限</p>
<p>· 不能添加和删除集群节点</p>
<p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<h4 id="151-RabbitMQ-对集群节点停止顺序有要求吗？-1"><a href="#151-RabbitMQ-对集群节点停止顺序有要求吗？-1" class="headerlink" title="151. RabbitMQ 对集群节点停止顺序有要求吗？"></a><strong>151. RabbitMQ 对集群节点停止顺序有要求吗？</strong></h4><p>RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。</p>
<h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a><strong>Kafka</strong></h3><h4 id="152-kafka-可以脱离-zookeeper-单独使用吗？为什么？-1"><a href="#152-kafka-可以脱离-zookeeper-单独使用吗？为什么？-1" class="headerlink" title="152. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a><strong>152. kafka 可以脱离 zookeeper 单独使用吗？为什么？</strong></h4><p>kafka 不能脱离 zookeeper 单独使用，因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p>
<h4 id="153-kafka-有几种数据保留的策略？-1"><a href="#153-kafka-有几种数据保留的策略？-1" class="headerlink" title="153. kafka 有几种数据保留的策略？"></a><strong>153. kafka 有几种数据保留的策略？</strong></h4><p>kafka 有两种数据保存策略：按照过期时间保留和按照存储的消息大小保留。</p>
<h4 id="154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？-1"><a href="#154-kafka-同时设置了-7-天和-10G-清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？-1" class="headerlink" title="154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a><strong>154. kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</strong></h4><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p>
<h4 id="155-什么情况会导致-kafka-运行变慢？-1"><a href="#155-什么情况会导致-kafka-运行变慢？-1" class="headerlink" title="155. 什么情况会导致 kafka 运行变慢？"></a><strong>155. 什么情况会导致 kafka 运行变慢？</strong></h4><p>· cpu 性能瓶颈</p>
<p>· 磁盘读写瓶颈</p>
<p>· 网络瓶颈</p>
<h4 id="156-使用-kafka-集群需要注意什么？-1"><a href="#156-使用-kafka-集群需要注意什么？-1" class="headerlink" title="156. 使用 kafka 集群需要注意什么？"></a><strong>156. 使用 kafka 集群需要注意什么？</strong></h4><p>· 集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</p>
<p>· 集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</p>
<h3 id="Zookeeper-1"><a href="#Zookeeper-1" class="headerlink" title="Zookeeper"></a><strong>Zookeeper</strong></h3><h4 id="157-zookeeper-是什么？-1"><a href="#157-zookeeper-是什么？-1" class="headerlink" title="157. zookeeper 是什么？"></a><strong>157. zookeeper 是什么？</strong></h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>
<h4 id="158-zookeeper-都有哪些功能？-1"><a href="#158-zookeeper-都有哪些功能？-1" class="headerlink" title="158. zookeeper 都有哪些功能？"></a><strong>158. zookeeper 都有哪些功能？</strong></h4><p>· 集群管理：监控节点存活状态、运行请求等。</p>
<p>· 主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。</p>
<p>· 分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。</p>
<p>· 命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>
<h4 id="-27"><a href="#-27" class="headerlink" title></a></h4><h4 id="159-zookeeper-有几种部署模式？-1"><a href="#159-zookeeper-有几种部署模式？-1" class="headerlink" title="159. zookeeper 有几种部署模式？"></a><strong>159. zookeeper 有几种部署模式？</strong></h4><p>zookeeper 有三种部署模式：</p>
<p>· 单机部署：一台集群上运行；</p>
<p>· 集群部署：多台集群运行；</p>
<p>· 伪集群部署：一台集群启动多个 zookeeper 实例运行。</p>
<h4 id="160-zookeeper-怎么保证主从节点的状态同步？-1"><a href="#160-zookeeper-怎么保证主从节点的状态同步？-1" class="headerlink" title="160. zookeeper 怎么保证主从节点的状态同步？"></a><strong>160. zookeeper 怎么保证主从节点的状态同步？</strong></h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>
<h4 id="161-集群中为什么要有主节点？-1"><a href="#161-集群中为什么要有主节点？-1" class="headerlink" title="161. 集群中为什么要有主节点？"></a><strong>161. 集群中为什么要有主节点？</strong></h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>
<h4 id="162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？-1"><a href="#162-集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？-1" class="headerlink" title="162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？"></a><strong>162. 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</strong></h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>
<h4 id="163-说一下-zookeeper-的通知机制？-1"><a href="#163-说一下-zookeeper-的通知机制？-1" class="headerlink" title="163. 说一下 zookeeper 的通知机制？"></a><strong>163. 说一下 zookeeper 的通知机制？</strong></h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>
<h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h3><h4 id="164-数据库的三范式是什么？-1"><a href="#164-数据库的三范式是什么？-1" class="headerlink" title="164. 数据库的三范式是什么？"></a><strong>164. 数据库的三范式是什么？</strong></h4><p>· 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</p>
<p>· 第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p>
<p>· 第三范式：任何非主属性不依赖于其它非主属性。</p>
<h4 id="165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？-1"><a href="#165-一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-MySQL-数据库，又插入了一条数据，此时-id-是几？-1" class="headerlink" title="165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？"></a><strong>165. 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？</strong></h4><p>· 表类型如果是 MyISAM ，那 id 就是 8。</p>
<p>· 表类型如果是 InnoDB，那 id 就是 6。</p>
<p>InnoDB 表只会把自增主键的最大 id 记录在内存中，所以重启之后会导致最大 id 丢失。</p>
<h4 id="166-如何获取当前数据库版本？-1"><a href="#166-如何获取当前数据库版本？-1" class="headerlink" title="166. 如何获取当前数据库版本？"></a><strong>166. 如何获取当前数据库版本？</strong></h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p>
<h4 id="167-说一下-ACID-是什么？-1"><a href="#167-说一下-ACID-是什么？-1" class="headerlink" title="167. 说一下 ACID 是什么？"></a><strong>167. 说一下 ACID 是什么？</strong></h4><p>· Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</p>
<p>· Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</p>
<p>· Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<p>· Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h4 id="168-char-和-varchar-的区别是什么？-1"><a href="#168-char-和-varchar-的区别是什么？-1" class="headerlink" title="168. char 和 varchar 的区别是什么？"></a><strong>168. char 和 varchar 的区别是什么？</strong></h4><p>· char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>
<p>· chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>· varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>
<p>· 所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>
<h4 id="169-float-和-double-的区别是什么？-1"><a href="#169-float-和-double-的区别是什么？-1" class="headerlink" title="169. float 和 double 的区别是什么？"></a><strong>169. float 和 double 的区别是什么？</strong></h4><p>· float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。</p>
<p>· double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>
<h4 id="170-MySQL-的内连接、左连接、右连接有什么区别？-1"><a href="#170-MySQL-的内连接、左连接、右连接有什么区别？-1" class="headerlink" title="170. MySQL 的内连接、左连接、右连接有什么区别？"></a><strong>170. MySQL 的内连接、左连接、右连接有什么区别？</strong></h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>
<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>
<h4 id="171-MySQL-索引是怎么实现的？-1"><a href="#171-MySQL-索引是怎么实现的？-1" class="headerlink" title="171. MySQL 索引是怎么实现的？"></a><strong>171. MySQL 索引是怎么实现的？</strong></h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>
<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>
<h4 id="172-怎么验证-MySQL-的索引是否满足需求？-1"><a href="#172-怎么验证-MySQL-的索引是否满足需求？-1" class="headerlink" title="172. 怎么验证 MySQL 的索引是否满足需求？"></a><strong>172. 怎么验证 MySQL 的索引是否满足需求？</strong></h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>
<p>explain 语法：explain select * from table where type=1。</p>
<h4 id="173-说一下数据库的事务隔离？-1"><a href="#173-说一下数据库的事务隔离？-1" class="headerlink" title="173. 说一下数据库的事务隔离？"></a><strong>173. 说一下数据库的事务隔离？</strong></h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：</p>
<p>transaction-isolation = REPEATABLE-READ</p>
<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>
<p>· READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。</p>
<p>· READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。</p>
<p>· REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。</p>
<p>· SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
<p><strong>脏读</strong> ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。</p>
<p><strong>幻读</strong> ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
<h4 id="174-说一下-MySQL-常用的引擎？-1"><a href="#174-说一下-MySQL-常用的引擎？-1" class="headerlink" title="174. 说一下 MySQL 常用的引擎？"></a><strong>174. 说一下 MySQL 常用的引擎？</strong></h4><p>InnoDB 引擎：mysql 5.1 后默认的数据库引擎，提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>
<p>MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>
<h4 id="175-说一下-MySQL-的行锁和表锁？-1"><a href="#175-说一下-MySQL-的行锁和表锁？-1" class="headerlink" title="175. 说一下 MySQL 的行锁和表锁？"></a><strong>175. 说一下 MySQL 的行锁和表锁？</strong></h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>
<p>· 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</p>
<p>· 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>
<h4 id="-28"><a href="#-28" class="headerlink" title></a></h4><h4 id="176-说一下乐观锁和悲观锁？-1"><a href="#176-说一下乐观锁和悲观锁？-1" class="headerlink" title="176. 说一下乐观锁和悲观锁？"></a><strong>176. 说一下乐观锁和悲观锁？</strong></h4><p>· 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>· 悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>
<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h4 id="177-MySQL-问题排查都有哪些手段？-1"><a href="#177-MySQL-问题排查都有哪些手段？-1" class="headerlink" title="177. MySQL 问题排查都有哪些手段？"></a><strong>177. MySQL 问题排查都有哪些手段？</strong></h4><p>· 使用 show processlist 命令查看当前所有连接信息。</p>
<p>· 使用 explain 命令查询 SQL 语句执行计划。</p>
<p>· 开启慢查询日志，查看慢查询的 SQL。</p>
<h4 id="178-如何做-MySQL-的性能优化？-1"><a href="#178-如何做-MySQL-的性能优化？-1" class="headerlink" title="178. 如何做 MySQL 的性能优化？"></a><strong>178. 如何做 MySQL 的性能优化？</strong></h4><p>· 为搜索字段创建索引。</p>
<p>· 避免使用 select *，列出需要查询的字段。</p>
<p>· 垂直分割分表。</p>
<p>· 选择正确的存储引擎。</p>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><h4 id="179-Redis-是什么？都有哪些使用场景？-1"><a href="#179-Redis-是什么？都有哪些使用场景？-1" class="headerlink" title="179. Redis 是什么？都有哪些使用场景？"></a><strong>179. Redis 是什么？都有哪些使用场景？</strong></h4><p>Redis 是一个使用 C 语言开发的高速缓存数据库。</p>
<p>Redis 使用场景：</p>
<p>· 记录帖子点赞数、点击数、评论数；</p>
<p>· 缓存近期热帖；</p>
<p>· 缓存文章详情信息；</p>
<p>· 记录用户会话信息。</p>
<h4 id="-29"><a href="#-29" class="headerlink" title></a></h4><h4 id="180-Redis-有哪些功能？-1"><a href="#180-Redis-有哪些功能？-1" class="headerlink" title="180. Redis 有哪些功能？"></a><strong>180. Redis 有哪些功能？</strong></h4><p>· 数据缓存功能</p>
<p>· 分布式锁的功能</p>
<p>· 支持数据持久化</p>
<p>· 支持事务</p>
<p>· 支持消息队列</p>
<h4 id="181-Redis-和-memcache-有什么区别？-1"><a href="#181-Redis-和-memcache-有什么区别？-1" class="headerlink" title="181. Redis 和 memcache 有什么区别？"></a><strong>181. Redis 和 memcache 有什么区别？</strong></h4><p>· 存储方式不同：memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。</p>
<p>· 数据支持类型：memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。</p>
<p>· 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
<p>· value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。</p>
<h4 id="182-Redis-为什么是单线程的？-1"><a href="#182-Redis-为什么是单线程的？-1" class="headerlink" title="182. Redis 为什么是单线程的？"></a><strong>182. Redis 为什么是单线程的？</strong></h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>
<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>
<h4 id="183-什么是缓存穿透？怎么解决？-1"><a href="#183-什么是缓存穿透？怎么解决？-1" class="headerlink" title="183. 什么是缓存穿透？怎么解决？"></a><strong>183. 什么是缓存穿透？怎么解决？</strong></h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>
<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>
<h4 id="184-Redis-支持的数据类型有哪些？-1"><a href="#184-Redis-支持的数据类型有哪些？-1" class="headerlink" title="184. Redis 支持的数据类型有哪些？"></a><strong>184. Redis 支持的数据类型有哪些？</strong></h4><p>Redis 支持的数据类型：string（字符串）、list（列表）、hash（字典）、set（集合）、zset（有序集合）。</p>
<h4 id="185-Redis-支持的-Java-客户端都有哪些？-1"><a href="#185-Redis-支持的-Java-客户端都有哪些？-1" class="headerlink" title="185. Redis 支持的 Java 客户端都有哪些？"></a><strong>185. Redis 支持的 Java 客户端都有哪些？</strong></h4><p>支持的 Java 客户端有 Redisson、jedis、lettuce 等。</p>
<h4 id="186-jedis-和-Redisson-有哪些区别？-1"><a href="#186-jedis-和-Redisson-有哪些区别？-1" class="headerlink" title="186. jedis 和 Redisson 有哪些区别？"></a><strong>186. jedis 和 Redisson 有哪些区别？</strong></h4><p>· jedis：提供了比较全面的 Redis 命令的支持。</p>
<p>· Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。</p>
<h4 id="187-怎么保证缓存和数据库数据的一致性？-1"><a href="#187-怎么保证缓存和数据库数据的一致性？-1" class="headerlink" title="187. 怎么保证缓存和数据库数据的一致性？"></a><strong>187. 怎么保证缓存和数据库数据的一致性？</strong></h4><p>· 合理设置缓存的过期时间。</p>
<p>· 新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>
<h4 id="188-Redis-持久化有几种方式？-1"><a href="#188-Redis-持久化有几种方式？-1" class="headerlink" title="188. Redis 持久化有几种方式？"></a><strong>188. Redis 持久化有几种方式？</strong></h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p>
<p>· RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p>
<p>· AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p>
<h4 id="189-Redis-怎么实现分布式锁？-1"><a href="#189-Redis-怎么实现分布式锁？-1" class="headerlink" title="189. Redis 怎么实现分布式锁？"></a><strong>189. Redis 怎么实现分布式锁？</strong></h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>
<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>
<h4 id="190-Redis-分布式锁有什么缺陷？-1"><a href="#190-Redis-分布式锁有什么缺陷？-1" class="headerlink" title="190. Redis 分布式锁有什么缺陷？"></a><strong>190. Redis 分布式锁有什么缺陷？</strong></h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>
<h4 id="-30"><a href="#-30" class="headerlink" title></a></h4><h4 id="191-Redis-如何做内存优化？-1"><a href="#191-Redis-如何做内存优化？-1" class="headerlink" title="191. Redis 如何做内存优化？"></a><strong>191. Redis 如何做内存优化？</strong></h4><p>尽量使用 Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。</p>
<h4 id="192-Redis-淘汰策略有哪些？-1"><a href="#192-Redis-淘汰策略有哪些？-1" class="headerlink" title="192. Redis 淘汰策略有哪些？"></a><strong>192. Redis 淘汰策略有哪些？</strong></h4><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p>
<p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p>
<p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p>
<p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p>
<p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</p>
<p>no-enviction（驱逐）：禁止驱逐数据。</p>
<h4 id="193-Redis-常见的性能问题有哪些？该如何解决？-1"><a href="#193-Redis-常见的性能问题有哪些？该如何解决？-1" class="headerlink" title="193. Redis 常见的性能问题有哪些？该如何解决？"></a><strong>193. Redis 常见的性能问题有哪些？该如何解决？</strong></h4><p>· 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</p>
<p>· Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>
<h3 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a><strong>JVM</strong></h3><h4 id="194-说一下-JVM-的主要组成部分？及其作用？-1"><a href="#194-说一下-JVM-的主要组成部分？及其作用？-1" class="headerlink" title="194. 说一下 JVM 的主要组成部分？及其作用？"></a><strong>194. 说一下 JVM 的主要组成部分？及其作用？</strong></h4><p>· 类加载器（ClassLoader）</p>
<p>· 运行时数据区（Runtime Data Area）</p>
<p>· 执行引擎（Execution Engine）</p>
<p>· 本地库接口（Native Interface）</p>
<p><strong>组件的作用：</strong> 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
<h4 id="195-说一下-JVM-运行时数据区？-1"><a href="#195-说一下-JVM-运行时数据区？-1" class="headerlink" title="195. 说一下 JVM 运行时数据区？"></a><strong>195. 说一下 JVM 运行时数据区？</strong></h4><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
<p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p>
<p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p>
<p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p>
<p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
<h4 id="196-说一下堆栈的区别？-1"><a href="#196-说一下堆栈的区别？-1" class="headerlink" title="196. 说一下堆栈的区别？"></a><strong>196. 说一下堆栈的区别？</strong></h4><p>· 功能方面：堆是用来存放对象的，栈是用来执行程序的。</p>
<p>· 共享性：堆是线程共享的，栈是线程私有的。</p>
<p>· 空间大小：堆大小远远大于栈。</p>
<h4 id="197-队列和栈是什么？有什么区别？-1"><a href="#197-队列和栈是什么？有什么区别？-1" class="headerlink" title="197. 队列和栈是什么？有什么区别？"></a><strong>197. 队列和栈是什么？有什么区别？</strong></h4><p>· 队列和栈都是被用来预存储数据的。</p>
<p>· 队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p>
<p>· 栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
<h4 id="198-什么是双亲委派模型？-1"><a href="#198-什么是双亲委派模型？-1" class="headerlink" title="198. 什么是双亲委派模型？"></a><strong>198. 什么是双亲委派模型？</strong></h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<p>· 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p>
<p>· 其他类加载器：</p>
<p>· 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</p>
<p>· 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>
<h4 id="199-说一下类装载的执行过程？-1"><a href="#199-说一下类装载的执行过程？-1" class="headerlink" title="199. 说一下类装载的执行过程？"></a><strong>199. 说一下类装载的执行过程？</strong></h4><p>类装载分为以下 5 个步骤：</p>
<p>· 加载：根据查找路径找到相应的 class 文件然后导入；</p>
<p>· 检查：检查加载的 class 文件的正确性；</p>
<p>· 准备：给类中的静态变量分配内存空间；</p>
<p>· 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p>
<p>· 初始化：对静态变量和静态代码块执行初始化工作。</p>
<h4 id="200-怎么判断对象是否可以被回收？-1"><a href="#200-怎么判断对象是否可以被回收？-1" class="headerlink" title="200. 怎么判断对象是否可以被回收？"></a><strong>200. 怎么判断对象是否可以被回收？</strong></h4><p>一般有两种方法来判断：</p>
<p>· 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p>
<p>· 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
<h4 id="201-Java-中都有哪些引用类型？-1"><a href="#201-Java-中都有哪些引用类型？-1" class="headerlink" title="201. Java 中都有哪些引用类型？"></a><strong>201. Java 中都有哪些引用类型？</strong></h4><p>· 强引用：发生 gc 的时候不会被回收。</p>
<p>· 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
<p>· 弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
<p>· 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
<h4 id="202-说一下-JVM-有哪些垃圾回收算法？-1"><a href="#202-说一下-JVM-有哪些垃圾回收算法？-1" class="headerlink" title="202. 说一下 JVM 有哪些垃圾回收算法？"></a><strong>202. 说一下 JVM 有哪些垃圾回收算法？</strong></h4><p>· 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p>
<p>· 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p>
<p>· 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p>
<p>· 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p>
<h4 id="203-说一下-JVM-有哪些垃圾回收器？-1"><a href="#203-说一下-JVM-有哪些垃圾回收器？-1" class="headerlink" title="203. 说一下 JVM 有哪些垃圾回收器？"></a><strong>203. 说一下 JVM 有哪些垃圾回收器？</strong></h4><p>· Serial：最早的单线程串行垃圾回收器。</p>
<p>· Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</p>
<p>· ParNew：是 Serial 的多线程版本。</p>
<p>· Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</p>
<p>· Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p>
<p>· CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p>
<p>· G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
<h4 id="204-详细介绍一下-CMS-垃圾回收器？-1"><a href="#204-详细介绍一下-CMS-垃圾回收器？-1" class="headerlink" title="204. 详细介绍一下 CMS 垃圾回收器？"></a><strong>204. 详细介绍一下 CMS 垃圾回收器？</strong></h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
<h4 id="205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？-1"><a href="#205-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？-1" class="headerlink" title="205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a><strong>205.</strong> <strong>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</strong></h4><p>· 新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>· 老年代回收器：Serial Old、Parallel Old、CMS</p>
<p>· 整堆回收器：G1</p>
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h4 id="206-简述分代垃圾回收器是怎么工作的？-1"><a href="#206-简述分代垃圾回收器是怎么工作的？-1" class="headerlink" title="206. 简述分代垃圾回收器是怎么工作的？"></a><strong>206. 简述分代垃圾回收器是怎么工作的？</strong></h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>· 把 Eden + From Survivor 存活的对象放入 To Survivor 区；</p>
<p>· 清空 Eden 和 From Survivor 分区；</p>
<p>· From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p>
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h4 id="-31"><a href="#-31" class="headerlink" title></a></h4><h4 id="-32"><a href="#-32" class="headerlink" title></a></h4><h4 id="207-说一下-JVM-调优的工具？-1"><a href="#207-说一下-JVM-调优的工具？-1" class="headerlink" title="207. 说一下 JVM 调优的工具？"></a><strong>207. 说一下 JVM 调优的工具？</strong></h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>· jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p>
<p>· jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h4 id="208-常用的-JVM-调优的参数都有哪些？-1"><a href="#208-常用的-JVM-调优的参数都有哪些？-1" class="headerlink" title="208. 常用的 JVM 调优的参数都有哪些？"></a><strong>208. 常用的 JVM 调优的参数都有哪些？</strong></h4><p>· -Xms2g：初始化推大小为 2g；</p>
<p>· -Xmx2g：堆最大内存为 2g；</p>
<p>· -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p>
<p>· -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p>
<p>· –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p>
<p>· -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p>
<p>· -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p>
<p>· -XX:+PrintGC：开启打印 gc 信息；</p>
<p>· -XX:+PrintGCDetails：打印 gc 详细信息。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程-线程共享与协作</title>
    <url>/posts/e2044221/</url>
    <content><![CDATA[<h3 id="多核并发缓存架构和jmm模型"><a href="#多核并发缓存架构和jmm模型" class="headerlink" title="多核并发缓存架构和jmm模型"></a>多核并发缓存架构和jmm模型</h3><p>​    <strong>java线程内存模型</strong></p><p>​        java线程内存模型跟cpu缓存类似，是基于cpu缓存模型来建立的，Java线程内存模型是标准化的，屏蔽掉了底层不同的</p><p>编写案例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XianChenTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initFlag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1进来了"</span>);</span><br><span class="line">            <span class="keyword">while</span> (initFlag)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程1结束了"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程2进来了"</span>);</span><br><span class="line">            initFlag = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">"线程2结束了"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">线程1进来了</span></span><br><span class="line"><span class="comment">线程2进来了</span></span><br><span class="line"><span class="comment">线程2结束了</span></span><br><span class="line"><span class="comment">循环还是一直正在进行中</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><a id="more"></a>




<p><img alt="Java线程内存模型JMM2" data-src="D:%5C%E8%B5%84%E6%96%99%5CJava%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM2.png"></p>
<h4 id="内存执行步骤"><a href="#内存执行步骤" class="headerlink" title="内存执行步骤"></a>内存执行步骤</h4><ol>
<li>工作内存通过read到主内存中读取共享资源</li>
<li>共享资源通过load指令加载到工作内存中</li>
<li>如果工作内存要使用共享资源则调用use指令</li>
<li>如果工作内存要修改共享资源则执行assign指令</li>
<li>如果共享资源被修改则会调用store命令读取出来</li>
<li>然后再调用write命令写入到主内存中</li>
</ol>
<p><strong>导致程序未能同步原因 线程2修改了initFlag并写入到了主内存中，但是线程1未能接收通知使用的依旧是之前读取的initFlag所以导致线程一直在运行停不下来</strong></p>
<p><strong>解决方案1：</strong></p>
<p>​        使用lock锁，锁定initFlag使得需要获取到initFlag必须得获取到锁，保证在同一时刻只有一个线程在使用initFlag，产生问题： 这样会导致需要获取initFlag的线程从多个线程并行执行到一个个线程串行执行，极大影响了系统性能；</p>
<p><strong>解决方案2：</strong></p>
<p>​        使用volatile关键字修饰initFlag，因为volatile底层的运行逻辑是 会先让所有的线程开启cpu总线嗅探机制，当所有线程获取到了initFlag时，如果有一个线程修改了initFlag，那么他在store回主内存时在经过总线时会触发MESI缓存一致性，缓存一致性会去通知到cpu总线的嗅探机制，那么接收到通知的线程 会去把initFlag设置为失效，下次使用的时候直接到总内存中读取最新的initFlag 不过为了防止并发问题也会到store处加锁 直到write成功才释放</p>
<h4 id="JMM数据原子操作"><a href="#JMM数据原子操作" class="headerlink" title="JMM数据原子操作"></a>JMM数据原子操作</h4><ul>
<li>read :从主内存读取数据</li>
<li>load : 将主内存读取到的数据写入工作内存</li>
<li>use : 从工作内存读取数据来计算</li>
<li>assign ： 将计算好的值重新赋值到工作内存中</li>
<li>store： 将工作内存中的数据写入主内存</li>
<li>write: 将store过去的变量值赋值给主内存中的变量</li>
<li>lock: 将主内存变量加锁，标识为线程独占状态</li>
<li>unlock：将主内存变量解锁，解锁后其他线程可以锁定该变量</li>
</ul>
<h3 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h3><p>​    线程是与物理CPU息息相关的，也就是说一个核心数对应一个线程，在因特尔引入了超核心数的技术 就变化成了一个核心对应两个线程。</p>
<h3 id="CPU时间片轮转机制"><a href="#CPU时间片轮转机制" class="headerlink" title="CPU时间片轮转机制"></a>CPU时间片轮转机制</h3><p>在系统运行多个线程时，由于内核无法对应太多线程的消耗，所以需要在多个线程之间来回切换，也就是上下文切换一般需要5千个时钟周期，大概需要占用线程运行20%左右的时间。</p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是程序运行分配的最小单位，一个进程内有多个线程，一起共享这个进程的资源，多个进程之间基本互不干扰，要进行通信的话要通过操作系统。</p>
<p>线程是CPU调度的最小单位，一个进程至少拥有一个线程</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p>   并行：系统可以同时处理的请求数</p>
<p>   并发：系统在一段时间内处理的请求数</p>
<h3 id="高并发编程的意义"><a href="#高并发编程的意义" class="headerlink" title="高并发编程的意义"></a>高并发编程的意义</h3><p>多个线程同时使用CPU，充实CPU使用率，提高程序性能，不过内存使用过高可能出现内存耗尽的情况，导致机器宕机</p>
<h3 id="获取当前进程运行中的所有线程"><a href="#获取当前进程运行中的所有线程" class="headerlink" title="获取当前进程运行中的所有线程"></a>获取当前进程运行中的所有线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</span><br><span class="line">       ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">       <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">           System.out.println(threadInfo.getThreadName());</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>一个main方法运行会产生以下线程</p>
<p><strong>Attach Listener</strong>：获取但前程序运行相关信息<br><strong>Signal Dispatcher</strong>：分发处理给虚拟机的线程<br><strong>Finalizer</strong>：结束运行时执行清理垃圾，但并不保证每次都会正常运行<br><strong>Reference Handler</strong>：负责清除引用<br><strong>main</strong>：当前线程</p>
<p><strong><code>Java程序天生就是多线程的</code></strong></p>
<h3 id="有几种开启新线程的方法？"><a href="#有几种开启新线程的方法？" class="headerlink" title="有几种开启新线程的方法？"></a>有几种开启新线程的方法？</h3><ol>
<li><p>直接继承类Thread重写run 方法 </p>
</li>
<li><p>实现Runnable重写run 方法并创建实现类对象，传递给Thread的构造</p>
</li>
<li><p>实现callable接口重写call方法并创建实现类对象，传递给FutureTask类构造，由于FutureTask实现了Runnable所以可以直接做为参数传递给Thread类开启线程。FutureTask类的get方法可以获取call方法的对应返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Thread创建线程</span></span><br><span class="line">      ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">      threadTest.start();</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//Runnable创建线程</span></span><br><span class="line">      RunnableTest runnableTest = <span class="keyword">new</span> RunnableTest();</span><br><span class="line">      <span class="keyword">new</span> Thread(runnableTest).start();</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//Callable创建线程</span></span><br><span class="line">      CallableTest callableTest = <span class="keyword">new</span> CallableTest();</span><br><span class="line">      FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(callableTest);</span><br><span class="line">      <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">      System.out.println(futureTask.get());</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="线程的安全停止"><a href="#线程的安全停止" class="headerlink" title="线程的安全停止"></a>线程的安全停止</h3><ol>
<li>自然执行完毕停止</li>
<li>出现异常，意外终止线程</li>
<li>stop()方法停止线程(无法保证线程资源正常释放可能导致未知问题)，resume()继续线程,suspend()暂停线程(都已过时因为可能导致死锁) </li>
<li>interrupt()中断一个线程，并不是强制停止一个线程，而是标注但前线程中断标注位为true</li>
<li>isInterrupt()判断但前线程是否属于中断 </li>
<li>静态的interrupt()也是判断一个线程是否属于中断状态 他会标注中断标志为false</li>
<li>Java线程是协作式的，因为要让线程完成自己的中止操作</li>
<li>调用一个线程的interrupt() 方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。</li>
</ol>
<h3 id="线程常用方法和线程的状态"><a href="#线程常用方法和线程的状态" class="headerlink" title="线程常用方法和线程的状态"></a>线程常用方法和线程的状态</h3><p>线程有  创建-&gt;就绪-&gt;运行-&gt;阻塞-&gt;死亡 五种状态</p>
<p>run()和start() ：run方法就是普通对象的普通方法，只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。</p>
<p>yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程的级别有1-10级 1为最高  默认省缺值是5</p>
<p>线程的优先级因系统而异 有些系统可能直接会把所有的优先级默认成5。</p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程一旦执行，只有主线程关闭才会关闭。</p>
<p>一般用于辅助主线程进行正常工作。</p>
<p><strong>使用</strong></p>
<p>​        需要在start方法<strong>前</strong>设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadTest.setDaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在使用守护线程时，try/finally不能保证一定执行，一旦主线程停止守护线程也会跟随立即停止  不会最后运行finally</p>
<h3 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a>synchronized内置锁</h3><p>用处：限制访问 各个线程之间去抢夺synchronized的标志位，谁吧标志位指向了自己  那么谁就获得了运行权</p>
<p>对象锁：在方法上加锁 或者在方法中加锁 限制但前对象只能排队进行访问</p>
<p>类锁：在类上定义，锁定但前类的class文件，对所有创建出来的对象进行限制。</p>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p> 轻量效率高的同步机制，但是线程不安全 不能保证原子性</p>
<p>适用环境：只有一个线程写多个线程读的时候</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>Thread local 包装成员变量能保证每一个线程只使用自己的那一份数据，每个线程之间互不干扰。</p>
<p>注意：由于每个线程都要开辟出来一个自己的内存空间，如果设置的类型占用内存大的话，可能会导致Thread local 占用内存太大</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h3><p>与synchronized一样是可重入锁，Synchronized是依赖于JVM实现的；而ReentrantLock是依赖于JDK实现的，是API层面的，需要Lock()和unLock()方法配合try/finally语句块来完成。ReentrantLock比Synchronized多了三项功能：等待可中断，可实现公平锁，可实现选择性通知（锁可绑定多个条件）。<br>关于上述三项功能的解释：<br>等待可中断是指线程可以选择放弃等待，改为处理其他事情，ReenTrantLock通过lock.lockInterruptibly()来实现的。<br>Synchronized只能是非公平锁。ReenTrantLock默认情况是非公平的，可以通过 ReentrantLock(boolean fair)构造方法来指定是公平锁还是非公平锁。<br>Synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，但被通知的线程是由JVM随机选择。Synchronized相当于整个Lock对象中只有一个单一的condition对象，所有的线程都注册在它一个对象身上。线程开始notifyAll()时，需要通知所有等待的线程，没有选择权，会造成很大的效率问题。而ReenTrantLock可以借助Condition对象实现选择性通知，具有更好的灵活性。比如：可以在一个Lock对象里创建多个Condition实例（即对象监视器），线程对像可以注册在指定的Condition中，从而可以有选择的进行线程通知，即使使用signalAll()方法也只会唤醒注册在该Condition实例中所有等待的线程。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud-Netflix 基本配置</title>
    <url>/posts/c0e48c42/</url>
    <content><![CDATA[<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><strong>pom</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>


<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 声明这个应用是一个EurekaServer</span></span><br></pre></td></tr></table></figure>

<p><strong>yml扩展</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment"># 是否注册自己的信息到EurekaServer，默认是true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 是否拉取其它服务的信息，默认是true</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a><strong>provider</strong></h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mydb1?useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span> <span class="comment">#当遇到同样名字的时候，是否允许覆盖注册</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址.</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableEurekaClient // 开启EurekaClient功能</span><br></pre></td></tr></table></figure>

<h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment"># 当其它服务获取地址时提供ip而不是hostname</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment"># 指定自己的ip信息，不指定的话会自己寻找</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient // 开启Eureka客户端</span><br></pre></td></tr></table></figure>



<h2 id="Hystix"><a href="#Hystix" class="headerlink" title="Hystix"></a>Hystix</h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//启动服务熔断</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod=<span class="string">"xxx"</span>) <span class="comment">//在对应方法上添加 指定处理的方法</span></span><br></pre></td></tr></table></figure>

<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">  	<span class="attr">default:</span></span><br><span class="line">        <span class="attr">execution:</span></span><br><span class="line">          <span class="attr">isolation:</span></span><br><span class="line">            <span class="attr">thread:</span></span><br><span class="line">              <span class="attr">timeoutInMilliseconds:</span> <span class="number">6000</span> <span class="comment"># 设置hystrix的超时时间为6000ms</span></span><br></pre></td></tr></table></figure>

<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>接口配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"user-service"</span>)  <span class="comment">//指定服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)  <span class="comment">//指定服务请求方法</span></span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启Feign功能</span></span><br></pre></td></tr></table></figure>

<p><strong>重试机制配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">user-service:</span>  <span class="string">//加服务名则是单个服务配置</span>  <span class="string">不加则是全局配置</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br></pre></td></tr></table></figure>

<p><strong>熔断支持</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure>

<h2 id="zuul"><a href="#zuul" class="headerlink" title="zuul"></a>zuul</h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-zuul</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span> <span class="comment"># 获取服务列表的周期：5s</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">retryable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">2</span> <span class="number">50</span> <span class="comment"># 连接超时时间(ms)</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">2000</span> <span class="comment"># 通信超时时间(ms)</span></span><br><span class="line">  <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作重试</span></span><br><span class="line">  <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">2</span> <span class="comment"># 同一服务不同实例的重试次数</span></span><br><span class="line">  <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 同一实例的重试次数</span></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMillisecond:</span> <span class="number">6000</span> <span class="comment"># 熔断超时时长：6000ms</span></span><br></pre></td></tr></table></figure>

<p><strong>启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span>  <span class="comment">//启动zuul网关</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span>  <span class="comment">//启动eureka客户端</span></span><br></pre></td></tr></table></figure>



<h2 id="消费者拉取服务列表"><a href="#消费者拉取服务列表" class="headerlink" title="消费者拉取服务列表"></a>消费者拉取服务列表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"user-service"</span>);</span><br><span class="line">      <span class="comment">//2、由于我们没有集群，只有一个，所以直接取出第一个</span></span><br><span class="line">      ServiceInstance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">      <span class="comment">//3、拼接URL</span></span><br><span class="line">      String url = <span class="string">"http://"</span>+instance.getHost()+<span class="string">":"</span>+instance.getPort()+<span class="string">"/user/"</span>+id;</span><br></pre></td></tr></table></figure>

<h2 id="设置服务心跳"><a href="#设置服务心跳" class="headerlink" title="设置服务心跳"></a>设置服务心跳</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span> <span class="comment"># 2秒即过期</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span> <span class="comment"># 1秒一次心跳</span></span><br></pre></td></tr></table></figure>

<h2 id="设置服务列表更新时间"><a href="#设置服务列表更新时间" class="headerlink" title="设置服务列表更新时间"></a>设置服务列表更新时间</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="失效剔除和自我保护"><a href="#失效剔除和自我保护" class="headerlink" title="失效剔除和自我保护"></a>失效剔除和自我保护</h2><p>服务每隔30秒会发生一次心跳,当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85% 如果超过了85% Eureka就会把服务保护起来并不会立即剔除</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（缺省为打开）</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">1000</span> <span class="comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></span><br></pre></td></tr></table></figure>

<h2 id="重试机制配置"><a href="#重试机制配置" class="headerlink" title="重试机制配置"></a>重试机制配置</h2><p><strong>pom</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>yml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">loadbalancer:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Spring Cloud的重试功能</span></span><br><span class="line"><span class="attr">user-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">ConnectTimeout:</span> <span class="number">250</span> <span class="comment"># Ribbon的连接超时时间</span></span><br><span class="line">    <span class="attr">ReadTimeout:</span> <span class="number">1000</span> <span class="comment"># Ribbon的数据读取超时时间</span></span><br><span class="line">    <span class="attr">OkToRetryOnAllOperations:</span> <span class="literal">true</span> <span class="comment"># 是否对所有操作都进行重试</span></span><br><span class="line">    <span class="attr">MaxAutoRetriesNextServer:</span> <span class="number">1</span> <span class="comment"># 切换实例的重试次数</span></span><br><span class="line">    <span class="attr">MaxAutoRetries:</span> <span class="number">1</span> <span class="comment"># 对当前实例的重试次数</span></span><br></pre></td></tr></table></figure>

<h2 id="zuul-的过滤器实现"><a href="#zuul-的过滤器实现" class="headerlink" title="zuul 的过滤器实现"></a><strong>zuul 的过滤器实现</strong></h2><ul>
<li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li>
<li><code>run</code>：过滤器的具体业务逻辑。</li>
<li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul>
<li><code>pre</code>：请求在被路由之前执行</li>
<li><code>routing</code>：在路由请求时调用</li>
<li><code>post</code>：在routing和errror过滤器之后调用</li>
<li><code>error</code>：处理请求时发生错误调用</li>
</ul>
</li>
<li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 登录校验，肯定是在前置拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 顺序设置为1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回true，代表过滤器生效。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 登录校验逻辑。</span></span><br><span class="line">        <span class="comment">// 1）获取Zuul提供的请求上下文对象</span></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 2) 从上下文中获取request对象</span></span><br><span class="line">        HttpServletRequest req = ctx.getRequest();</span><br><span class="line">        <span class="comment">// 3) 从请求中获取token</span></span><br><span class="line">        String token = req.getParameter(<span class="string">"access-token"</span>);</span><br><span class="line">        <span class="comment">// 4) 判断</span></span><br><span class="line">        <span class="keyword">if</span>(token == <span class="keyword">null</span> || <span class="string">""</span>.equals(token.trim()))&#123;</span><br><span class="line">            <span class="comment">// 没有token，登录校验失败，拦截</span></span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseBody(<span class="string">"没有权限"</span>);</span><br><span class="line">            <span class="comment">// 返回401状态码。也可以考虑重定向到登录页。</span></span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zuul-的熔断器实现"><a href="#zuul-的熔断器实现" class="headerlink" title="zuul 的熔断器实现"></a>zuul 的熔断器实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceFallbackProvider</span> <span class="keyword">implements</span> <span class="title">FallbackProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 表明是为哪个微服务提供回退，*表示为所有微服务提供回退</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"*"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">fallbackResponse</span><span class="params">(String route, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response(HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ClientHttpResponse <span class="title">response</span><span class="params">(<span class="keyword">final</span> HttpStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientHttpResponse() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpStatus <span class="title">getStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRawStatusCode</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status.value();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getStatusText</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> status.getReasonPhrase();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> InputStream <span class="title">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"服务不可用，请稍后再试。"</span>.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> HttpHeaders <span class="title">getHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// headers设定</span></span><br><span class="line">                HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">                MediaType mt = <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"json"</span>, Charset.forName(<span class="string">"GBK"</span>));</span><br><span class="line">                headers.setContentType(mt);</span><br><span class="line">                <span class="keyword">return</span> headers;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="附：齐全的服务提供者pom"><a href="#附：齐全的服务提供者pom" class="headerlink" title="附：齐全的服务提供者pom"></a>附：齐全的服务提供者pom</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入SSM整合SpringBoot jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mybatis.starter.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mapper.starter.version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">mapper.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pageHelper.starter.version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">pageHelper.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">durid.starter.version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">durid.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- eureka客户端启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- web启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 单元测试启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- jdbc启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mybatis启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通用Mapper启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 分页助手启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;durid.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- lombok  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>spring-cloud-Netflix</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>redis+spring-data-redis 的简单使用</title>
    <url>/posts/bbccbdd3/</url>
    <content><![CDATA[<h3 id="一、为什么使用"><a href="#一、为什么使用" class="headerlink" title="一、为什么使用"></a>一、为什么使用</h3><ol>
<li>解决应用服务器的cpu和内存压力</li>
<li>减少io的读操作，减轻io的压力</li>
<li>关系型数据库的扩展性不强，难以改变表结构</li>
</ol><h3 id="二、优点："><a href="#二、优点：" class="headerlink" title="二、优点："></a>二、优点：</h3><ol>
<li>nosql数据库没有关联关系，数据结构简单，拓展表比较容易</li>
<li>nosql读取速度快，对较大数据处理快</li>
</ol><h3 id="三、适用场景："><a href="#三、适用场景：" class="headerlink" title="三、适用场景："></a><strong>三、适用场景：</strong></h3><ol>
<li>数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求高的数据</li>
</ol><a id="more"></a>


<h3 id="四、不适场景："><a href="#四、不适场景：" class="headerlink" title="四、不适场景："></a>四、不适场景：</h3><ol>
<li>需要事务支持（非关系型数据库）</li>
<li>基于sql结构化查询储存，关系复杂</li>
</ol>
<h3 id="五、Spring-Data-Redis"><a href="#五、Spring-Data-Redis" class="headerlink" title="五、Spring Data Redis"></a>五、Spring Data Redis</h3><p> Spring-data-redis是spring大家族的一部分，提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。</p>
<p> spring-data-redis针对jedis提供了如下功能：</p>
<p>连接池自动管理，提供了一个高度封装的“RedisTemplate”类</p>
<p>针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口</p>
<p>ValueOperations：简单K-V操作</p>
<p>SetOperations：set类型数据操作</p>
<p>ZSetOperations：zset类型数据操作</p>
<p>HashOperations：针对map类型的数据操作</p>
<p>ListOperations：针对list类型的数据操作</p>
<h3 id="六、开始使用"><a href="#六、开始使用" class="headerlink" title="六、开始使用"></a>六、开始使用</h3><ol>
<li><p>创建一个spring-boot项目</p>
</li>
<li><p>加入pom文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.dszmr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-data-redis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 引入SSM整合SpringBoot jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mybatis.starter.version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">mybatis.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mapper.starter.version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">mapper.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pageHelper.starter.version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">pageHelper.starter.version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">durid.starter.version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">durid.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mybatis启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;durid.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 测试启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- pool连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- jedis --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- spring-boot-redis 启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test1</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span>  <span class="comment">###### redis 配置</span></span><br><span class="line">    <span class="attr">hostName:</span> <span class="number">106.54</span><span class="string">.*.***</span> <span class="comment"># ip地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span>  <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attr">password:</span> <span class="comment"># 无密码不填</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30000</span>  <span class="comment"># 连接超时时间 （默认1天）</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">shutdown-timeout:</span> <span class="number">100</span> <span class="comment"># 关闭超时时间 默认 100ms</span></span><br><span class="line">      <span class="attr">pool:</span> <span class="comment"># lettuce 连接池</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数 默认 8（-1 ：表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">60000</span> <span class="comment"># 连接池最大阻塞等待时间 默认-1ms （-1 :表示没有限制） 这里设置1分钟</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接  默认 8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接  默认 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Redis配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成对Redis的整合的一些配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.创建JedisPoolConfig对象。在该对象中完成一些链接池配置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@ConfigurationProperties</span>:会将前缀相同的内容创建一个实体。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.redis.pool"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">		JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">		<span class="comment">/*//最大空闲数</span></span><br><span class="line"><span class="comment">		config.setMaxIdle(10);</span></span><br><span class="line"><span class="comment">		//最小空闲数</span></span><br><span class="line"><span class="comment">		config.setMinIdle(5);</span></span><br><span class="line"><span class="comment">		//最大链接数</span></span><br><span class="line"><span class="comment">		config.setMaxTotal(20);*/</span></span><br><span class="line">		System.out.println(<span class="string">"默认值："</span>+config.getMaxIdle());</span><br><span class="line">		System.out.println(<span class="string">"默认值："</span>+config.getMinIdle());</span><br><span class="line">		System.out.println(<span class="string">"默认值："</span>+config.getMaxTotal());</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2.创建JedisConnectionFactory：配置redis链接信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.redis"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">(JedisPoolConfig config)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"配置完毕："</span>+config.getMaxIdle());</span><br><span class="line">		System.out.println(<span class="string">"配置完毕："</span>+config.getMinIdle());</span><br><span class="line">		System.out.println(<span class="string">"配置完毕："</span>+config.getMaxTotal());</span><br><span class="line"></span><br><span class="line">		JedisConnectionFactory factory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">		<span class="comment">//关联链接池的配置对象</span></span><br><span class="line">		factory.setPoolConfig(config);</span><br><span class="line">		<span class="comment">//配置链接Redis的信息</span></span><br><span class="line">		<span class="comment">//主机地址</span></span><br><span class="line">		<span class="comment">/*factory.setHostName("192.168.70.128");</span></span><br><span class="line"><span class="comment">		//端口</span></span><br><span class="line"><span class="comment">		factory.setPort(6379);*/</span></span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 3.创建RedisTemplate:用于执行Redis操作的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">(JedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">		RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">		<span class="comment">//关联</span></span><br><span class="line">		template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为key设置序列化器</span></span><br><span class="line">		template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">		<span class="comment">//为value设置序列化器</span></span><br><span class="line">		template.setValueSerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> template;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.model.Users;</span><br><span class="line"><span class="keyword">import</span> org.assertj.core.util.Lists;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.JdkSerializationRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= SpringDataRedisApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringbootRedisDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.opsForValue().set(<span class="string">"key"</span>, <span class="string">"bobokaoya..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String value = (String)<span class="keyword">this</span>.redisTemplate.opsForValue().get(<span class="string">"key"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加Users对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetUesrs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Users users = <span class="keyword">new</span> Users();</span><br><span class="line">        users.setAge(<span class="number">20</span>);</span><br><span class="line">        users.setName(<span class="string">"张三丰"</span>);</span><br><span class="line">        users.setId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//重新设置序列化器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.opsForValue().set(<span class="string">"users"</span>, users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取Users对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//重新设置序列化器</span></span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.setValueSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer());</span><br><span class="line">        Users users = (Users)<span class="keyword">this</span>.redisTemplate.opsForValue().get(<span class="string">"users"</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于JSON格式存Users对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSetUsersUseJSON</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Users users = <span class="keyword">new</span> Users();</span><br><span class="line">        users.setAge(<span class="number">20</span>);</span><br><span class="line">        users.setName(<span class="string">"李四丰"</span>);</span><br><span class="line">        users.setId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Users<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.opsForValue().set(<span class="string">"users_json"</span>, users);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于JSON格式取Users对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUseJSON</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.setValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Users<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        Users users = (Users)<span class="keyword">this</span>.redisTemplate.opsForValue().get(<span class="string">"users_json"</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testsetlist</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (redisTemplate.opsForList().size(<span class="string">"dsz"</span>) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            redisTemplate.opsForList().leftPop(<span class="string">"dsz"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list = Lists.newArrayList();</span><br><span class="line">        list.add(<span class="string">"1"</span>);</span><br><span class="line">        list.add(<span class="string">"2"</span>);</span><br><span class="line">        list.add(<span class="string">"3"</span>);</span><br><span class="line">        list.add(<span class="string">"4"</span>);</span><br><span class="line">        list.add(<span class="string">"5"</span>);</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate.opsForList().rightPushAll(<span class="string">"dsz"</span>,list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testgetlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Object&gt; dsz = <span class="keyword">this</span>.redisTemplate.opsForList().range(<span class="string">"dsz"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        dsz.forEach(s -&gt;&#123;</span><br><span class="line">            String s1 = String.valueOf(s);</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>spring全家桶</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus 使用</title>
    <url>/posts/8b8e6788/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
</ul><a id="more"></a>
<p>。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>pom依赖</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Spring Boot</span><br><span class="line">Maven：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">Gradle：</span><br><span class="line"></span><br><span class="line">compile group: 'com.baomidou', name: 'mybatis-plus-boot-starter', version: '3.3.1.tmp'</span><br><span class="line">#Spring MVC</span><br><span class="line">Maven:</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">Gradle：</span><br><span class="line"></span><br><span class="line">compile group: 'com.baomidou', name: 'mybatis-plus', version: '3.3.1.tmp'</span><br><span class="line"> 一个是为spring boot 项目时引用的依赖 一个是为web应用引用的依赖 最好不要一起引入</span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">   <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test1</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="comment"># 可省略，SpringBoot自动推断</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment">#外部化xml配置</span></span><br><span class="line">  <span class="comment">#config-location: classpath:mybatis-config.xml</span></span><br><span class="line">  <span class="comment">#指定外部化 MyBatis Properties 配置，通过该配置可以抽离配置，实现不同环境的配置部署</span></span><br><span class="line">  <span class="comment">#configuration-properties: classpath:mybatis/config.properties</span></span><br><span class="line">  <span class="comment">#xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置）</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/*.xml</span></span><br><span class="line">  <span class="comment">#MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">net.xinhuamm.noah.api.model.entity,net.xinhuamm.noah.api.model.dto</span></span><br><span class="line">  <span class="comment">#如果配置了该属性，则仅仅会扫描路径下以该类作为父类的域对象</span></span><br><span class="line">  <span class="comment">#type-aliases-super-type: java.lang.Object</span></span><br><span class="line">  <span class="comment">#枚举类 扫描路径，如果配置了该属性，会将路径下的枚举类进行注入，让实体类字段能够简单快捷的使用枚举属性</span></span><br><span class="line">  <span class="comment">#type-enums-package: com.baomidou.mybatisplus.samples.quickstart.enums</span></span><br><span class="line">  <span class="comment">#项目启动会检查xml配置存在(只在开发时候打开)</span></span><br><span class="line">  <span class="attr">check-config-location:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#SIMPLE：该执行器类型不做特殊的事情，为每个语句的执行创建一个新的预处理语句,REUSE：该执行器类型会复用预处理语句,BATCH：该执行器类型会批量执行所有的更新语句</span></span><br><span class="line">  <span class="attr">default-executor-type:</span> <span class="string">REUSE</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存，默认为 true</span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#懒加载</span></span><br><span class="line">    <span class="comment">#aggressive-lazy-loading: true</span></span><br><span class="line">    <span class="comment">#NONE：不启用自动映射 PARTIAL：只对非嵌套的 resultMap 进行自动映射 FULL：对所有的 resultMap 都进行自动映射</span></span><br><span class="line">    <span class="comment">#auto-mapping-behavior: partial</span></span><br><span class="line">    <span class="comment">#NONE：不做任何处理 (默认值)WARNING：以日志的形式打印相关警告信息 FAILING：当作映射失败处理，并抛出异常和详细信息</span></span><br><span class="line">    <span class="comment">#auto-mapping-unknown-column-behavior: none</span></span><br><span class="line">    <span class="comment">#如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段</span></span><br><span class="line">    <span class="attr">call-setters-on-nulls:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 这个配置会将执行的sql打印出来，在开发或测试的时候可以用</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#表名下划线命名默认true</span></span><br><span class="line">      <span class="attr">table-underline:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#id类型</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment">#是否开启大写命名，默认不开启</span></span><br><span class="line">      <span class="comment">#capital-mode: false</span></span><br><span class="line">      <span class="comment">#逻辑已删除值,(逻辑删除下有效) 需要注入逻辑策略LogicSqlInjector 以@Bean方式注入</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment">#逻辑未删除值,(逻辑删除下有效)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment">#数据库类型</span></span><br><span class="line">      <span class="attr">db-type:</span> <span class="string">sql_server</span></span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1RhYmxlTmFtZS5qYXZh" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableName.java">@TableName<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：表名注解</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td>表名</td>
</tr>
<tr>
<td align="center">schema</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td>schema</td>
</tr>
<tr>
<td align="center">keepGlobalPrefix</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">false</td>
<td>是否保持使用全局的 tablePrefix 的值(如果设置了全局 tablePrefix 且自行设置了 value 的值)</td>
</tr>
<tr>
<td align="center">resultMap</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td>xml 中 resultMap 的 id</td>
</tr>
<tr>
<td align="center">autoResultMap</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">false</td>
<td>是否自动构建 resultMap 并使用(如果设置 resultMap 则不会进行 resultMap 的自动构建并注入)</td>
</tr>
</tbody></table>
<p>关于<code>autoResultMap</code>的说明:</p>
<p>mp会自动构建一个<code>ResultMap</code>并注入到mybatis里(一般用不上).下面讲两句: 因为mp底层是mybatis,所以一些mybatis的常识你要知道,mp只是帮你注入了常用crud到mybatis里 注入之前可以说是动态的(根据你entity的字段以及注解变化而变化),但是注入之后是静态的(等于你写在xml的东西) 而对于直接指定<code>typeHandler</code>,mybatis只支持你写在2个地方:</p>
<ol>
<li>定义在resultMap里,只作用于select查询的返回结果封装</li>
<li>定义在<code>insert</code>和<code>update</code>sql的<code>#{property}</code>里的<code>property</code>后面(例:<code>#{property,typehandler=xxx.xxx.xxx}</code>),只作用于<code>设置值</code> 而除了这两种直接指定<code>typeHandler</code>,mybatis有一个全局的扫描你自己的<code>typeHandler</code>包的配置,这是根据你的<code>property</code>的类型去找<code>typeHandler</code>并使用.</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI3RhYmxlaWQ=" title="https://mp.baomidou.com/guide/annotation.html#tableid">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1RhYmxlSWQuamF2YQ==" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableId.java">@TableId<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：主键注解</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">主键字段名</td>
</tr>
<tr>
<td align="center">type</td>
<td align="center">Enum</td>
<td align="center">否</td>
<td align="center">IdType.NONE</td>
<td align="center">主键类型</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI2lkdHlwZQ==" title="https://mp.baomidou.com/guide/annotation.html#idtype">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL0lkVHlwZS5qYXZh" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AUTO</td>
<td align="center">数据库ID自增</td>
</tr>
<tr>
<td align="center">NONE</td>
<td align="center">无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT)</td>
</tr>
<tr>
<td align="center">INPUT</td>
<td align="center">insert前自行set主键值</td>
</tr>
<tr>
<td align="center">ASSIGN_ID</td>
<td align="center">分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td>
</tr>
<tr>
<td align="center">ASSIGN_UUID</td>
<td align="center">分配UUID,主键类型为String(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextUUID</code>(默认default方法)</td>
</tr>
<tr>
<td align="center">ID_WORKER</td>
<td align="center">分布式全局唯一ID 长整型类型(please use <code>ASSIGN_ID</code>)</td>
</tr>
<tr>
<td align="center">UUID</td>
<td align="center">32位UUID字符串(please use <code>ASSIGN_UUID</code>)</td>
</tr>
<tr>
<td align="center">ID_WORKER_STR</td>
<td align="center">分布式全局唯一ID 字符串类型(please use <code>ASSIGN_ID</code>)</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI3RhYmxlZmllbGQ=" title="https://mp.baomidou.com/guide/annotation.html#tablefield">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1RhYmxlRmllbGQuamF2YQ==" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableField.java">@TableField<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：字段注解(非主键)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">字段名</td>
</tr>
<tr>
<td align="center">el</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">映射为原生 <code>#{ ... }</code> 逻辑,相当于写在 xml 里的 <code>#{ ... }</code> 部分</td>
</tr>
<tr>
<td align="center">exist</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">true</td>
<td align="center">是否为数据库表字段</td>
</tr>
<tr>
<td align="center">condition</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">字段 <code>where</code> 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的</td>
</tr>
<tr>
<td align="center">update</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">字段 <code>update set</code> 部分注入, 例如：update=”%s+1”：表示更新时会set version=version+1(该属性优先级高于 <code>el</code> 属性)</td>
</tr>
<tr>
<td align="center">insertStrategy</td>
<td align="center">Enum</td>
<td align="center">N</td>
<td align="center">DEFAULT</td>
<td align="center">举例：NOT_NULL: <code>insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#{columnProperty}&lt;/if&gt;)</code></td>
</tr>
<tr>
<td align="center">updateStrategy</td>
<td align="center">Enum</td>
<td align="center">N</td>
<td align="center">DEFAULT</td>
<td align="center">举例：IGNORED: <code>update table_a set column=#{columnProperty}</code></td>
</tr>
<tr>
<td align="center">whereStrategy</td>
<td align="center">Enum</td>
<td align="center">N</td>
<td align="center">DEFAULT</td>
<td align="center">举例：NOT_EMPTY: <code>where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#{columnProperty}&lt;/if&gt;</code></td>
</tr>
<tr>
<td align="center">fill</td>
<td align="center">Enum</td>
<td align="center">否</td>
<td align="center">FieldFill.DEFAULT</td>
<td align="center">字段自动填充策略</td>
</tr>
<tr>
<td align="center">select</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">true</td>
<td align="center">是否进行 select 查询</td>
</tr>
<tr>
<td align="center">keepGlobalFormat</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">false</td>
<td align="center">是否保持使用全局的 format 进行处理</td>
</tr>
<tr>
<td align="center">jdbcType</td>
<td align="center">JdbcType</td>
<td align="center">否</td>
<td align="center">JdbcType.UNDEFINED</td>
<td align="center">JDBC类型 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td align="center">typeHandler</td>
<td align="center">Class&lt;? extends TypeHandler&gt;</td>
<td align="center">否</td>
<td align="center">UnknownTypeHandler.class</td>
<td align="center">类型处理器 (该默认值不代表会按照该值生效)</td>
</tr>
<tr>
<td align="center">numericScale</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">指定小数点后保留的位数</td>
</tr>
</tbody></table>
<p>关于<code>jdbcType</code>和<code>typeHandler</code>以及<code>numericScale</code>的说明:</p>
<p><code>numericScale</code>只生效于 update 的sql. <code>jdbcType</code>和<code>typeHandler</code>如果不配合<code>@TableName#autoResultMap = true</code>一起使用,也只生效于 update 的sql. 对于<code>typeHandler</code>如果你的字段类型和set进去的类型为<code>equals</code>关系,则只需要让你的<code>typeHandler</code>让Mybatis加载到即可,不需要使用注解</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI2ZpZWxkc3RyYXRlZ3k=" title="https://mp.baomidou.com/guide/annotation.html#fieldstrategy">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL0ZpZWxkU3RyYXRlZ3kuamF2YQ==" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/FieldStrategy.java">FieldStrategy<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IGNORED</td>
<td align="center">忽略判断</td>
</tr>
<tr>
<td align="center">NOT_NULL</td>
<td align="center">非NULL判断</td>
</tr>
<tr>
<td align="center">NOT_EMPTY</td>
<td align="center">非空判断(只对字符串类型字段,其他类型字段依然为非NULL判断)</td>
</tr>
<tr>
<td align="center">DEFAULT</td>
<td align="center">追随全局配置</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI2ZpZWxkZmlsbA==" title="https://mp.baomidou.com/guide/annotation.html#fieldfill">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL0ZpZWxkRmlsbC5qYXZh" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/FieldFill.java">FieldFill<i class="fa fa-external-link"></i></span></p>
<table>
<thead>
<tr>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DEFAULT</td>
<td align="center">默认不处理</td>
</tr>
<tr>
<td align="center">INSERT</td>
<td align="center">插入时填充字段</td>
</tr>
<tr>
<td align="center">UPDATE</td>
<td align="center">更新时填充字段</td>
</tr>
<tr>
<td align="center">INSERT_UPDATE</td>
<td align="center">插入和更新时填充字段</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI3ZlcnNpb24=" title="https://mp.baomidou.com/guide/annotation.html#version">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1ZlcnNpb24uamF2YQ==" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/Version.java">@Version<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：乐观锁注解、标记 <code>@Verison</code> 在字段上</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI2VudW12YWx1ZQ==" title="https://mp.baomidou.com/guide/annotation.html#enumvalue">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL0VudW1WYWx1ZS5qYXZh" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/EnumValue.java">@EnumValue<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：通枚举类注解(注解在枚举字段上)</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI3RhYmxlbG9naWM=" title="https://mp.baomidou.com/guide/annotation.html#tablelogic">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1RhYmxlTG9naWMuamF2YQ==" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/TableLogic.java">@TableLogic<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：表字段逻辑处理注解（逻辑删除）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">逻辑未删除值</td>
</tr>
<tr>
<td align="center">delval</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">逻辑删除值</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI3NxbHBhcnNlcg==" title="https://mp.baomidou.com/guide/annotation.html#sqlparser">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL1NxbFBhcnNlci5qYXZh" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/SqlParser.java">@SqlParser<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：租户注解,支持method上以及mapper接口上</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">filter</td>
<td align="center">boolean</td>
<td align="center">否</td>
<td align="center">false</td>
<td align="center">true: 表示过滤SQL解析，即不会进入ISqlParser解析链，否则会进解析链并追加例如tenant_id等条件</td>
</tr>
</tbody></table>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC5iYW9taWRvdS5jb20vZ3VpZGUvYW5ub3RhdGlvbi5odG1sI2tleXNlcXVlbmNl" title="https://mp.baomidou.com/guide/annotation.html#keysequence">#<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jhb21pZG91L215YmF0aXMtcGx1cy9ibG9iLzMuMC9teWJhdGlzLXBsdXMtYW5ub3RhdGlvbi9zcmMvbWFpbi9qYXZhL2NvbS9iYW9taWRvdS9teWJhdGlzcGx1cy9hbm5vdGF0aW9uL0tleVNlcXVlbmNlLmphdmE=" title="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/KeySequence.java">@KeySequence<i class="fa fa-external-link"></i></span></p>
<ul>
<li>描述：序列主键策略 <code>oracle</code></li>
<li>属性：value、resultMap</li>
</ul>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">必须指定</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value</td>
<td align="center">String</td>
<td align="center">否</td>
<td align="center">“”</td>
<td align="center">序列名</td>
</tr>
<tr>
<td align="center">clazz</td>
<td align="center">Class</td>
<td align="center">否</td>
<td align="center">Long.class</td>
<td align="center">id的类型, 可以指定String.class，这样返回的Sequence值是字符串”1”</td>
</tr>
</tbody></table>
<h2 id="简单CRUD"><a href="#简单CRUD" class="headerlink" title="简单CRUD"></a>简单CRUD</h2><ul>
<li>增加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">User u  = <span class="keyword">new</span> User();</span><br><span class="line">      u.setUsername(<span class="string">"Dsz"</span>);</span><br><span class="line">      u.setPassword(<span class="string">"1111"</span>);</span><br><span class="line">      service.insert(u);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id删除</span></span><br><span class="line">service.deleteById(u.getUid());</span><br><span class="line"><span class="comment">//条件删除</span></span><br><span class="line">service.delete(<span class="keyword">new</span> QueryWrapper&lt;User&gt;().eq(<span class="string">"username"</span>,u.getUsername()));</span><br></pre></td></tr></table></figure>

<ul>
<li>更新</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过id更新</span></span><br><span class="line">service.updateById(u);</span><br><span class="line"><span class="comment">//通过条件更新</span></span><br><span class="line">service.update(u,<span class="keyword">new</span> QueryWrapper&lt;&gt;());</span><br><span class="line"><span class="comment">//更新 如果不存在则插入</span></span><br><span class="line">service.insertOrUpdate(u);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件查询单个</span></span><br><span class="line">service.selectOne(<span class="keyword">new</span> QueryWrapper&lt;&gt;());</span><br><span class="line"><span class="comment">//条件查询多个</span></span><br><span class="line">service.selectList(<span class="keyword">new</span> QueryWrapper&lt;&gt;());</span><br><span class="line"><span class="comment">//通过id查询</span></span><br><span class="line">service.selectById(u.getUid());</span><br><span class="line"><span class="comment">//查询有多少条记录</span></span><br><span class="line">service.selectCount(<span class="keyword">new</span> QueryWrapper&lt;&gt;());</span><br></pre></td></tr></table></figure>



<h3 id="附：条件参数说明"><a href="#附：条件参数说明" class="headerlink" title="附：条件参数说明"></a>附：条件参数说明</h3><p>查询方式            说明<br>setSqlSelect    设置 SELECT 查询字段<br>where    WHERE 语句，拼接 + WHERE 条件<br>and    AND 语句，拼接 + AND 字段=值<br>andNew    AND 语句，拼接 + AND (字段=值)<br>or    OR 语句，拼接 + OR 字段=值<br>orNew    OR 语句，拼接 + OR (字段=值)<br>eq    等于=<br>allEq    基于 map 内容等于=<br>ne    不等于&lt;&gt;<br>gt    大于&gt;<br>ge    大于等于&gt;=<br>lt    小于&lt;<br>le    小于等于&lt;=<br>like    模糊查询 LIKE<br>notLike    模糊查询 NOT LIKE<br>in    IN 查询<br>notIn    NOT IN 查询<br>isNull    NULL 值查询<br>isNotNull    IS NOT NULL<br>groupBy    分组 GROUP BY<br>having    HAVING 关键词<br>orderBy    排序 ORDER BY<br>orderAsc    ASC 排序 ORDER BY<br>orderDesc    DESC 排序 ORDER BY<br>exists    EXISTS 条件语句<br>notExists    NOT EXISTS 条件语句<br>between    BETWEEN 条件语句<br>notBetween    NOT BETWEEN 条件语句<br>addFilter    自由拼接 SQL<br>last    拼接在最后，例如：last(“LIMIT 1”)</p>
]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring security oAth2-实战(3)</title>
    <url>/posts/a6542501/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <strong>为什么需要 oAuth2</strong> 和 <strong>RBAC 基于角色的权限控制</strong> 章节，我们介绍过资源的概念，简单点说就是需要被访问的业务数据或是静态资源文件都可以被称作资源。</p><p>为了让大家更好的理解资源服务器的概念，我们单独创建一个名为 <code>spring-security-oauth2-resource</code> 资源服务器的项目，该项目的主要目的就是对数据表的 CRUD 操作，而这些操作就是对资源的操作了。</p><a id="more"></a>

<p><strong>操作流程</strong></p>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/901ef32a4fa6cad.png"></p>
<ul>
<li>初始化资源服务器数据库</li>
<li>POM 所需依赖同认证服务器</li>
<li>配置资源服务器</li>
<li>配置资源(Controller)</li>
</ul>
<h2 id="初始化资源服务器数据库"><a href="#初始化资源服务器数据库" class="headerlink" title="初始化资源服务器数据库"></a>初始化资源服务器数据库</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_content`</span> (  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,  <span class="string">`category_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'内容类目ID'</span>,  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'内容标题'</span>,  <span class="string">`sub_title`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'子标题'</span>,  <span class="string">`title_desc`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'标题描述'</span>,  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'链接'</span>,  <span class="string">`pic`</span> <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'图片绝对路径'</span>,  <span class="string">`pic2`</span> <span class="built_in">varchar</span>(<span class="number">300</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'图片2'</span>,  <span class="string">`content`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'内容'</span>,  <span class="string">`created`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`updated`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),  <span class="keyword">KEY</span> <span class="string">`category_id`</span> (<span class="string">`category_id`</span>),  <span class="keyword">KEY</span> <span class="string">`updated`</span> (<span class="string">`updated`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">42</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_content`</span>(<span class="string">`id`</span>,<span class="string">`category_id`</span>,<span class="string">`title`</span>,<span class="string">`sub_title`</span>,<span class="string">`title_desc`</span>,<span class="string">`url`</span>,<span class="string">`pic`</span>,<span class="string">`pic2`</span>,<span class="string">`content`</span>,<span class="string">`created`</span>,<span class="string">`updated`</span>) <span class="keyword">values</span> (<span class="number">28</span>,<span class="number">89</span>,<span class="string">'标题'</span>,<span class="string">'子标题'</span>,<span class="string">'标题说明'</span>,<span class="string">'http://www.jd.com'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-07 00:56:09'</span>,<span class="string">'2019-04-07 00:56:11'</span>),(<span class="number">29</span>,<span class="number">89</span>,<span class="string">'ad2'</span>,<span class="string">'ad2'</span>,<span class="string">'ad2'</span>,<span class="string">'http://www.baidu.com'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-07 00:56:13'</span>,<span class="string">'2019-04-07 00:56:15'</span>),(<span class="number">30</span>,<span class="number">89</span>,<span class="string">'ad3'</span>,<span class="string">'ad3'</span>,<span class="string">'ad3'</span>,<span class="string">'http://www.sina.com.cn'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-07 00:56:17'</span>,<span class="string">'2019-04-07 00:56:19'</span>),(<span class="number">31</span>,<span class="number">89</span>,<span class="string">'ad4'</span>,<span class="string">'ad4'</span>,<span class="string">'ad4'</span>,<span class="string">'http://www.funtl.com'</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-07 00:56:22'</span>,<span class="string">'2019-04-07 00:56:25'</span>);<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_content_category`</span> (  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'类目ID'</span>,  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父类目ID=0时，代表的是一级的类目'</span>,  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类名称'</span>,  <span class="string">`status`</span> <span class="built_in">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'状态。可选值:1(正常),2(删除)'</span>,  <span class="string">`sort_order`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数'</span>,  <span class="string">`is_parent`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'该类目是否为父类目，1为true，0为false'</span>,  <span class="string">`created`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,  <span class="string">`updated`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),  <span class="keyword">KEY</span> <span class="string">`parent_id`</span> (<span class="string">`parent_id`</span>,<span class="string">`status`</span>) <span class="keyword">USING</span> BTREE,  <span class="keyword">KEY</span> <span class="string">`sort_order`</span> (<span class="string">`sort_order`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">98</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'内容分类'</span>;<span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_content_category`</span>(<span class="string">`id`</span>,<span class="string">`parent_id`</span>,<span class="string">`name`</span>,<span class="string">`status`</span>,<span class="string">`sort_order`</span>,<span class="string">`is_parent`</span>,<span class="string">`created`</span>,<span class="string">`updated`</span>) <span class="keyword">values</span> (<span class="number">30</span>,<span class="number">0</span>,<span class="string">'LeeShop'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2015-04-03 16:51:38'</span>,<span class="string">'2015-04-03 16:51:40'</span>),(<span class="number">86</span>,<span class="number">30</span>,<span class="string">'首页'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2015-06-07 15:36:07'</span>,<span class="string">'2015-06-07 15:36:07'</span>),(<span class="number">87</span>,<span class="number">30</span>,<span class="string">'列表页面'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2015-06-07 15:36:16'</span>,<span class="string">'2015-06-07 15:36:16'</span>),(<span class="number">88</span>,<span class="number">30</span>,<span class="string">'详细页面'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2015-06-07 15:36:27'</span>,<span class="string">'2015-06-07 15:36:27'</span>),(<span class="number">89</span>,<span class="number">86</span>,<span class="string">'大广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:36:38'</span>,<span class="string">'2015-06-07 15:36:38'</span>),(<span class="number">90</span>,<span class="number">86</span>,<span class="string">'小广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:36:45'</span>,<span class="string">'2015-06-07 15:36:45'</span>),(<span class="number">91</span>,<span class="number">86</span>,<span class="string">'商城快报'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:36:55'</span>,<span class="string">'2015-06-07 15:36:55'</span>),(<span class="number">92</span>,<span class="number">87</span>,<span class="string">'边栏广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:37:07'</span>,<span class="string">'2015-06-07 15:37:07'</span>),(<span class="number">93</span>,<span class="number">87</span>,<span class="string">'页头广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:37:17'</span>,<span class="string">'2015-06-07 15:37:17'</span>),(<span class="number">94</span>,<span class="number">87</span>,<span class="string">'页脚广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:37:31'</span>,<span class="string">'2015-06-07 15:37:31'</span>),(<span class="number">95</span>,<span class="number">88</span>,<span class="string">'边栏广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-06-07 15:37:56'</span>,<span class="string">'2015-06-07 15:37:56'</span>),(<span class="number">96</span>,<span class="number">86</span>,<span class="string">'中广告'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2015-07-25 18:58:52'</span>,<span class="string">'2015-07-25 18:58:52'</span>),(<span class="number">97</span>,<span class="number">96</span>,<span class="string">'中广告1'</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'2015-07-25 18:59:43'</span>,<span class="string">'2015-07-25 18:59:43'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.dszmr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-resource<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Security --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- CP --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hikaricp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">oauth2-resource</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span>  <span class="string">jdbc:mysql://localhost:3306/oath2?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">600000</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">MyHikariCP</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="attr">connection-test-query:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">client</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="string">secret</span></span><br><span class="line">      <span class="attr">access-token-uri:</span> <span class="string">http://localhost:8080/oauth/token</span></span><br><span class="line">      <span class="attr">user-authorization-uri:</span> <span class="string">http://localhost:8080/oauth/authorize</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">token-info-uri:</span> <span class="string">http://localhost:8080/oauth/check_token</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/contents</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="attr">org.springframework.web:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="attr">org.springframework.security:</span> <span class="string">INFO</span></span><br><span class="line">    <span class="attr">org.springframework.security.oauth2:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<h3 id="配置资源服务器"><a href="#配置资源服务器" class="headerlink" title="配置资源服务器"></a>配置资源服务器</h3><p>创建一个类继承 <code>ResourceServerConfigurerAdapter</code> 并添加相关注解：</p>
<ul>
<li><code>@Configuration</code></li>
<li><code>@EnableResourceServer</code>：资源服务器</li>
<li><code>@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)</code>：全局方法拦截</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.dszmr.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line">import org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line">import org.springframework.security.config.http.SessionCreationPolicy;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;</span><br><span class="line">@Configuration</span><br><span class="line">@EnableResourceServer</span><br><span class="line">@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)</span><br><span class="line">public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                .and()</span><br><span class="line">                // Session 创建策略</span><br><span class="line">                // ALWAYS 总是创建 HttpSession</span><br><span class="line">                // IF_REQUIRED Spring Security 只会在需要时创建一个 HttpSession</span><br><span class="line">                // NEVER Spring Security 不会创建 HttpSession，但如果它已经存在，将可以使用 HttpSession</span><br><span class="line">                // STATELESS Spring Security 永远不会创建 HttpSession，它不会使用 HttpSession 来获取 SecurityContext</span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                // 以下为配置所需保护的资源路径及权限，需要与认证服务器配置的授权部分对应</span><br><span class="line">                .antMatchers(&quot;/contents/**&quot;).hasAuthority(&quot;SystemContent&quot;)</span><br><span class="line">                .antMatchers(&quot;/view/**&quot;).hasAuthority(&quot;SystemContentView&quot;)</span><br><span class="line">                .antMatchers(&quot;/insert/**&quot;).hasAuthority(&quot;SystemContentInsert&quot;)</span><br><span class="line">                .antMatchers(&quot;/update/**&quot;).hasAuthority(&quot;SystemContentUpdate&quot;)</span><br><span class="line">                .antMatchers(&quot;/delete/**&quot;).hasAuthority(&quot;SystemContentDelete&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h3><p>创建一个名为 <code>ResponseResult</code> 的通用数据传输对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的返回对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseResult</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3468352004150968551L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.message = throwable.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResponseResult</span><span class="params">(Integer state, String message, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Integer state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((data == <span class="keyword">null</span>) ? <span class="number">0</span> : data.hashCode());</span><br><span class="line">        result = prime * result + ((message == <span class="keyword">null</span>) ? <span class="number">0</span> : message.hashCode());</span><br><span class="line">        result = prime * result + ((state == <span class="keyword">null</span>) ? <span class="number">0</span> : state.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ResponseResult&lt;?&gt; other = (ResponseResult&lt;?&gt;) obj;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!data.equals(other.data)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (message == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!message.equals(other.message)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (other.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(other.state)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.domain.TbContent;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.service.TbContentService;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.vo.ResponseResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TbContentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TbContentService tbContentService;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseResult&lt;List&lt;TbContent&gt;&gt; list() &#123;</span><br><span class="line">        List&lt;TbContent&gt; tbContents = tbContentService.selectAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseResult&lt;List&lt;TbContent&gt;&gt;(HttpStatus.OK.value(), HttpStatus.OK.toString(), tbContents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h2><h3 id="访问获取授权码"><a href="#访问获取授权码" class="headerlink" title="访问获取授权码"></a>访问获取授权码</h3><ul>
<li>通过浏览器访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次访问会跳转到登录页面</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/81b26cd8f499725-3.png"></p>
<ul>
<li>验证成功后会询问用户是否授权客户端</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/6d93fe9ca240195-3.png"></p>
<ul>
<li>选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（<code>code=1JuO6V</code>），浏览器地址栏会显示如下地址：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/?code=1JuO6V</span><br></pre></td></tr></table></figure>

<h3 id="向服务器申请令牌"><a href="#向服务器申请令牌" class="headerlink" title="向服务器申请令牌"></a>向服务器申请令牌</h3><ul>
<li>通过 CURL 或是 Postman 请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -d &apos;grant_type=authorization_code&amp;code=1JuO6V&apos; &quot;http://client:secret@localhost:8080/oauth/token&quot;</span><br></pre></td></tr></table></figure>

<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/1dc1ad17978e97d-3.png"></p>
<ul>
<li>得到响应结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    &quot;access_token&quot;: &quot;016d8d4a-dd6e-4493-b590-5f072923c413&quot;,    &quot;token_type&quot;: &quot;bearer&quot;,    &quot;expires_in&quot;: 43199,    &quot;scope&quot;: &quot;app&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="携带令牌访问资源服务器"><a href="#携带令牌访问资源服务器" class="headerlink" title="携带令牌访问资源服务器"></a>携带令牌访问资源服务器</h3><p>此处以获取全部资源为例，其它请求方式一样，可以参考我源码中的单元测试代码。可以使用以下方式请求：</p>
<ul>
<li>使用 Headers 方式：需要在请求头增加 <code>Authorization: Bearer yourAccessToken</code></li>
<li>直接请求带参数方式：<code>http://localhost:8081/contents?access_token=yourAccessToken</code></li>
</ul>
<p>使用 Headers 方式，通过 CURL 或是 Postman 请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl --location --request GET &quot;http://localhost:8081/contents&quot; --header &quot;Content-Type: application/json&quot; --header &quot;Authorization: Bearer yourAccessToken&quot;</span><br></pre></td></tr></table></figure>

<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/c50de6809490e5a.png"></p>
]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring security oAth2(2)</title>
    <url>/posts/30e46b1/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本章节 <strong>基于 JDBC 存储令牌</strong> 的模式用于演示最基本的操作，帮助大家快速理解 oAuth2 认证服务器中 “认证”、”授权”、”访问令牌” 的基本概念</p><h3 id="对于上篇文章需要修改的点"><a href="#对于上篇文章需要修改的点" class="headerlink" title="对于上篇文章需要修改的点"></a>对于上篇文章需要修改的点</h3><ul>
<li><p>初始化 oAuth2 相关表</p>
</li>
<li><p>在数据库中配置客户端</p>
</li>
<li><p>配置认证服务器</p>
<ul>
<li><p>配置数据源：<code>DataSource</code></p>
</li>
<li><p>配置令牌存储方式：<code>TokenStore</code> -&gt; <code>JdbcTokenStore</code></p>
</li>
<li><p>配置客户端读取方式：<code>ClientDetailsService</code> -&gt; <code>JdbcClientDetailsService</code></p>
</li>
<li><p>配置服务端点信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AuthorizationServerEndpointsConfigurer</span><br></pre></td></tr></table></figure>

<ul>
<li><code>tokenStore</code>：设置令牌存储方式</li>
</ul>
</li>
<li><p>配置客户端信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClientDetailsServiceConfigurer</span><br></pre></td></tr></table></figure>

<ul>
<li><code>withClientDetails</code>：设置客户端配置读取方式</li>
</ul>
</li>
</ul>
</li>
</ul><a id="more"></a>

<h2 id="初始化-oAuth2-相关表"><a href="#初始化-oAuth2-相关表" class="headerlink" title="初始化 oAuth2 相关表"></a>初始化 oAuth2 相关表</h2><p>使用官方提供的建表脚本初始化 oAuth2 相关表，地址如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql</span><br></pre></td></tr></table></figure>

<p>由于我们使用的是 MySQL 数据库，默认建表语句中主键为 <code>VARCHAR(256)</code>，这超过了最大的主键长度，请手动修改为 <code>128</code>，并用 <code>BLOB</code> 替换语句中的 <code>LONGVARBINARY</code> 类型，修改后的建表脚本如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`clientdetails`</span> (  <span class="string">`appId`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`resourceIds`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`appSecret`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`scope`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`grantTypes`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`redirectUrl`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`authorities`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`access_token_validity`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`refresh_token_validity`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`additionalInformation`</span> <span class="built_in">varchar</span>(<span class="number">4096</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`autoApproveScopes`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`appId`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_access_token`</span> (  <span class="string">`token_id`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`token`</span> <span class="built_in">blob</span>,  <span class="string">`authentication_id`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`client_id`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`authentication`</span> <span class="built_in">blob</span>,  <span class="string">`refresh_token`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`authentication_id`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_approvals`</span> (  <span class="string">`userId`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`clientId`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`scope`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`status`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`expiresAt`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`lastModifiedAt`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_client_details`</span> (  <span class="string">`client_id`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`resource_ids`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`client_secret`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`scope`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`authorized_grant_types`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`web_server_redirect_uri`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`authorities`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`access_token_validity`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`refresh_token_validity`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`additional_information`</span> <span class="built_in">varchar</span>(<span class="number">4096</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`autoapprove`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`client_id`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_client_token`</span> (  <span class="string">`token_id`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`token`</span> <span class="built_in">blob</span>,  <span class="string">`authentication_id`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`client_id`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  PRIMARY <span class="keyword">KEY</span> (<span class="string">`authentication_id`</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_code`</span> (  <span class="string">`code`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`authentication`</span> <span class="built_in">blob</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`oauth_refresh_token`</span> (  <span class="string">`token_id`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,  <span class="string">`token`</span> <span class="built_in">blob</span>,  <span class="string">`authentication`</span> <span class="built_in">blob</span>) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="在数据库中配置客户端"><a href="#在数据库中配置客户端" class="headerlink" title="在数据库中配置客户端"></a>在数据库中配置客户端</h2><p>将上一篇文章中在内存对应的配置，更换到内存中进行配置，配置的字段如下：</p>
<ul>
<li><p><code>client_id</code>：客户端标识</p>
</li>
<li><p><code>client_secret</code>：客户端安全码，<strong>此处不能是明文，需要加密</strong></p>
</li>
<li><p><code>scope</code>：客户端授权范围</p>
</li>
<li><p><code>authorized_grant_types</code>：客户端授权类型</p>
</li>
<li><p><code>web_server_redirect_uri</code>：服务器回调地址</p>
<p>只是将本来存在于内存的配置移动到了数据库进行存储</p>
</li>
</ul>
<p>因为客户端安全码必须是加密文字所以必须要先进行加密然后再进行存储，编写测试方法对密码进行加密：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.dszmr.test;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">public class Test1 &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testBCryptPasswordEncoder() &#123;</span><br><span class="line">        System.out.println(new BCryptPasswordEncoder().encode(&quot;secret&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库数据效果图</p>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/2c3e824c2e419b3.png"></p>
<p>由于是对数据库进行操作所以需要添加数据库对应依赖</p>
<ul>
<li>pom</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hikaricp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>application.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url:  jdbc:mysql://localhost:3306/ordering?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    hikari:</span><br><span class="line">      minimum-idle: 5</span><br><span class="line">      idle-timeout: 600000</span><br><span class="line">      maximum-pool-size: 10</span><br><span class="line">      auto-commit: true</span><br><span class="line">      pool-name: MyHikariCP</span><br><span class="line">      max-lifetime: 1800000</span><br><span class="line">      connection-timeout: 30000</span><br><span class="line">      connection-test-query: SELECT 1</span><br><span class="line">  application:</span><br><span class="line">    name: business-oauth2</span><br><span class="line">  main:</span><br><span class="line">    allow-bean-definition-overriding: true</span><br><span class="line">  jackson:</span><br><span class="line">    time-zone: GMT+8</span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 106.54.8.126:8848</span><br><span class="line"></span><br><span class="line">dubbo:</span><br><span class="line">  scan:</span><br><span class="line">    base-packages: cn.dszmr.business.myshop.controller,cn.dszmr.business.myshop.service</span><br><span class="line">  protocol:</span><br><span class="line">    name: dubbo</span><br><span class="line">    port: -1</span><br><span class="line">    serialization: kryo</span><br><span class="line">  registry:</span><br><span class="line">    address: nacos://106.54.8.126</span><br><span class="line">    port: 8848</span><br><span class="line">feign:</span><br><span class="line">  okhttp:</span><br><span class="line">    enabled: true</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: false</span><br><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">business:</span><br><span class="line">  oauth2:</span><br><span class="line">    grant_type: password</span><br><span class="line">    client_id: client</span><br><span class="line">    client_secret: secret</span><br></pre></td></tr></table></figure>

<ul>
<li>修改AuthorizationServerConfiguration</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.dszmr.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.boot.jdbc.DataSourceBuilder;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.Primary;</span><br><span class="line">import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line">import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;</span><br><span class="line">import org.springframework.security.oauth2.provider.ClientDetailsService;</span><br><span class="line">import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.TokenStore;</span><br><span class="line">import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableAuthorizationServer  //告诉spring 需要加载那些spring security 的类</span><br><span class="line">public class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BCryptPasswordEncoder passwordEncoder; //注入密码模式</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        // 配置数据源（注意，我使用的是 HikariCP 连接池），以上注解是指定数据源，否则会有冲突</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public TokenStore tokenStore() &#123;</span><br><span class="line">        // 基于 JDBC 实现，令牌保存到数据库</span><br><span class="line">        return new JdbcTokenStore(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ClientDetailsService jdbcClientDetailsService() &#123;</span><br><span class="line">        // 基于 JDBC 实现，需要事先在数据库配置客户端信息</span><br><span class="line">        return new JdbcClientDetailsService(dataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;</span><br><span class="line">        // 设置令牌存储模式</span><br><span class="line">        endpoints.tokenStore(tokenStore());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;</span><br><span class="line">        // 客户端配置</span><br><span class="line">        clients.withClientDetails(jdbcClientDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h2><ul>
<li>通过浏览器访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次访问会跳转到登录页面</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/81b26cd8f499725-1.png"></p>
<ul>
<li>验证成功后会询问用户是否授权客户端</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/6d93fe9ca240195-1.png"></p>
<ul>
<li>选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（<code>code=1JuO6V</code>），浏览器地址栏会显示如下地址：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/?code=1JuO6V</span><br></pre></td></tr></table></figure>

<h3 id="向服务器申请令牌"><a href="#向服务器申请令牌" class="headerlink" title="向服务器申请令牌"></a>向服务器申请令牌</h3><ul>
<li>通过 CURL 或是 Postman 请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -d &apos;grant_type=authorization_code&amp;code=1JuO6V&apos; &quot;http://client:secret@localhost:8080/oauth/token&quot;</span><br></pre></td></tr></table></figure>

<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/1dc1ad17978e97d-1.png"></p>
<ul>
<li>得到响应结果如下</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    <span class="attr">"access_token"</span>: <span class="string">"016d8d4a-dd6e-4493-b590-5f072923c413"</span>,    <span class="attr">"token_type"</span>: <span class="string">"bearer"</span>,    <span class="attr">"expires_in"</span>: <span class="number">43199</span>,    <span class="attr">"scope"</span>: <span class="string">"app"</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC 基于角色的访问控制"></a>RBAC 基于角色的访问控制</h3><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般是多对多的关系。（如下图）</p>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/e05470fa06dbe31.png"></p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在我们的 oAuth2 系统中，我们需要对系统的所有资源进行权限控制，系统中的资源包括：</p>
<ul>
<li>静态资源（对象资源）：功能操作、数据列</li>
<li>动态资源（数据资源）：数据</li>
</ul>
<p>系统的目的就是对应用系统的所有对象资源和数据资源进行权限控制，比如：功能菜单、界面按钮、数据显示的列、各种行级数据进行权限的操控</p>
<h2 id="初始化-RBAC-相关表"><a href="#初始化-RBAC-相关表" class="headerlink" title="初始化 RBAC 相关表"></a>初始化 RBAC 相关表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父权限'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限名称'</span>,</span><br><span class="line">  <span class="string">`enname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限英文名称'</span>,</span><br><span class="line">  <span class="string">`url`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'授权路径'</span>,</span><br><span class="line">  <span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  <span class="string">`created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`updated`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">44</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'权限表'</span>;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_permission`</span>(<span class="string">`id`</span>,<span class="string">`parent_id`</span>,<span class="string">`name`</span>,<span class="string">`enname`</span>,<span class="string">`url`</span>,<span class="string">`description`</span>,<span class="string">`created`</span>,<span class="string">`updated`</span>) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">37</span>,<span class="number">0</span>,<span class="string">'系统管理'</span>,<span class="string">'System'</span>,<span class="string">'/'</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 23:22:54'</span>,<span class="string">'2019-04-04 23:22:56'</span>),</span><br><span class="line">(<span class="number">38</span>,<span class="number">37</span>,<span class="string">'用户管理'</span>,<span class="string">'SystemUser'</span>,<span class="string">'/users/'</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 23:25:31'</span>,<span class="string">'2019-04-04 23:25:33'</span>),</span><br><span class="line">(<span class="number">39</span>,<span class="number">38</span>,<span class="string">'查看用户'</span>,<span class="string">'SystemUserView'</span>,<span class="string">''</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 15:30:30'</span>,<span class="string">'2019-04-04 15:30:43'</span>),</span><br><span class="line">(<span class="number">40</span>,<span class="number">38</span>,<span class="string">'新增用户'</span>,<span class="string">'SystemUserInsert'</span>,<span class="string">''</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 15:30:31'</span>,<span class="string">'2019-04-04 15:30:44'</span>),</span><br><span class="line">(<span class="number">41</span>,<span class="number">38</span>,<span class="string">'编辑用户'</span>,<span class="string">'SystemUserUpdate'</span>,<span class="string">''</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 15:30:32'</span>,<span class="string">'2019-04-04 15:30:45'</span>),</span><br><span class="line">(<span class="number">42</span>,<span class="number">38</span>,<span class="string">'删除用户'</span>,<span class="string">'SystemUserDelete'</span>,<span class="string">''</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 15:30:48'</span>,<span class="string">'2019-04-04 15:30:45'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'父角色'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色名称'</span>,</span><br><span class="line">  <span class="string">`enname`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色英文名称'</span>,</span><br><span class="line">  <span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'备注'</span>,</span><br><span class="line">  <span class="string">`created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`updated`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">38</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色表'</span>;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_role`</span>(<span class="string">`id`</span>,<span class="string">`parent_id`</span>,<span class="string">`name`</span>,<span class="string">`enname`</span>,<span class="string">`description`</span>,<span class="string">`created`</span>,<span class="string">`updated`</span>) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">37</span>,<span class="number">0</span>,<span class="string">'超级管理员'</span>,<span class="string">'admin'</span>,<span class="literal">NULL</span>,<span class="string">'2019-04-04 23:22:03'</span>,<span class="string">'2019-04-04 23:22:05'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_role_permission`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色 ID'</span>,</span><br><span class="line">  <span class="string">`permission_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'权限 ID'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">43</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'角色权限表'</span>;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_role_permission`</span>(<span class="string">`id`</span>,<span class="string">`role_id`</span>,<span class="string">`permission_id`</span>) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">37</span>,<span class="number">37</span>,<span class="number">37</span>),</span><br><span class="line">(<span class="number">38</span>,<span class="number">37</span>,<span class="number">38</span>),</span><br><span class="line">(<span class="number">39</span>,<span class="number">37</span>,<span class="number">39</span>),</span><br><span class="line">(<span class="number">40</span>,<span class="number">37</span>,<span class="number">40</span>),</span><br><span class="line">(<span class="number">41</span>,<span class="number">37</span>,<span class="number">41</span>),</span><br><span class="line">(<span class="number">42</span>,<span class="number">37</span>,<span class="number">42</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名'</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'密码，加密存储'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'注册手机号'</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'注册邮箱'</span>,</span><br><span class="line">  <span class="string">`created`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`updated`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`username`</span> (<span class="string">`username`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`phone`</span> (<span class="string">`phone`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`email`</span> (<span class="string">`email`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">38</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'用户表'</span>;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_user`</span>(<span class="string">`id`</span>,<span class="string">`username`</span>,<span class="string">`password`</span>,<span class="string">`phone`</span>,<span class="string">`email`</span>,<span class="string">`created`</span>,<span class="string">`updated`</span>) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">37</span>,<span class="string">'admin'</span>,<span class="string">'$2a$10$9ZhDOBp.sRKat4l14ygu/.LscxrMUcDAfeVOEPiYwbcRkoB09gCmi'</span>,<span class="string">'15888888888'</span>,<span class="string">'lee.lusifer@gmail.com'</span>,<span class="string">'2019-04-04 23:21:27'</span>,<span class="string">'2019-04-04 23:21:29'</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_user_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户 ID'</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'角色 ID'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">38</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'用户角色表'</span>;</span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> <span class="string">`tb_user_role`</span>(<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`role_id`</span>) <span class="keyword">values</span> </span><br><span class="line">(<span class="number">37</span>,<span class="number">37</span>,<span class="number">37</span>);</span><br></pre></td></tr></table></figure>

<p><strong>自行编写测试类对密码进行加密</strong></p>
<ul>
<li>添加tkmapper依赖</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>service层需要编写两个查询</p>
<ul>
<li>通过用户名获取到对应user对象</li>
<li>通过用户id根据表间关系获取到对应权限permission对象</li>
</ul>
</li>
<li><p>自定义认证授权实现类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.dszmr.domain.TbPermission;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.domain.TbUser;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.service.TbPermissionService;</span><br><span class="line"><span class="keyword">import</span> cn.dszmr.service.TbUserService;</span><br><span class="line"><span class="keyword">import</span> org.assertj.core.util.Lists;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TbUserService tbUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TbPermissionService tbPermissionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        TbUser tbUser = tbUserService.getByUsername(s);</span><br><span class="line">        List&lt;GrantedAuthority&gt; grantedAuthorities = Lists.newArrayList();</span><br><span class="line">        <span class="keyword">if</span> (tbUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 声明用户授权</span></span><br><span class="line">            List&lt;TbPermission&gt; tbPermissions = tbPermissionService.selectByUserId(tbUser.getId());</span><br><span class="line">            tbPermissions.forEach(tbPermission -&gt; &#123;</span><br><span class="line">                GrantedAuthority grantedAuthority = <span class="keyword">new</span> SimpleGrantedAuthority(tbPermission.getEnname());</span><br><span class="line">                grantedAuthorities.add(grantedAuthority);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 由框架完成认证工作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(tbUser.getUsername(), tbUser.getPassword(), grantedAuthorities);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务器安全配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//声明这是一个配置类</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">//加载配置认证信息</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>, securedEnabled = <span class="keyword">true</span>, jsr250Enabled = <span class="keyword">true</span>)<span class="comment">//全局方法拦截</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置默认的加密方式 也就是密码加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDetailsServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            auth.userDetailsService(userDetailsService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将 check_token 暴露出去，否则资源服务器访问时报 403 错误</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">"/oauth/check_token"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>步骤与前两次测试一致</p>
]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring security oAth2(1)</title>
    <url>/posts/28231572/</url>
    <content><![CDATA[<h2 id="一、Spring-security框架简介"><a href="#一、Spring-security框架简介" class="headerlink" title="一、Spring security框架简介"></a>一、Spring security框架简介</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​           一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方式的安全框架（简单说是对访问权限进行控制），主要核心功能为 认证和授权</p><p>​            认证：判断该用户是否有权限登录该系统</p><p>​            授权：判断该用户是否有权限访问该功能</p><a id="more"></a>


<p>spring security的所有的架构也是基于这两个核心功能去实现的。</p>
<h3 id="2、框架原理"><a href="#2、框架原理" class="headerlink" title="2、框架原理"></a>2、框架原理</h3><p>​     众所周知 想要对对Web资源进行保护，最好的办法莫过于Filter，要想对方法调用进行保护，最好的办法莫过于AOP。所以springSecurity在我们进行用户认证以及授予权限的时候，通过各种各样的拦截器来控制权限的访问，从而实现安全。</p>
<h5 id="关于-oAth2"><a href="#关于-oAth2" class="headerlink" title="关于 oAth2"></a>关于 oAth2</h5><p>​    oAth2不是一种技术，而是一种安全协议</p>
<h3 id="3，框架基础"><a href="#3，框架基础" class="headerlink" title="3，框架基础"></a>3，框架基础</h3><ul>
<li><p>配置认证服务器</p>
<ul>
<li><p>配置客户端信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClientDetailsServiceConfigurer</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inMemory</code>：内存配置</li>
<li><code>withClient</code>：客户端标识</li>
<li><code>secret</code>：客户端安全码</li>
<li><code>authorizedGrantTypes</code>：客户端授权类型</li>
<li><code>scopes</code>：客户端授权范围</li>
<li><code>redirectUris</code>：注册回调地址</li>
</ul>
</li>
</ul>
</li>
<li><p>配置 Web 安全</p>
</li>
<li><p>通过 GET 请求访问认证服务器获取授权码</p>
<ul>
<li>端点：<code>/oauth/authorize</code></li>
</ul>
</li>
<li><p>通过 POST 请求利用授权码访问认证服务器获取令牌</p>
<ul>
<li>端点：<code>/oauth/token</code></li>
</ul>
</li>
</ul>
<p><strong>默认的端点 URL</strong></p>
<ul>
<li><p><code>/oauth/authorize</code>：授权端点</p>
</li>
<li><p><code>/oauth/token</code>：令牌端点</p>
</li>
<li><p><code>/oauth/confirm_access</code>：用户确认授权提交端点</p>
</li>
<li><p><code>/oauth/error</code>：授权服务错误信息端点</p>
</li>
<li><p><code>/oauth/check_token</code>：用于资源服务访问的令牌解析端点</p>
</li>
<li><p><code>/oauth/token_key</code>：提供公有密匙的端点，如果你使用 JWT 令牌的话</p>
</li>
</ul>
<h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>  <img alt="253eb4ef0c03ae7" data-src="253eb4ef0c03ae7.png"></p>
<h3 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h3><ol>
<li><p>​        创建spring-cloud项目</p>
<ul>
<li>项目根pom        </li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;spring-security-oauth2-dependencies&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;spring-security-oauth2-server&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;cn.dszmr&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;spring-security-test&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;$&#123;java.version&#125;&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;$&#123;java.version&#125;&lt;/maven.compiler.target&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;cn.dszmr&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-security-oauth2-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;spring-milestone&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Spring Milestone&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.spring.io/milestone&lt;/url&gt;</span></span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;spring-snapshot&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Spring Snapshot&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.spring.io/snapshot&lt;/url&gt;</span></span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line">    &lt;pluginRepositories&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">            &lt;id&gt;spring-milestone&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Spring Milestone&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.spring.io/milestone&lt;/url&gt;</span></span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/pluginRepository&gt;</span><br><span class="line">        &lt;pluginRepository&gt;</span><br><span class="line">            &lt;id&gt;spring-snapshot&lt;/id&gt;</span><br><span class="line">            &lt;name&gt;Spring Snapshot&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//repo.spring.io/snapshot&lt;/url&gt;</span></span><br><span class="line">            &lt;snapshots&gt;</span><br><span class="line">                &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">            &lt;/snapshots&gt;</span><br><span class="line">        &lt;/pluginRepository&gt;</span><br><span class="line">    &lt;/pluginRepositories&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>项目统一依赖管理项目pom</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.dszmr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建认证服务</p>
<ul>
<li>pom</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.dszmr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-oauth2-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Security --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestone<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestone<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestone<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>项目application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">oauth2-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>认证服务器配置基于内存模式（WebSecurityConfiguration类）</p>
<blockquote>
<p>该类用于配置用户 和分配权限</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//声明这是一个配置类</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">//加载配置认证信息</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>, securedEnabled = <span class="keyword">true</span>, jsr250Enabled = <span class="keyword">true</span>)<span class="comment">//全局方法拦截</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置默认的加密方式 也就是密码加密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在内存中创建用户</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">                <span class="comment">//配置用户名为user 配置密码为123456并加密 配值权限为USER</span></span><br><span class="line">                .withUser(<span class="string">"user"</span>).password(passwordEncoder().encode(<span class="string">"123456"</span>)).roles(<span class="string">"USER"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .withUser(<span class="string">"admin"</span>).password(passwordEncoder().encode(<span class="string">"admin888"</span>)).roles(<span class="string">"ADMIN"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>认证服务器配置基于内存模式（AuthorizationServerConfiguration类）</p>
<blockquote>
<p>该类用于配置security的授权模式与应用范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.dszmr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span>  <span class="comment">//告诉spring 需要加载那些spring security 的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfiguration</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder passwordEncoder; <span class="comment">//注入密码模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置客户端</span></span><br><span class="line">        clients</span><br><span class="line">                <span class="comment">// 使用内存设置</span></span><br><span class="line">                .inMemory()</span><br><span class="line">                <span class="comment">// client_id</span></span><br><span class="line">                .withClient(<span class="string">"client"</span>)</span><br><span class="line">                <span class="comment">// client_secret</span></span><br><span class="line">                .secret(passwordEncoder.encode(<span class="string">"secret"</span>))</span><br><span class="line">                <span class="comment">// 授权类型</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">"authorization_code"</span>)</span><br><span class="line">                <span class="comment">// 授权范围</span></span><br><span class="line">                .scopes(<span class="string">"app"</span>)</span><br><span class="line">                <span class="comment">// 注册回调地址</span></span><br><span class="line">                .redirectUris(<span class="string">"https://www.baidu.com"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过浏览器访问获得令牌<br> 访问  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL29hdXRoL2F1dGhvcml6ZT9jbGllbnRfaWQ9Y2xpZW50JmFtcDtyZXNwb25zZV90eXBlPWNvZGU=" title="http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code<i class="fa fa-external-link"></i></span></p>
<p>​    </p>
<ul>
<li>第一次访问会跳转到登录页面</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/81b26cd8f499725.png"></p>
<ul>
<li>验证成功后会询问用户是否授权客户端</li>
</ul>
<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/6d93fe9ca240195.png"></p>
<ul>
<li>选择授权后会跳转到百度，浏览器地址上还会包含一个授权码（<code>code=1JuO6V</code>），浏览器地址栏会显示如下地址：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://www.baidu.com/?code=1JuO6V</span><br></pre></td></tr></table></figure>
</li>
<li><p>向服务器申请令牌</p>
</li>
<li><p>通过 CURL 或是 Postman 请求</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -d &apos;grant_type=authorization_code&amp;code=1JuO6V&apos; &quot;http://client:secret@localhost:8080/oauth/token&quot;</span><br></pre></td></tr></table></figure>

<p><img alt="img" data-src="http://www.qfdmy.com/wp-content/uploads/2019/08/1dc1ad17978e97d.png"></p>
<ul>
<li>得到响应结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    &quot;access_token&quot;: &quot;016d8d4a-dd6e-4493-b590-5f072923c413&quot;,    &quot;token_type&quot;: &quot;bearer&quot;,    &quot;expires_in&quot;: 43199,    &quot;scope&quot;: &quot;app&quot;&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>主流框架</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
        <tag>spring全家桶</tag>
      </tags>
  </entry>
  <entry>
    <title>gateway网关</title>
    <url>/posts/1a1a324a/</url>
    <content><![CDATA[<p><strong>实现思想</strong></p><p>一个微服务项目有着很多的服务，但是服务与服务之间的域名肯定不相同那么每一次请求服务时，对于域名的修改就显得极为麻烦了，所以在微服务生态中就有了网关，网关统一请求路径也就是每一个请求都会经过网关，当请求到达gateway时在通过动态路由分配到各个对应的服务</p><p><strong>功能特征</strong></p><ul>
<li>基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</li>
<li>动态路由</li>
<li>Predicates 和 Filters 作用于特定路由</li>
<li>集成 Hystrix 断路器</li>
<li>集成 Spring Cloud DiscoveryClient</li>
<li>易于编写的 Predicates 和 Filters</li>
<li>限流</li>
<li>路径重写</li>
</ul><a id="more"></a>



<p><strong>具体拦截与分配代码</strong></p>
<h1 id="采用自定义路由-ID（有固定用法，不同的-id-有不同的功能，详见：https-cloud-spring-io-spring-cloud-gateway-2-0-x-single-spring-cloud-gateway-html-gateway-route-filters）"><a href="#采用自定义路由-ID（有固定用法，不同的-id-有不同的功能，详见：https-cloud-spring-io-spring-cloud-gateway-2-0-x-single-spring-cloud-gateway-html-gateway-route-filters）" class="headerlink" title="采用自定义路由 ID（有固定用法，不同的 id 有不同的功能，详见：https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）"></a>采用自定义路由 ID（有固定用法，不同的 id 有不同的功能，详见：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5zcHJpbmcuaW8vc3ByaW5nLWNsb3VkLWdhdGV3YXkvMi4wLngvc2luZ2xlL3NwcmluZy1jbG91ZC1nYXRld2F5Lmh0bWwjZ2F0ZXdheS1yb3V0ZS1maWx0ZXJz77yJ" title="https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）">https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）<i class="fa fa-external-link"></i></span></h1><ul>
<li>id: BUSINESS-OAUTH2<h1 id="采用-LoadBalanceClient-方式请求，以-lb-开头，后面的是注册在-Nacos-上的服务名"><a href="#采用-LoadBalanceClient-方式请求，以-lb-开头，后面的是注册在-Nacos-上的服务名" class="headerlink" title="采用 LoadBalanceClient 方式请求，以 lb:// 开头，后面的是注册在 Nacos 上的服务名"></a>采用 LoadBalanceClient 方式请求，以 lb:// 开头，后面的是注册在 Nacos 上的服务名</h1>uri: lb://business-oauth2<h1 id="Predicate-翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法"><a href="#Predicate-翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法" class="headerlink" title="Predicate 翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法"></a>Predicate 翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法</h1>predicates:<h1 id="路径匹配，以-api-开头，直接配置是不生效的，看-filters-配置"><a href="#路径匹配，以-api-开头，直接配置是不生效的，看-filters-配置" class="headerlink" title="路径匹配，以 api 开头，直接配置是不生效的，看 filters 配置"></a>路径匹配，以 api 开头，直接配置是不生效的，看 filters 配置</h1><ul>
<li>Path=/api/user/**<br>filters:<h1 id="前缀过滤，默认配置下，我们的请求路径是-http-localhost-8888-business-oauth2-这时会路由到指定的服务"><a href="#前缀过滤，默认配置下，我们的请求路径是-http-localhost-8888-business-oauth2-这时会路由到指定的服务" class="headerlink" title="前缀过滤，默认配置下，我们的请求路径是 http://localhost:8888/business-oauth2/** 这时会路由到指定的服务"></a>前缀过滤，默认配置下，我们的请求路径是 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2J1c2luZXNzLW9hdXRoMi8=" title="http://localhost:8888/business-oauth2/">http://localhost:8888/business-oauth2/<i class="fa fa-external-link"></i></span>** 这时会路由到指定的服务</h1><h1 id="此处配置去掉-1-个路径前缀，再配置上面的-Path-api-，就能按照-http-localhost-8888-api-的方式访问了"><a href="#此处配置去掉-1-个路径前缀，再配置上面的-Path-api-，就能按照-http-localhost-8888-api-的方式访问了" class="headerlink" title="此处配置去掉 1 个路径前缀，再配置上面的 Path=/api/，就能按照 http://localhost:8888/api/ 的方式访问了"></a>此处配置去掉 1 个路径前缀，再配置上面的 Path=/api/<strong>，就能按照 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2FwaS8=" title="http://localhost:8888/api/">http://localhost:8888/api/<i class="fa fa-external-link"></i></span></strong> 的方式访问了</h1></li>
<li>StripPrefix=1</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<p>创建一个项目名为<strong>gateway</strong></p>
<ol>
<li>添加pom依赖</li>
</ol>
<dependencies>
    <!-- Spring Boot Begin -->
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-actuator</artifactid>
    </dependency>
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-test</artifactid>
        <scope>test</scope>
    </dependency>
    <!-- Spring Boot End -->
    <!-- Spring Cloud Begin -->
    <dependency>
        <groupid>org.springframework.cloud</groupid>
        <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>
        <version>0.9.0.RELEASE</version>
    </dependency>
    <dependency>
        <groupid>org.springframework.cloud</groupid>
        <artifactid>spring-cloud-starter-gateway</artifactid>
    </dependency>
    <!-- Spring Cloud End -->
    <!-- Commons Begin -->
    <dependency>
        <groupid>javax.servlet</groupid>
        <artifactid>javax.servlet-api</artifactid>
    </dependency>
    <!-- Commons Begin -->
</dependencies>

<pre><code>2.application.yml</code></pre><p>base:<br>  config:<br>    nacos:<br>      hostname: 106.54.8.126<br>      port: 8848<br>spring:<br>  application:<br>    # 应用名称<br>​    name: gateway<br>  main:<br>​    allow-bean-definition-overriding: true<br>  cloud:<br>    # 使用 Nacos 作为服务注册发现<br>​    nacos:<br>​      discovery:<br>​        server-addr: ${base.config.nacos.hostname}:${base.config.nacos.port}<br>    # 路由网关配置<br>​    gateway:<br>      # 设置与服务注册发现组件结合，这样可以采用服务名的路由策略<br>​      discovery:<br>​        locator:<br>​          enabled: true<br>      # 配置路由规则<br>​      routes:<br>        # 采用自定义路由 ID（有固定用法，不同的 id 有不同的功能，详见：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5zcHJpbmcuaW8vc3ByaW5nLWNsb3VkLWdhdGV3YXkvMi4wLngvc2luZ2xlL3NwcmluZy1jbG91ZC1nYXRld2F5Lmh0bWwjZ2F0ZXdheS1yb3V0ZS1maWx0ZXJz77yJ" title="https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）">https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）<i class="fa fa-external-link"></i></span><br>        - id: BUSINESS-OAUTH2<br>          # 采用 LoadBalanceClient 方式请求，以 lb:// 开头，后面的是注册在 Nacos 上的服务名<br>          uri: lb://business-oauth2<br>          # Predicate 翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法<br>          predicates:<br>            # 路径匹配，以 api 开头，直接配置是不生效的，看 filters 配置<br>            - Path=/api/user/**<br>          filters:<br>            # 前缀过滤，默认配置下，我们的请求路径是 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2J1c2luZXNzLW9hdXRoMi8=" title="http://localhost:8888/business-oauth2/">http://localhost:8888/business-oauth2/<i class="fa fa-external-link"></i></span>** 这时会路由到指定的服务<br>            # 此处配置去掉 1 个路径前缀，再配置上面的 Path=/api/<strong>，就能按照 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4L2FwaS8=" title="http://localhost:8888/api/">http://localhost:8888/api/<i class="fa fa-external-link"></i></span></strong> 的方式访问了<br>            - StripPrefix=1<br>                - id: BUSINESS-PROFILE<br>          uri: lb://business-profile<br>          predicates:<br>            - Path=/api/profile/**<br>          filters:<br>            - StripPrefix=1<br>server:<br>      port: 8888</p>
<h1 id="配置日志级别，方别调试"><a href="#配置日志级别，方别调试" class="headerlink" title="配置日志级别，方别调试"></a>配置日志级别，方别调试</h1><p>logging:<br>  level:<br>    org.springframework.cloud.gateway: debug</p>
<p>3.GatewayApplication</p>
<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br>import org.springframework.cloud.client.discovery.DiscoveryClient;<br>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br>import org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator;<br>import org.springframework.cloud.gateway.discovery.DiscoveryLocatorProperties;<br>import org.springframework.cloud.gateway.route.RouteDefinitionLocator;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.http.HttpHeaders;<br>import org.springframework.http.HttpMethod;<br>import org.springframework.http.HttpStatus;<br>import org.springframework.http.codec.ServerCodecConfigurer;<br>import org.springframework.http.codec.support.DefaultServerCodecConfigurer;<br>import org.springframework.http.server.reactive.ServerHttpRequest;<br>import org.springframework.http.server.reactive.ServerHttpResponse;<br>import org.springframework.web.cors.reactive.CorsUtils;<br>import org.springframework.web.server.ServerWebExchange;<br>import org.springframework.web.server.WebFilter;<br>import org.springframework.web.server.WebFilterChain;<br>import reactor.core.publisher.Mono;<br>/**</p>
<ul>
<li>Spring Cloud Gateway</li>
<li><p></p></li>
<li>Description:</li>
<li><p></p></li>
<li></li>
<li>@author Lusifer</li>
<li>@version v1.0.0</li>
<li>@date 2019-08-01 11:14:35</li>
<li>@see</li>
<li>/<br>@SpringBootApplication<br>@EnableDiscoveryClient<br>public class GatewayApplication {<br>  // —————————– 解决跨域 Begin —————————–<br>  private static final String ALL = “*”;<br>  private static final String MAX_AGE = “3600L”;<br>  @Bean<br>  public RouteDefinitionLocator discoveryClientRouteDefinitionLocator(DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) {<pre><code>return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties);</code></pre>  }<br>  @Bean<br>  public ServerCodecConfigurer serverCodecConfigurer() {<pre><code>return new DefaultServerCodecConfigurer();</code></pre>  }<br>  @Bean<br>  public WebFilter corsFilter() {<pre><code>return (ServerWebExchange ctx, WebFilterChain chain) -&gt; {
    ServerHttpRequest request = ctx.getRequest();
    if (!CorsUtils.isCorsRequest(request)) {
        return chain.filter(ctx);
    }
    HttpHeaders requestHeaders = request.getHeaders();
    ServerHttpResponse response = ctx.getResponse();
    HttpMethod requestMethod = requestHeaders.getAccessControlRequestMethod();
    HttpHeaders headers = response.getHeaders();
    headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, requestHeaders.getOrigin());
    headers.addAll(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, requestHeaders.getAccessControlRequestHeaders());
    if (requestMethod != null) {
        headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, requestMethod.name());
    }
    headers.add(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, &quot;true&quot;);
    headers.add(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, ALL);
    headers.add(HttpHeaders.ACCESS_CONTROL_MAX_AGE, MAX_AGE);
    if (request.getMethod() == HttpMethod.OPTIONS) {
        response.setStatusCode(HttpStatus.OK);
        return Mono.empty();
    }
    return chain.filter(ctx);
};</code></pre>  }<br>  // —————————– 解决跨域 End —————————–<br>  public static void main(String[] args) {<pre><code>SpringApplication.run(GatewayApplication.class, args);</code></pre>  }<br>}</li>
</ul>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs设置全局路径后npm报错 已解决</title>
    <url>/posts/daddcf83/</url>
    <content><![CDATA[<p>nodejs 在 npm config set prefix “path of npm_global” 设置全局路径后一直出现如下错误</p><p><img alt="大大大" data-src="%E5%A4%A7%E5%A4%A7%E5%A4%A7.bmp"></p><p>解决办法：</p><p>​                <strong>删除c盘用户目录下的.cnpm文件即可解决</strong></p>]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>bug记录</tag>
      </tags>
  </entry>
  <entry>
    <title>4，Nacos分布式配置中心</title>
    <url>/posts/d7a54cc5/</url>
    <content><![CDATA[<p><strong>以服务消费者service-consumer为例</strong></p><ol>
<li>添加pom依赖</li>
</ol><p><dependency>     <groupid>org.springframework.cloud</groupid>     <artifactid>spring-cloud-starter-alibaba-nacos-config</artifactid> </dependency> </p><p>2.打开nacos 打开 服务配置列表 点击新增配置</p><p><img alt="img" data-src="clipboard.png"></p><p>3.添加服务</p><p>Data ID 必须是唯一的  </p><a id="more"></a>






<p>以.yaml结尾</p>
<p>并选中配置格式 .yaml</p>
<p>否则系统将默认为.properties文件</p>
<p><img alt="img" data-src="clipboard1.png"></p>
<p>4.把consumer项目的application.yml 配置复制到</p>
<p><img alt="img" data-src="clipboard2.png"></p>
<p>后面增加一个节点用于测试</p>
<p>test:     name: “dsz” </p>
<pre><code>5.在controller </code></pre><ul>
<li>添加注解@RefreshScope</li>
</ul>
<p><img alt="img" data-src="clipboard3.png"></p>
<ul>
<li>注入测试节点</li>
</ul>
<p>@Value(“${test.name}”) private String name; </p>
<ul>
<li>新增测试方法</li>
</ul>
<p>@GetMapping(“name”) public String getName() {     return name; } </p>
<p>6.修改application.yml </p>
<ul>
<li><p>删除 application.yml </p>
</li>
<li><p>添加bootstrap.properties</p>
<p>bootstrap.properties配置内容</p>
</li>
</ul>
<p>#配置的Data ID spring.application.name=service-consumer-config # nacos 的地址 spring.cloud.nacos.config.server-addr= 106.54.8.126:8848  #配置的文件格式 spring.cloud.nacos.config.file-extension=yaml </p>
<p>附：</p>
<p>spring-boot配置文件加载顺序</p>
<p>spring-boot会默认按照如下顺序加载  有时候 application加载不到就是因为 加载顺序的原因</p>
<p>bootstrap.properties-&gt;bootstrap.yml-&gt;application.properties-&gt;application.yml </p>
<p>7.运行测试</p>
<p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL25hbWU=" title="http://localhost:8080/name">http://localhost:8080/name<i class="fa fa-external-link"></i></span></p>
<p><img alt="img" data-src="clipboard4.png"></p>
<p>修改配置</p>
<p><img alt="img" data-src="clipboard5.png"></p>
<p>刷新</p>
<p><img alt="img" data-src="clipboard6.png"></p>
<p>成功！</p>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>3，Nacos Feign 客户端</title>
    <url>/posts/7501af29/</url>
    <content><![CDATA[<p><strong>创建服务消费者spring-cloud-demo-consumer</strong></p><ol>
<li>修改pom添加依赖</li>
</ol><dependencies>
    <!-- Spring Boot Begin -->
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-web</artifactid>
    </dependency>
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-actuator</artifactid>
    </dependency>
    <dependency>
        <groupid>org.springframework.cloud</groupid>
        <artifactid>spring-cloud-starter-openfeign</artifactid>
    </dependency>
    <!-- Spring Boot End -->
    <!-- Spring Cloud Begin -->
    <dependency>
        <groupid>org.springframework.cloud</groupid>
        <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>
    </dependency>
    <!-- Spring Cloud End -->
</dependencies><a id="more"></a>





<p>2.创建并修改 application.yml </p>
<p>spring:<br>  application:<br>    # 服务名<br>​    name: service-consumer<br>  cloud:<br>​    nacos:<br>​      discovery:<br>        # 服务注册中心<br>​        server-addr: 192.168.141.132:8848<br>server:</p>
<h1 id="服务端口"><a href="#服务端口" class="headerlink" title="服务端口"></a>服务端口</h1><p>  port: 8080<br>management:</p>
<h1 id="端点检查（健康检查）"><a href="#端点检查（健康检查）" class="headerlink" title="端点检查（健康检查）"></a>端点检查（健康检查）</h1><p>  endpoints:<br>    web:<br>      exposure:<br>        include: “*”</p>
<p>3.创建启动类</p>
<p>import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class ConsumerApplication {     public static void main(String[] args) {         SpringApplication.run(ConsumerApplication.class, args);     } } </p>
<p>4.启动查看nacos</p>
<p><img alt="img" data-src="clipboard.png"></p>
<p>服务注册成功!</p>
<p><strong>使用feign客户端请求provider服务提供者获得服务</strong></p>
<ol>
<li>在consumer创建好目录结构</li>
</ol>
<p><img alt="img" data-src="clipboard1.png"></p>
<ol>
<li>在service处添加</li>
</ol>
<p>@FeignClient(“service-provider”)这个注解的意思是向名为service-provider的服务发起请求</p>
<p>@GetMapping(“/dsz”) 此注解的意思是向 /dsz 的路径发起get请求</p>
<p>import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable;  import java.util.List;  @FeignClient(“service-provider”) public interface EchoService {     @GetMapping(“/dsz”)     List<string> getList(); } </string></p>
<p>3.在controller处添加</p>
<p>@RestController public class TestEchoController {       @Autowired     private EchoService echoService;          @GetMapping(value = “/feign/list”)     public List echo() {         return echoService.getList();     } } </p>
<p>4.修改provider项目的controller 创建一个集合并输出</p>
<p>@RestController public class EchoController {      @GetMapping(value = “dsz”)     public List<string> ok(){         ArrayList<string> strings = new ArrayList&lt;&gt;();         strings.add(“dsz1”);         strings.add(“dsz2”);         strings.add(“dsz3”);         strings.add(“dsz4”);         strings.add(“dsz5”);         return strings;     } } </string></string></p>
<p>5.启动项目</p>
<p><img alt="img" data-src="clipboard2.png"></p>
<p>请求成功</p>
<p>这一个小demo的意思就是通过服务消费者的service，去请求服务提供者 ，</p>
<p>获取数据，然后服务消费者进行输出展示最终结果</p>
<p><img alt="img" data-src="clipboard3.png"></p>
<p><strong>feign负载均衡</strong></p>
<p>修改idea 配置</p>
<p><img alt="img" data-src="clipboard4.png"></p>
<p><img alt="img" data-src="clipboard5.png"></p>
<p>启动一台服务提供者provider后</p>
<p>修改端口号 再启动一台</p>
<p>在controller处创建变量提取配置文件端口号 通过端口号的变换 来确定是否实现负载均衡</p>
<ol>
<li>修改controller  添加  </li>
</ol>
<p>@Value(“${server.port}”) private String port;  @GetMapping(value = “/echo/{string}”) public String echo(@PathVariable String string) {     return string+”  您好，负载均衡已经开启 现在是端口为”+port+”的服务器为您提供服务！”; } </p>
<p>2.修改服务消费者consumer service 添加如下配置</p>
<p>@GetMapping(value = “/echo/{string}”) String echo(@PathVariable(“string”) String string); </p>
<p>3.修改controller添加</p>
<p>@GetMapping(value = “/feign/echo/{str}”) public String echo(@PathVariable String str) {     return echoService.echo(str); } </p>
<p>4.浏览器请求  <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2ZlaWduL2VjaG8vZHN6" title="http://localhost:8080/feign/echo/dsz">http://localhost:8080/feign/echo/dsz<i class="fa fa-external-link"></i></span></p>
<p><img alt="img" data-src="clipboard6.png"></p>
<p>5.刷新浏览器</p>
<p><img alt="img" data-src="clipboard7.png"></p>
<p>负载均衡成功！</p>
<p><strong>附：扩展阅读</strong></p>
<p><strong>常见负载均衡策略</strong></p>
<p>负载主机可以提供很多种负载均衡方法，也就是我们常说的调度方法或算法</p>
<p><strong>轮循</strong></p>
<p><strong>Round Robin：</strong> 这种方法会将收到的请求循环分配到服务器集群中的每台机器，即有效服务器。如果使用这种方式，所有的标记进入虚拟服务的服务器应该有相近的资源容量 以及负载形同的应用程序。如果所有的服务器有相同或者相近的性能那么选择这种方式会使服务器负载形同。基于这个前提，轮循调度是一个简单而有效的分配请求 的方式。然而对于服务器不同的情况，选择这种方式就意味着能力比较弱的服务器也会在下一轮循环中接受轮循，即使这个服务器已经不能再处理当前这个请求了。 这可能导致能力较弱的服务器超载。</p>
<p><strong>加权轮循</strong></p>
<p><strong>Weighted Round Robin：</strong> 这种算法解决了简单轮循调度算法的缺点：传入的请求按顺序被分配到集群中服务器，但是会考虑提前为每台服务器分配的权重。管理员只是简单的通过服务 器的处理能力来定义各台服务器的权重。例如，能力最强的服务器 A 给的权重是 100，同时能力最低的服务器给的权重是 50。这意味着在服务器 B 接收到第一个 请求之前前，服务器 A 会连续的接受到 2 个请求，以此类推。</p>
<p><strong>最少连接数</strong></p>
<p><strong>Least Connection：</strong> 以上两种方法都没有考虑的是系统不能识别在给定的时间里保持了多少连接。因此可能发生，服务器 B 服务器收到的连接比服务器 A 少但是它已经超载，因为 服务器 B 上的用户打开连接持续的时间更长。这就是说连接数即服务器的负载是累加的。这种潜在的问题可以通过 “最少连接数” 算法来避免：传入的请求是根据每 台服务器当前所打开的连接数来分配的。即活跃连接数最少的服务器会自动接收下一个传入的请求。接本上和简单轮询的原则相同：所有拥有虚拟服务的服务器资源 容量应该相近。值得注意的是，在流量率低的配置环境中，各服务器的流量并不是相同的，会优先考虑第一台服务器。这是因为，如果所有的服务器是相同的，那么 第一个服务器优先，直到第一台服务器有连续的活跃流量，否则总是会优先选择第一台服务器。</p>
<p><strong>最少连接数慢启动时间</strong></p>
<p><strong>Least Connection Slow Start Time：</strong> 对最少连接数和带权重的最小连接数调度方法来说，当一个服务器刚加入线上环境是，可以为其配置一个时间段，在这段时间内连接数是有限制的而且是缓慢 增加的。这为服务器提供了一个‘过渡时间’以保证这个服务器不会因为刚启动后因为分配的连接数过多而超载。这个值在 L7 配置界面设置。</p>
<p><strong>加权最少连接</strong></p>
<p><strong>Weighted Least Connection：</strong> 如果服务器的资源容量各不相同，那么 “加权最少连接” 方法更合适：由管理员根据服务器情况定制的权重所决定的活跃连接数一般提供了一种对服务器非常 平衡的利用，因为他它借鉴了最少连接和权重两者的优势。通常，这是一个非常公平的分配方式，因为它使用了连接数和服务器权重比例；集群中比例最低的服务器 自动接收下一个请求。但是请注意，在低流量情况中使用这种方法时，请参考 “最小连接数” 方法中的注意事项。</p>
<p><strong>基于代理的自适应负载均衡</strong></p>
<p><strong>Agent Based Adaptive Balancing：</strong> 除了上述方法之外，负载主机包含一个自适用逻辑用来定时监测服务器状态和该服务器的权重。对于非常强大的 “基于代理的自适应负载均衡” 方法来说，负 载主机以这种方式来定时检测所有服务器负载情况：每台服务器都必须提供一个包含文件，这个文件包含一个 0~99 的数字用来标明改服务器的实际负载情况 (0 = 空前，99 = 超载，101 = 失败，102 = 管理员禁用)，而服务器同构 http get 方法来获取这个文件；同时对集群中服务器来说，以二进制文件形式提供自身负载情况也是该服务器工作之一，然而，并没有限制服务器如何计算自身的负载 情况。根据服务器整体负载情况，有两种策略可以选择：在常规的操作中，调度算法通过收集的服务器负载值和分配给该服务器的连接数的比例计算出一个权重比 例。因此，如果一个服务器负载过大，权重会通过系统透明的作重新调整。和加权轮循调度方法一样，不正确的分配可以被记录下来使得可以有效的为不同服务器分 配不同的权重。然而，在流量非常低的环境下，服务器报上来的负载值将不能建立一个有代表性的样本；那么基于这些值来分配负载的话将导致失控以及指令震荡。 因此，在这种情况下更合理的做法是基于静态的权重比来计算负载分配。当所有服务器的负载低于管理员定义的下限时，负载主机就会自动切换为加权轮循方式来分 配请求；如果负载大于管理员定义的下限，那么负载主机又会切换回自适应方式。</p>
<p><strong>固定权重</strong></p>
<p><strong>Fixed Weighted：</strong> 最高权重只有在其他服务器的权重值都很低时才使用。然而，如果最高权重的服务器下降，则下一个最高优先级的服务器将为客户端服务。这种方式中每个真实服务器的权重需要基于服务器优先级来配置。</p>
<p><strong>加权响应</strong></p>
<p><strong>Weighted Response：</strong> 流量的调度是通过加权轮循方式。加权轮循中所使用的权重是根据服务器有效性检测的响应时间来计算。每个有效性检测都会被计时，用来标记它响应成功花 了多长时间。但是需要注意的是，这种方式假定服务器心跳检测是基于机器的快慢，但是这种假设也许不总是能够成立。所有服务器在虚拟服务上的响应时间的总和 加在一起，通过这个值来计算单个服务物理服务器的权重；这个权重值大约每 15 秒计算一次。</p>
<p><strong>源 IP 哈希</strong></p>
<p><strong>Source IP Hash：</strong> 这种方式通过生成请求源 IP 的哈希值，并通过这个哈希值来找到正确的真实服务器。这意味着对于同一主机来说他对应的服务器总是相同。使用这种方式，你不需要保存任何源 IP。但是需要注意，这种方式可能导致服务器负载不平衡。</p>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>2，服务注册与发现Nacos</title>
    <url>/posts/9eeb3ef5/</url>
    <content><![CDATA[<p>Nacos需要部署 所以想自己部署的同学请移步docker学习</p><p><strong>部署操作步骤</strong></p><ol>
<li><strong>Clone 项目</strong></li>
</ol><p>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25hY29zLWdyb3VwL25hY29zLWRvY2tlci5naXQ=" title="https://github.com/nacos-group/nacos-docker.git">https://github.com/nacos-group/nacos-docker.git<i class="fa fa-external-link"></i></span> cd nacos-docker </p><ol>
<li><strong>单机模式</strong></li>
</ol><p>docker-compose -f example/standalone-mysql.yaml up -d </p><a id="more"></a>





<p><strong>3.查看日志</strong></p>
<p>docker-compose -f example/standalone-mysql.yaml logs -f </p>
<p><strong>4.Nacos 控制台</strong></p>
<p>​         <span class="exturl" data-url="aHR0cDovL3d3dy5xZmRteS5jb20vd3AtY29udGVudC90aGVtZXMvcXVhbmJhaWtlL2dvLnBocD91cmw9YUhSMGNEb3ZMekU1TWk0eE5qZ3VNVFF4TGpFek1qbzRPRFE0TDI1aFkyOXo=" title="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cDovLzE5Mi4xNjguMTQxLjEzMjo4ODQ4L25hY29z">http://服务器地址:8848/nacos<i class="fa fa-external-link"></i></span></p>
<p>如果想以后再部署的同学可以使用我的nacos</p>
<p>​        <span class="exturl" data-url="aHR0cDovLzEwNi41NC44LjEyNjo4ODQ4L25hY29z" title="http://106.54.8.126:8848/nacos">http://106.54.8.126:8848/nacos<i class="fa fa-external-link"></i></span></p>
<p>账号：nacos</p>
<p>密码：nacos</p>
<p><strong>服务注册与发现</strong></p>
<p>新增模块  spring-cloud-demo-provider服务提供者</p>
<p><img alt="img" data-src="clipboard.png"></p>
<p><strong>添加pom依赖</strong></p>
<p>注：如遇maven报错请移步《maven报错解决》</p>
<dependencies>
    <!-- Spring Boot Begin -->
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-web</artifactid>
    </dependency>
    <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-starter-actuator</artifactid>
    </dependency>
    <!-- Spring Boot End -->
    <!-- Spring Cloud Begin -->
    <dependency>
        <groupid>org.springframework.cloud</groupid>
        <artifactid>spring-cloud-starter-alibaba-nacos-discovery</artifactid>
    </dependency>
    <!-- Spring Cloud End -->
</dependencies>



<p><strong>项目结构</strong></p>
<p><img alt="img" data-src="clipboard1.png"></p>
<ol>
<li>创建启动类</li>
</ol>
<p>import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient;   @SpringBootApplication @EnableDiscoveryClient public class ProviderApplication {     public static void main(String[] args) {         SpringApplication.run(ProviderApplication.class, args);     } } </p>
<p>2.创建controller</p>
<p>@RestController public class EchoController {      @GetMapping(value = “/echo/{string}”)     public String echo(@PathVariable String string) {         return “hello “+string;     }     } </p>
<p>3.创建application.yml</p>
<p>spring:<br>  application:<br>    # 服务名<br>​    name: service-provider<br>  cloud:<br>​    nacos:<br>​      discovery:<br>        # 服务注册中心<br>​        server-addr: 106.54.8.126:8848<br>server:</p>
<h1 id="服务端口"><a href="#服务端口" class="headerlink" title="服务端口"></a>服务端口</h1><p>  port: 8071<br>management:</p>
<h1 id="端点检查（健康检查）"><a href="#端点检查（健康检查）" class="headerlink" title="端点检查（健康检查）"></a>端点检查（健康检查）</h1><p>  endpoints:<br>    web:<br>      exposure:<br>        include: “*”</p>
<p><strong>运行项目</strong></p>
<p>访问 ： <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDcwL2VjaG8vZHN6" title="http://localhost:8070/echo/dsz">http://localhost:8070/echo/dsz<i class="fa fa-external-link"></i></span> </p>
<p><strong>再登录nacos</strong></p>
<p>前面有说如何登录</p>
<p><img alt="img" data-src="clipboard2.png"></p>
<p>显示服务名即表示服务注册成功</p>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>1，统一依赖管理</title>
    <url>/posts/undefined/</url>
    <content><![CDATA[<p><strong>创建一个普通spring-boot工程</strong></p><p><img alt="img" data-src="clipboard.png"></p><p><strong>修改pom文件</strong></p><ol>
<li>修改pom文件默认打包方式为pom</li>
</ol><p><packaging>pom</packaging> </p><ol>
<li>添加统一版本管理</li>
</ol><p><properties>     &lt;java.version&gt;1.8&lt;/java.version&gt;     &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;     &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;     &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;     &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; </properties> </p><a id="more"></a>






<p>3.添加插件管理</p>
<p>插件管理备注：</p>
<p>  <id>default</id> 这是一个标注现在状态的一个属性 可以自定义</p>
  <activation>

<p>​            <activebydefault>true</activebydefault></p>
  </activation>

<p>表示为默认使用状态 如果不使用可以设置为false</p>
<p>spring.javaformat</p>
<p>代码格式化插件 可以将代码格式化为spring风格</p>
<p>maven-surefire-plugin</p>
<p>测试运行器</p>
<p>maven-enforcer-plugin</p>
<p>用于管理jar包冲突 如遇jar包冲突允许即可打印冲突jar包</p>
<p>maven-install-plugin</p>
<p>maven的默认插件之一</p>
<p>maven-javadoc-plugin</p>
<p>生成javadoc文档工具 与java8有冲突 可以不使用</p>
<profiles>
    <profile>
        <id>default</id>
        <activation>
            <activebydefault>true</activebydefault>
        </activation>
        <properties>
            <spring-javaformat.version>0.0.12</spring-javaformat.version>
        </properties>
        <build>
            <plugins>
                <plugin>
                    <groupid>io.spring.javaformat</groupid>
                    <artifactid>spring-javaformat-maven-plugin</artifactid>
                    <version>${spring-javaformat.version}</version>
                </plugin>
                <plugin>
                    <groupid>org.apache.maven.plugins</groupid>
                    <artifactid>maven-surefire-plugin</artifactid>
                    <configuration>
                        <includes>
                            <include>**/*Tests.java</include>
                        </includes>
                        <excludes>
                            <exclude>**/Abstract*.java</exclude>
                        </excludes>
                        <systempropertyvariables>
                            <java.security.egd>file:/dev/./urandom</java.security.egd>
                            <java.awt.headless>true</java.awt.headless>
                        </systempropertyvariables>
                    </configuration>
                </plugin>
                <plugin>
                    <groupid>org.apache.maven.plugins</groupid>
                    <artifactid>maven-enforcer-plugin</artifactid>
                    <executions>
                        <execution>
                            <id>enforce-rules</id>
                            <goals>
                                <goal>enforce</goal>
                            </goals>
                            <configuration>
                                <rules>
                                    <banneddependencies>
                                        <excludes>
                                            <exclude>commons-logging:*:*</exclude>
                                        </excludes>
                                        <searchtransitive>true</searchtransitive>
                                    </banneddependencies>
                                </rules>
                                <fail>true</fail>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
                <plugin>
                    <groupid>org.apache.maven.plugins</groupid>
                    <artifactid>maven-install-plugin</artifactid>
                    <configuration>
                        <skip>true</skip>
                    </configuration>
                </plugin>
                <plugin>
                    <groupid>org.apache.maven.plugins</groupid>
                    <artifactid>maven-javadoc-plugin</artifactid>
                    <configuration>
                        <skip>true</skip>
                    </configuration>
                    <inherited>true</inherited>
                </plugin>
            </plugins>
        </build>
    </profile>
</profiles>
<repositories>
    <repository>
        <id>spring-milestone</id>
        <name>Spring Milestone</name>
        <url>https://repo.spring.io/milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
    <repository>
        <id>spring-snapshot</id>
        <name>Spring Snapshot</name>
        <url>https://repo.spring.io/snapshot</url>
        <snapshots>
            <enabled>true</enabled>
        </snapshots>
    </repository>
</repositories>

<p><strong>创建统一依赖管理</strong></p>
<p><strong>创建模块</strong> </p>
<p><img alt="img" data-src="clipboard1.png"></p>
<p><strong>修改pom</strong> </p>
<p><strong>更改打包方式为 pom</strong></p>
<ol>
<li>统一版本</li>
</ol>
<p><strong>这里注意了 spring boot 版本一定要对应 spring cloud版本 如果不对应 那么迎接而来的一定是各种莫名其妙的问题，而且还不会报版本错误，俗称版本坑</strong> </p>
<p>这是版本对应表</p>
<table>
<thead>
<tr>
<th>Spring Boot</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>1.2.x</td>
<td>Angel版本</td>
</tr>
<tr>
<td>1.3.x</td>
<td>Brixton版本</td>
</tr>
<tr>
<td>1.4.x stripes</td>
<td>Camden版本</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Dalston版本、Edgware版本</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Finchley版本</td>
</tr>
<tr>
<td>2.1.x</td>
<td>Greenwich.SR2</td>
</tr>
<tr>
<td>2.2.x</td>
<td>Hoxton</td>
</tr>
</tbody></table>
<p> <properties>          <!--这里填对应版本 列如我使用的是2.2.0 所以是-->         &lt;spring-cloud.version&gt;Hoxton.M3&lt;/spring-cloud.version&gt;         &lt;spring-cloud-alibaba.version&gt;0.9.0.RELEASE&lt;/spring-cloud-alibaba.version&gt;     </properties> </p>
<p>2.依赖cloud项目</p>
<dependencymanagement>
    <dependencies>
        <dependency>
            <groupid>org.springframework.cloud</groupid>
            <artifactid>spring-cloud-dependencies</artifactid>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupid>org.springframework.cloud</groupid>
            <artifactid>spring-cloud-alibaba-dependencies</artifactid>
            <version>${spring-cloud-alibaba.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencymanagement>



<p><strong>再让父pom依赖dependencies</strong></p>
<p>添加依赖管理 把整个项目的依赖交由dependencies管理</p>
<dependencymanagement>
    <dependencies>
        <dependency>
            <groupid>cn.dszmr</groupid>
            <artifactid>spring-cloud-demo-dependencies</artifactid>
            <version>${project.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencymanagement>
<modules>
    <module>spring-cloud-demo-dependencies</module>
</modules>





<p><strong>完整父pom文件（供参考）</strong></p>
<?xml version="1.0" encoding="UTF-8"?>
<p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <modelversion>4.0.0</modelversion><br>    <modules><br>        <module>spring-cloud-demo-dependencies</module><br>    </modules><br>    <parent><br>        <groupid>org.springframework.boot</groupid><br>        <artifactid>spring-boot-starter-parent</artifactid><br>        <version>2.2.0.RELEASE</version><br>        <relativepath> <!-- lookup parent from repository --><br>    </relativepath></parent><br>    <groupid>cn.dszmr</groupid><br>    <artifactid>spring-cloud-demo</artifactid><br>    <version>0.0.1-SNAPSHOT</version><br>    <name>spring-cloud-demo</name><br>    <packaging>pom</packaging><br>    <description>Demo project for Spring Boot</description></project></p>
<p>​    <properties><br>​        &lt;java.version&gt;1.8&lt;/java.version&gt;<br>​        &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt;<br>​        &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;<br>​        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br>​        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br>​    </properties></p>
<p>​    <dependencymanagement><br>​        <dependencies><br>​            <dependency><br>​                <groupid>cn.dszmr</groupid><br>​                <artifactid>spring-cloud-demo-dependencies</artifactid><br>​                <version>${project.version}</version><br>​                <type>pom</type><br>​                <scope>import</scope><br>​            </dependency><br>​        </dependencies><br>​    </dependencymanagement></p>
<p>​    <profiles><br>​        <profile><br>​            <id>default</id><br>​            <activation><br>​                <activebydefault>true</activebydefault><br>​            </activation><br>​            <properties><br>​                &lt;spring-javaformat.version&gt;0.0.12&lt;/spring-javaformat.version&gt;<br>​            </properties><br>​            <build><br>​                <plugins><br>​                    <plugin><br>​                        <groupid>io.spring.javaformat</groupid><br>​                        <artifactid>spring-javaformat-maven-plugin</artifactid><br>​                        <version>${spring-javaformat.version}</version><br>​                    </plugin><br>​                    <plugin><br>​                        <groupid>org.apache.maven.plugins</groupid><br>​                        <artifactid>maven-surefire-plugin</artifactid><br>​                        <configuration><br>​                            <includes><br>​                                <include><strong>/*Tests.java</strong></include><br>​                            </includes><br>​                            <excludes><br>​                                <exclude>/Abstract<em>.java</em></exclude><br>​                            </excludes><br>​                            <systempropertyvariables><br>​                                &lt;java.security.egd&gt;file:/dev/./urandom&lt;/java.security.egd&gt;<br>​                                &lt;java.awt.headless&gt;true&lt;/java.awt.headless&gt;<br>​                            </systempropertyvariables><br>​                        </configuration><br>​                    </plugin><br>​                    <plugin><br>​                        <groupid>org.apache.maven.plugins</groupid><br>​                        <artifactid>maven-enforcer-plugin</artifactid><br>​                        <executions><br>​                            <execution><br>​                                <id>enforce-rules</id><br>​                                <goals><br>​                                    <goal>enforce</goal><br>​                                </goals><br>​                                <configuration><br>​                                    <rules><br>​                                        <banneddependencies><br>​                                            <excludes><br>​                                                <exclude>commons-logging::*</exclude><br>​                                            </excludes><br>​                                            <searchtransitive>true</searchtransitive><br>​                                        </banneddependencies><br>​                                    </rules><br>​                                    <fail>true</fail><br>​                                </configuration><br>​                            </execution><br>​                        </executions><br>​                    </plugin><br>​                    <plugin><br>​                        <groupid>org.apache.maven.plugins</groupid><br>​                        <artifactid>maven-install-plugin</artifactid><br>​                        <configuration><br>​                            <skip>true</skip><br>​                        </configuration><br>​                    </plugin><br>​                    <plugin><br>​                        <groupid>org.apache.maven.plugins</groupid><br>​                        <artifactid>maven-javadoc-plugin</artifactid><br>​                        <configuration><br>​                            <skip>true</skip><br>​                        </configuration><br>​                        <inherited>true</inherited><br>​                    </plugin><br>​                </plugins><br>​            </build><br>​        </profile><br>​    </profiles><br>​    <repositories><br>​        <repository><br>​            <id>spring-milestone</id><br>​            <name>Spring Milestone</name><br>​            <url><span class="exturl" data-url="aHR0cHM6Ly9yZXBvLnNwcmluZy5pby9taWxlc3RvbmU=" title="https://repo.spring.io/milestone">https://repo.spring.io/milestone<i class="fa fa-external-link"></i></span></url><br>​            <snapshots><br>​                <enabled>false</enabled><br>​            </snapshots><br>​        </repository><br>​        <repository><br>​            <id>spring-snapshot</id><br>​            <name>Spring Snapshot</name><br>​            <url><span class="exturl" data-url="aHR0cHM6Ly9yZXBvLnNwcmluZy5pby9zbmFwc2hvdA==" title="https://repo.spring.io/snapshot">https://repo.spring.io/snapshot<i class="fa fa-external-link"></i></span></url><br>​            <snapshots><br>​                <enabled>true</enabled><br>​            </snapshots><br>​        </repository><br>​    </repositories></p>




<p><strong>完整dependencies依赖管理pom</strong></p>
<?xml version="1.0" encoding="UTF-8"?>
<p><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"><br>    <parent><br>        <artifactid>spring-cloud-demo</artifactid><br>        <groupid>cn.dszmr</groupid><br>        <version>0.0.1-SNAPSHOT</version><br>    </parent><br>    <modelversion>4.0.0</modelversion><br>    <packaging>pom</packaging></project></p>
<p>​    <artifactid>spring-cloud-demo-dependencies</artifactid><br>​    <properties><br>​        <!--这里填对应版本 列如我使用的是2.2.0 所以是Hoxton--><br>​        &lt;spring-cloud.version&gt;Hoxton.RELEASE&lt;/spring-cloud.version&gt;<br>​        &lt;spring-cloud-alibaba.version&gt;0.9.0.RELEASE&lt;/spring-cloud-alibaba.version&gt;<br>​    </properties></p>
<p>​    <dependencymanagement><br>​        <dependencies><br>​            <dependency><br>​                <groupid>org.springframework.cloud</groupid><br>​                <artifactid>spring-cloud-dependencies</artifactid><br>​                <version>${spring-cloud.version}</version><br>​                <type>pom</type><br>​                <scope>import</scope><br>​            </dependency><br>​            <dependency><br>​                <groupid>org.springframework.cloud</groupid><br>​                <artifactid>spring-cloud-alibaba-dependencies</artifactid><br>​                <version>${spring-cloud-alibaba.version}</version><br>​                <type>pom</type><br>​                <scope>import</scope><br>​            </dependency><br>​        </dependencies><br>​    </dependencymanagement></p>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>5，sentinel服务熔断</title>
    <url>/posts/24421a25/</url>
    <content><![CDATA[<p>sentinel是阿里巴巴开源，应对高并发场景的解决方案</p><p>下载解压</p><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMUx4ZGFnQlBpNDVJbXNzTkZ4SWxnbUE=" title="https://pan.baidu.com/s/1LxdagBPi45ImssNFxIlgmA">https://pan.baidu.com/s/1LxdagBPi45ImssNFxIlgmA<i class="fa fa-external-link"></i></span> 密码：t9so </p><p><img alt="img" data-src="clipboard.png"></p><p>点击启动文件启动项目</p><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5NTI3Lw==" title="http://localhost:9527/">http://localhost:9527<i class="fa fa-external-link"></i></span></p><p>账号 密码 都是 sentinel</p><p>修改服务消费者 consuner </p><a id="more"></a>







<p>填加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;     &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;     &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt; &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<p>修改配置文件</p>
<p>spring:<br>  application:<br>    # 服务名<br>​    name: service-consumer<br>  cloud:<br>​    nacos:<br>​      discovery:<br>        # 服务注册中心<br>​        server-addr: 192.168.141.132:8848<br>​      config:<br>        # 服务配置中心<br>​        server-addr: 192.168.141.132:8848<br>    # 熔断限流<br>​    sentinel:<br>​      transport:<br>​        dashboard: localhost:8888</p>
<h1 id="开启-Feign-对-Sentinel-的支持"><a href="#开启-Feign-对-Sentinel-的支持" class="headerlink" title="开启 Feign 对 Sentinel 的支持"></a>开启 Feign 对 Sentinel 的支持</h1><p>feign:<br>  sentinel:<br>    enabled: true<br>server:</p>
<h1 id="服务端口"><a href="#服务端口" class="headerlink" title="服务端口"></a>服务端口</h1><p>  port: 8080<br>management:</p>
<h1 id="端点检查（健康检查）"><a href="#端点检查（健康检查）" class="headerlink" title="端点检查（健康检查）"></a>端点检查（健康检查）</h1><p>  endpoints:<br>    web:<br>      exposure:<br>        include: “*”<br>test<br>    name: “dsz”</p>
<p>创建一个熔断类</p>
<p>继承service    当service无法请求到服务提供者时 将会执行这个方法的固定返回值</p>
<p>@Component public class EchoServiceFallback implements EchoService {     @Override     public String echo(String string) {         return “echo fallback”;     }     @Override     public String lb() {         return “lb fallback”;     } } </p>
<p>在service 的注解上添加 fallback 指向熔断类</p>
<p>@FeignClient(value = “service-provider”, fallback = EchoServiceFallback.class) </p>
<p>启动 consuner 关闭 provider</p>
<p>访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL2ZlaWduL2VjaG8vZHN6" title="http://localhost:8080/feign/echo/dsz">http://localhost:8080/feign/echo/dsz<i class="fa fa-external-link"></i></span></p>
<p><img alt="img" data-src="clipboard1.png"></p>
<p><img alt="img" data-src="clipboard2.png"></p>
]]></content>
      <categories>
        <category>Spring-Cloud-Alibaba</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
</search>
